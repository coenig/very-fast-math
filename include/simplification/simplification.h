// Auto-generated file using vfm's 'createCodeForAllSimplificationRules' function.
// Creation time: Sat May  3 08:05:33 2025

// Usage note: There are three simplification modes in vfm (only two are currently working) which have the following benefits (if in doubt use 2):
// 1) Runtime simplification via MathStruct::simplify(): Slowest, but can be triggered to provide detailed debugging information.
//    Allows adding and removing rules at runtime, e.g. via runInterpreter().
// 2) Hard-coded simplification via simplification::simplifyFast() in this file: About 300x faster than runtime version.
//    Very close to a theoretical speed limit, it appears (possibly still marginally slower than simplifyVeryFast(), once established).
//    Can be triggered to individually apply simplification rules to a formula via applyToFullFormula() function below.
//    Available in 'positive' (simplification_pos) and 'negative' (simplification) logic style, which are very similar in terms of runtime, though.
//    If in doubt, use the negative version of this function (simplification::simplifyFast) for full-feature simplification, because it's slightly faster.
// 3) Hard-coded simplification via simplification::simplifyVeryFast() in this file: Possibly up to 1.2x faster than regular hard-coded version, but monolithic.
//    CAUTION: THIS FUNCTION IS CURRENTLY UNDER CONSTRUCTION!

#pragma once
#include "term.h"
#include "meta_rule.h"
#include "parser.h"

namespace vfm {
namespace simplification {

// Unique operators at creation time. Overloading one of these might lead to errors in the simplification if they are part of a simplification rule.
static const std::set<std::string> NON_OVERLOADED_OPERATORS = { "!", "!=", "!==", "%", "&&", "*", "**", "+", "--", ".", ".C", ".D", "/", ":", ";", "<", "<=", "<=>", "=", "==", "===", "=>", ">", ">=", "?", "@f", "F", "F_bound", "G", "G_bound", "Get", "Get2", "Get3", "Getk", "H", "H_bound", "O", "O_bound", "Print", "S", "Set", "Set2", "Set3", "Setk", "T", "U", "V", "X", "Y", "Z", "_def_", "abs", "arccos", "arcsin", "arctan", "array", "array2", "array3", "arrayk", "boolify", "combineArrays", "compound", "copy", "cos", "dot", "fctin", "fib", "fillArray3", "for", "forRange", "free", "get", "id", "if", "ifelse", "isprime", "lambda", "length", "literal", "ln", "malloc", "max", "min", "o_", "p_", "print", "print2", "printErr", "print_plain", "printf", "printfln", "println", "q_func", "rand", "return", "rsqrt", "s_", "set", "sin", "sqrt", "square", "tan", "trunc", "while", "whilelim", "xnor", "xor", "||", };

// Overloaded operators at creation time.
static const std::set<std::string> OVERLOADED_OPERATORS = { "-", };

// All operators used in "from" part of simplification rules.
static const std::set<std::string> USED_OPERATORS = { "!", "!=", "!==", "%", "&&", "*", "**", "+", "-", "--", "/", ";", "<", "<=", "<=>", "=", "==", "===", "=>", ">", ">=", "F", "G", "U", "V", "X", "a_", "abs", "boolify", "compound", "free", "id", "if", "ifelse", "malloc", "max", "min", "o_", "print_plain", "s_", "sqrt", "trunc", "whilelim", "xnor", "xor", "||", };

// Autogenerated function to repeatedly apply a subset of meta rules to a whole formula, until no changes occur anymore.
//
// Caution: OPTIMIZE_AWAY_FIRST_CONDITION_FOR_FAST_SIMPLIFICATION is active, you'll not be able to use the rule-wise functions below out of the box
// (this does not affect simplifyFast() and simplifyVeryFast()).
// Instead of:
//    simplification::applyToFullFormula(formula, { simplification::apply__mult_31 });
// You'll need to do, e.g.:
//    simplification::applyToFullFormula(formula, { [](const TermPtr t, const std::shared_ptr<FormulaParser> p) {
//       return t->getOptor() != "*" ? false : simplification::apply__mult_31(t, p);
//    } });
inline TermPtr applyToFullFormula(
   const TermPtr formula_raw, 
   const std::vector<std::function<bool(const TermPtr, const std::shared_ptr<FormulaParser>)>>& funcs, 
   const std::shared_ptr<FormulaParser> parser_raw = nullptr,
   const bool eval_constant_subterms = false) 
{
   auto parser{ parser_raw ? parser_raw : SingletonFormulaParser::getInstance() };
   auto formula{ _id(formula_raw) };
   bool changed{ true };

   while (changed) {
      changed = false;
      formula->applyToMeAndMyChildrenIterative([&funcs, &changed, &parser, eval_constant_subterms](const MathStructPtr m) {

      if (eval_constant_subterms && !MetaRule::is_leaf(m) && !m->isCompoundOperator() && m->isOverallConstant()) {
         m->replace(_val_plain(m->constEval()));
         changed = true;
      }
      else {
         for (const auto& func : funcs)
            changed = func(m->toTermIfApplicable(), parser) || changed;
      }

      }, TraverseCompoundsType::avoid_compound_structures, FormulaTraversalType::PostOrder);
   }

   return formula->child0();
}

// Autogenerated function for meta rule:
// a != b ==> b != a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__notequal_0(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_neq(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a !== b ==> b !== a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__not__equal_1(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!==") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_napprox(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b && c ==> a && c && b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply__and_2(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_and(_and(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b ==> b && a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__and_3(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_and(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b * c ==> a * c * b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply__mult_4(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_mult(_mult(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b ==> b * a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__mult_5(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_mult(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * c ==> a -  --(b) * c [[b: 'is_constant_and_evaluates_to_negative']] $0
inline bool apply__plus_6(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_negative(formula_1_0) && MetaRule::no_check(formula)) {
      formula->replace(_minus(formula_0, _mult(_neg(formula_1_0), formula_1_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b + c ==> a + c + b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply__plus_7(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_plus(_plus(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b - c ==> (a + b) - c [[a + c: 'is_not_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__plus_8(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "-" || formula_1->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_not_constant(_plus_plain(formula_0, formula_1_1)) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(_plus(formula_0, formula_1_0), formula_1_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b - c ==> a - c + b [[c: 'is_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__plus_9(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "-" || formula_1->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(_minus(formula_0, formula_1_1), formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b ==> b + a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__plus_10(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_plus(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - b + c ==> (a + c) - b [[a + c: 'is_not_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__plus_11(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_not_constant(_plus_plain(formula_0_0, formula_1)) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(_plus(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a + b) - c ==> a - c + b [[a - c: 'is_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__minus_12(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(_minus_plain(formula_0_0, formula_1)) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(_minus(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a + b) - c ==> a - c + b [[a: 'is_constant', c: 'is_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__minus_13(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_0_0) && MetaRule::is_constant(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(_minus(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b) - c ==> (a - c) - b [[a: 'is_constant', c: 'is_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__minus_14(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_0_0) && MetaRule::is_constant(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(_minus(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b) - c ==> (a - c) - b [[c: 'is_constant', b: 'is_not_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__minus_15(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_1) && MetaRule::is_not_constant(formula_0_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(_minus(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b) - c ==> a - (c + b) [[b: 'is_constant', c: 'is_constant']] {{'has_no_sideeffects'}} $0
inline bool apply__minus_16(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_0_1) && MetaRule::is_constant(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(formula_0_0, _plus(formula_1, formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - (b + c) ==> (a - b) - c {{'has_no_sideeffects'}} $0
inline bool apply__minus_17(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(_minus(formula_0, formula_1_0), formula_1_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - (b - c) ==> a - b + c {{'has_no_sideeffects'}} $0
inline bool apply__minus_18(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "-" || formula_1->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(_minus(formula_0, formula_1_0), formula_1_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a <=> b <=> c ==> a <=> c <=> b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply__smallerorequal__greater_19(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "<=>") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "<=>") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_ltl_iff(_ltl_iff(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a <=> b ==> b <=> a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__smallerorequal__greater_20(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "<=>") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_ltl_iff(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a == b ==> b == a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__equal_21(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "==") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_eq(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a === b ==> b === a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__equal__equal_sign_22(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "===") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_approx(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ~(a, b) ==> ~(b, a) [[a: 'is_not_constant', b: 'is_constant', ~(a, b): 'is_commutative_operation', ~(a, b): 'is_associative_operation']] {{'parent_is_not_get'}} $0
inline bool apply__anyway_operation_23(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_not_constant(formula_0) && MetaRule::is_constant(formula_1) && MetaRule::is_commutative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_0, formula_1 })->toTermIfApplicable()) && MetaRule::is_associative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_0, formula_1 })->toTermIfApplicable()) && MetaRule::parent_is_not_get(formula)) {
      formula->replace(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1, formula_0 })->setChildrensFathers(false, false)->toTermIfApplicable());
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ~(~(a, b), c) ==> ~(~(a, c), b) [[c: 'is_constant', b: 'is_not_constant', ~(c, a): 'is_commutative_operation', ~(c, a): 'is_associative_operation']] $0
inline bool apply__anyway_operation_24(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula->getOptorOnCompoundLevel() != formula_0->getOptorOnCompoundLevel()) {
      return false;
   }
   if (formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_1) && MetaRule::is_not_constant(formula_0_1) && MetaRule::is_commutative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1, formula_0_0 })->toTermIfApplicable()) && MetaRule::is_associative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1, formula_0_0 })->toTermIfApplicable()) && MetaRule::no_check(formula)) {
      formula->replace(p->termFactory(formula->getOptorJumpIntoCompound(), { p->termFactory(formula->getOptorJumpIntoCompound(), { formula_0_0, formula_1 })->setChildrensFathers(false, false)->toTermIfApplicable(), formula_0_1 })->setChildrensFathers(false, false)->toTermIfApplicable());
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ~(~(a, b), c) ==> ~(~(c, b), a) [[c: 'is_constant', a: 'is_not_constant', ~(c, a): 'is_commutative_operation', ~(c, a): 'is_associative_operation']] $0
inline bool apply__anyway_operation_25(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula->getOptorOnCompoundLevel() != formula_0->getOptorOnCompoundLevel()) {
      return false;
   }
   if (formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_1) && MetaRule::is_not_constant(formula_0_0) && MetaRule::is_commutative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1, formula_0_0 })->toTermIfApplicable()) && MetaRule::is_associative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1, formula_0_0 })->toTermIfApplicable()) && MetaRule::no_check(formula)) {
      formula->replace(p->termFactory(formula->getOptorJumpIntoCompound(), { p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1, formula_0_1 })->setChildrensFathers(false, false)->toTermIfApplicable(), formula_0_0 })->setChildrensFathers(false, false)->toTermIfApplicable());
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// max(a, b) ==> max(b, a) [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply_max26(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "max") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_max(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// min(a, b) ==> min(b, a) [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply_min27(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "min") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_min(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a xnor b ==> b xnor a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply_xnor28(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "xnor") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_ltl_xnor(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a xnor b xnor c ==> a xnor c xnor b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply_xnor29(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "xnor") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "xnor") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_ltl_xnor(_ltl_xnor(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a xor b ==> b xor a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply_xor30(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "xor") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_ltl_xor(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a xor b xor c ==> a xor c xor b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply_xor31(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "xor") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "xor") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_ltl_xor(_ltl_xor(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || b ==> b || a [[a ; b: 'of_first_two_operands_second_is_alphabetically_above', a: 'is_variable', b: 'is_variable']] $0
inline bool apply__or_32(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0, formula_1)) && MetaRule::is_variable(formula_0) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_or(formula_1, formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || b || c ==> a || c || b [[b ; c: 'of_first_two_operands_second_is_alphabetically_above', b: 'is_variable', c: 'is_variable']] $0
inline bool apply__or_33(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1, formula_1)) && MetaRule::is_variable(formula_0_1) && MetaRule::is_variable(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_or(_or(formula_0_0, formula_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(!(a)) ==> boolify(a) $10
inline bool apply__not_34(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "!") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !((a != b)) ==> a == b $10
inline bool apply__not_35(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "!=") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_eq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !((a < b)) ==> a >= b $10
inline bool apply__not_36(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "<") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_greq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !((a <= b)) ==> a > b $10
inline bool apply__not_37(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "<=") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_gr(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !((a == b)) ==> a != b $10
inline bool apply__not_38(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "==") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_neq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !((a > b)) ==> a <= b $10
inline bool apply__not_39(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != ">") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_smeq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !((a >= b)) ==> a < b $10
inline bool apply__not_40(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != ">=") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_sm(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(F(a)) ==> G(!(a)) $10
inline bool apply__not_41(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "F") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_globally(_not(formula_0_0)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(G(a)) ==> F(!(a)) $10
inline bool apply__not_42(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "G") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_finally(_not(formula_0_0)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(X(a)) ==> X(!(a)) $10
inline bool apply__not_43(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "X") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_next(_not(formula_0_0)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a && b) ==> !(a) || !(b) $10
inline bool apply__not_44(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_or(_not(formula_0_0), _not(formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a <=> b) ==> !(a) <=> !(b) $10
inline bool apply__not_45(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "<=>") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_iff(_not(formula_0_0), _not(formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a => b) ==> a && !(b) $10
inline bool apply__not_46(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "=>") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_and(formula_0_0, _not(formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a U b) ==> !(a) V !(b) $10
inline bool apply__not_47(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "U") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_released(_not(formula_0_0), _not(formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a V b) ==> !(a) U !(b) $10
inline bool apply__not_48(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "V") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_until(_not(formula_0_0), _not(formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a || b) ==> !(a) && !(b) $10
inline bool apply__not_49(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_and(_not(formula_0_0), _not(formula_0_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(boolify(a)) ==> !(a) $10
inline bool apply__not_50(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "boolify") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_not(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) !=  --(b) ==> a != b $10
inline bool apply__notequal_51(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_neq(formula_0_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a != a ==> 0 {{'has_no_sideeffects'}} $10
inline bool apply__notequal_52(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a != b ==> boolify(a) [[b: 'is_constant_and_evaluates_to_false', a: 'contains_no_meta']] $10
inline bool apply__notequal_53(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_1) && MetaRule::contains_no_meta(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a != b ==> boolify(b) [[a: 'is_constant_and_evaluates_to_false', b: 'contains_no_meta']] $10
inline bool apply__notequal_54(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "!=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_0) && MetaRule::contains_no_meta(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a % b * c % b) % b ==> (a * c) % b {{'has_no_sideeffects'}} $10
inline bool apply__modulo_55(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "%") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->getOptorOnCompoundLevel() != "%") {
      return false;
   }
   TermPtr formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->getOptorOnCompoundLevel() != "%") {
      return false;
   }
   TermPtr formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_0_1->isStructurallyEqual(formula_0_1_1) && formula_0_0_1->isStructurallyEqual(formula_1) && formula_0_1_1->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mod(_mult(formula_0_0_0, formula_0_1_0), formula_0_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a || b) && (b || c) ==> a && c || b {{'has_no_sideeffects'}} $10
inline bool apply__and_56(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_or(_and(formula_0_0, formula_1_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a || b) && (c || a) ==> b && c || a {{'has_no_sideeffects'}} $10
inline bool apply__and_57(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_or(_and(formula_0_1, formula_1_0), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a || b) && (c || b) ==> a && c || b {{'has_no_sideeffects'}} $10
inline bool apply__and_58(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_or(_and(formula_0_0, formula_1_0), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a || b) && a ==> b && 0 || a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__and_59(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_or(_and(formula_0_1, _val(0.000000)), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a || b) && b ==> a && 0 || b [[b: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__and_60(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_or(_and(formula_0_0, _val(0.000000)), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 0 && a ==> 0 [[a: 'has_no_sideeffects']] $10
inline bool apply__and_61(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 1 && a ==> boolify(a) $10
inline bool apply__and_62(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && (b || a) ==> 0 && b || a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__and_63(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1_1) && MetaRule::is_not_constant(formula_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_or(_and(_val(0.000000), formula_1_0), formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && 0 ==> 0 [[a: 'has_no_sideeffects']] $10
inline bool apply__and_64(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && 1 ==> boolify(a) $10
inline bool apply__and_65(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b ==> 0 [[a ; b: 'first_two_operands_are_negations_of_each_other']] {{'has_no_sideeffects'}} $10
inline bool apply__and_66(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_1)) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b ==> a && boolify(b) [[b: 'is_non_boolean_constant']] $10
inline bool apply__and_67(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_non_boolean_constant(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_and(formula_0, _boolify(formula_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b ==> boolify(a) && b [[a: 'is_non_boolean_constant']] $10
inline bool apply__and_68(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_non_boolean_constant(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_and(_boolify(formula_0), formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && boolify(b) ==> a && b [[b: 'is_not_non_boolean_constant']] $10
inline bool apply__and_69(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "boolify") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::is_not_non_boolean_constant(formula_1_0) && MetaRule::no_check(formula)) {
      formula->replace(_and(formula_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// boolify(a) && b ==> a && b [[a: 'is_not_non_boolean_constant']] $10
inline bool apply__and_70(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "&&") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "boolify") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::is_not_non_boolean_constant(formula_0_0) && MetaRule::no_check(formula)) {
      formula->replace(_and(formula_0_0, formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 0 * a ==> 0 [[a: 'has_no_sideeffects']] $10
inline bool apply__mult_71(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 1 * a ==> id(a) $10
inline bool apply__mult_72(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 1 / a * a ==> 1 [[a: 'is_constant_and_evaluates_to_true']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_73(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "/") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (!formula_0_0->isTermVal() || formula_0_0->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (formula_0_1->isStructurallyEqual(formula_1) && MetaRule::is_constant_and_evaluates_to_true(formula_0_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a *  --(b) ==>  --(a * b) $10
inline bool apply__mult_74(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_neg(_mult(formula_0, formula_1_0)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * 0 ==> 0 [[a: 'has_no_sideeffects']] $10
inline bool apply__mult_75(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * 1 / a ==> 1 [[a: 'is_constant_and_evaluates_to_true']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_76(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "/") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (!formula_1_0->isTermVal() || formula_1_0->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (formula_0->isStructurallyEqual(formula_1_1) && MetaRule::is_constant_and_evaluates_to_true(formula_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * 1 ==> id(a) $10
inline bool apply__mult_77(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b ** o_(c, 1) * b ** o_(d, 1) ==> a * b ** (id(c) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__mult_78(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(_id(formula_0_1_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b ** o_(c, 1) * d ** o_(e, 1) ==> a * b ** (id(c) + id(ln(d) / ln(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_79(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(_id(formula_0_1_1), _id(_mult(_div(_ln(formula_1_0), _ln(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b ** o_(c, 1) * d ** o_(e, 1) ==> a * d ** (id(ln(b) / ln(d) * c) + id(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(b) / ln(d): 'is_constant_integer', b / d == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_80(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_1_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_0, formula_1_0), formula_0_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_1_0, _plus(_id(_mult(_div(_ln(formula_0_1_0), _ln(formula_1_0->copy())), formula_0_1_1)), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b ==>  --(a *  --(b)) [[b: 'is_constant_and_evaluates_to_negative']] $10
inline bool apply__mult_81(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_negative(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_neg(_mult(formula_0, _neg(formula_1))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** o_(b, 1) * c * a ** o_(d, 1) ==> c * a ** (id(b) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__mult_82(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_0_0_0, _plus(_id(formula_0_0_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** o_(b, 1) * c * d ** o_(e, 1) ==> c * a ** (id(b) + id(ln(d) / ln(a) * e)) [[a: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(a): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_83(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_0_0_0, _plus(_id(formula_0_0_1), _id(_mult(_div(_ln(formula_1_0), _ln(formula_0_0_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** o_(b, 1) * c * d ** o_(e, 1) ==> c * d ** (id(ln(a) / ln(d) * b) + id(e)) [[d: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', ln(a) / ln(d): 'is_constant_integer', a / d == a: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_84(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_0_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_0_0, formula_1_0), formula_0_0_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_1_0, _plus(_id(_mult(_div(_ln(formula_0_0_0), _ln(formula_1_0->copy())), formula_0_0_1)), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** o_(b, 1) * o_(c, 1) * a ** o_(d, 1) ==> c * a ** (b + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__mult_85(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_0_0_0, _plus(formula_0_0_1, _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** o_(b, 1) * o_(c, 1) * d ** o_(e, 1) ==> c * a ** (b + id(ln(d) / ln(a) * e)) [[a: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(a): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_86(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_0_0_0, _plus(formula_0_0_1, _id(_mult(_div(_ln(formula_1_0), _ln(formula_0_0_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** o_(b, 1) * o_(c, 1) * d ** o_(e, 1) ==> c * d ** (ln(a) / ln(d) * b + id(e)) [[d: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', ln(a) / ln(d): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_87(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_0_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_1_0, _plus(_mult(_div(_ln(formula_0_0_0), _ln(formula_1_0->copy())), formula_0_0_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b ** o_(c, 1) * b ** o_(d, 1) ==> a * b ** (c + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__mult_88(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = _val_plain(1.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(formula_0_1_1, _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b ** o_(c, 1) * d ** o_(e, 1) ==> a * b ** (c + id(ln(d) / ln(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_89(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = _val_plain(1.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(formula_0_1_1, _id(_mult(_div(_ln(formula_1_0), _ln(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b ** o_(c, 1) * d ** o_(e, 1) ==> a * d ** (ln(b) / ln(d) * c + id(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(b) / ln(d): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__mult_90(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "*") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = _val_plain(1.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_1_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_1_0, _plus(_mult(_div(_ln(formula_0_1_0), _ln(formula_1_0->copy())), formula_0_1_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 1 ** a ==> 1 [[a: 'has_no_sideeffects']] $10
inline bool apply__pow_91(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "**") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ** 1 ==> id(a) $10
inline bool apply__pow_92(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "**") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) + b ==> b - a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_93(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::is_not_constant(formula_0_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_minus(formula_1, formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 0 + a ==> id(a) $10
inline bool apply__plus_94(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b + a ==> (b + 1) * a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_95(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_plus(formula_0_1, _val(1.000000)), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b + b * c ==> (a + c) * b {{'has_no_sideeffects'}} $10
inline bool apply__plus_96(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_plus(formula_0_0, formula_1_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b + b ==> (a + 1) * b [[b: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_97(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_plus(formula_0_0, _val(1.000000)), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b + c * a ==> (b + c) * a {{'has_no_sideeffects'}} $10
inline bool apply__plus_98(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_plus(formula_0_1, formula_1_0), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b + c * b ==> (a + c) * b {{'has_no_sideeffects'}} $10
inline bool apply__plus_99(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_plus(formula_0_0, formula_1_0), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + c + a * o_(d, 1) ==> c + a * (id(b) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_100(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(_id(formula_0_0_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + c + d * o_(e, 1) ==> c + a * (id(b) + id(id(d) / id(a) * e)) [[a: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', id(d) / id(a): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_101(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(_id(formula_0_0_1), _id(_mult(_div(_id(formula_1_0), _id(formula_0_0_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + c + d * o_(e, 1) ==> c + d * (id(id(a) / id(d) * b) + id(e)) [[d: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', id(a) / id(d): 'is_constant_integer', a / d == a: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_102(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_0_0, formula_1_0), formula_0_0_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_0, _plus(_id(_mult(_div(_id(formula_0_0_0), _id(formula_1_0->copy())), formula_0_0_1)), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + c + o_(d, 1) * a ==> c + a * (id(b) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_103(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(_id(formula_0_0_1), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + c + o_(d, 1) * e ==> c + a * (id(b) + id(id(e) / id(a) * d)) [[a: 'is_constant_and_evaluates_to_true', a == e: 'is_constant_and_evaluates_to_false', id(e) / id(a): 'is_constant_integer', e / a == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_104(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(_id(formula_0_0_1), _id(_mult(_div(_id(formula_1_1), _id(formula_0_0_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + c + o_(d, 1) * e ==> c + e * (id(id(a) / id(e) * b) + id(d)) [[e: 'is_constant_and_evaluates_to_true', a == e: 'is_constant_and_evaluates_to_false', id(a) / id(e): 'is_constant_integer', a / e == a: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_105(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_0_0, formula_1_1), formula_0_0_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_1, _plus(_id(_mult(_div(_id(formula_0_0_0), _id(formula_1_1->copy())), formula_0_0_1)), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + o_(c, 0) + a * o_(d, 1) ==> c + a * (b + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_106(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + o_(c, 0) + d * o_(e, 1) ==> c + a * (b + id(id(d) / id(a) * e)) [[a: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', id(d) / id(a): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_107(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _id(_mult(_div(_id(formula_1_0), _id(formula_0_0_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + o_(c, 0) + d * o_(e, 1) ==> c + d * (id(a) / id(d) * b + id(e)) [[d: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', id(a) / id(d): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_108(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_0_0), _id(formula_1_0->copy())), formula_0_0_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + o_(c, 0) + o_(d, 1) * a ==> c + a * (b + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_109(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + o_(c, 0) + o_(d, 1) * e ==> c + a * (b + id(id(e) / id(a) * d)) [[a: 'is_constant_and_evaluates_to_true', a == e: 'is_constant_and_evaluates_to_false', id(e) / id(a): 'is_constant_integer', e / a == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_110(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _id(_mult(_div(_id(formula_1_1), _id(formula_0_0_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * o_(b, 1) + o_(c, 0) + o_(d, 1) * e ==> c + e * (id(a) / id(e) * b + id(d)) [[e: 'is_constant_and_evaluates_to_true', a == e: 'is_constant_and_evaluates_to_false', id(a) / id(e): 'is_constant_integer', e / a == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_111(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_0_0), _id(formula_1_1->copy())), formula_0_0_1), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a +  --(b) ==> a - b $10
inline bool apply__plus_112(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_minus(formula_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + 0 ==> id(a) $10
inline bool apply__plus_113(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * a ==> (1 + b) * a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_114(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1_1) && MetaRule::is_not_constant(formula_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_plus(_val(1.000000), formula_1_0), formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * o_(c, 1) + b * o_(d, 1) ==> a + b * (id(c) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_115(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_id(formula_0_1_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * o_(c, 1) + d * o_(e, 1) ==> a + b * (id(c) + id(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_116(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_id(formula_0_1_1), _id(_mult(_div(_id(formula_1_0), _id(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * o_(c, 1) + d * o_(e, 1) ==> a + d * (id(id(b) / id(d) * c) + id(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', b / d == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_117(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_0, formula_1_0), formula_0_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_id(_mult(_div(_id(formula_0_1_0), _id(formula_1_0->copy())), formula_0_1_1)), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * o_(c, 1) + o_(d, 1) * b ==> a + b * (id(c) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_118(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_id(formula_0_1_1), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * o_(c, 1) + o_(d, 1) * e ==> a + b * (id(c) + id(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_119(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_id(formula_0_1_1), _id(_mult(_div(_id(formula_1_1), _id(formula_0_1_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + b * o_(c, 1) + o_(d, 1) * e ==> a + e * (id(id(b) / id(e) * c) + id(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', b / e == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_120(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_0, formula_1_1), formula_0_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_id(_mult(_div(_id(formula_0_1_0), _id(formula_1_1->copy())), formula_0_1_1)), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + o_(b, 1) * c + c * o_(d, 1) ==> a + c * (id(b) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_121(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_id(formula_0_1_0), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + o_(b, 1) * c + d * o_(e, 1) ==> a + c * (id(b) + id(id(d) / id(c) * e)) [[c: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(d) / id(c): 'is_constant_integer', d / c == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_122(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_id(formula_0_1_0), _id(_mult(_div(_id(formula_1_0), _id(formula_0_1_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + o_(b, 1) * c + d * o_(e, 1) ==> a + d * (id(id(c) / id(d) * b) + id(e)) [[d: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(c) / id(d): 'is_constant_integer', c / d == c: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_123(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_1, formula_1_0), formula_0_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_id(_mult(_div(_id(formula_0_1_1), _id(formula_1_0->copy())), formula_0_1_0)), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + o_(b, 1) * c + o_(d, 1) * c ==> a + c * (id(b) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_124(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_id(formula_0_1_0), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + o_(b, 1) * c + o_(d, 1) * e ==> a + c * (id(b) + id(id(e) / id(c) * d)) [[c: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(e) / id(c): 'is_constant_integer', e / c == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_125(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_id(formula_0_1_0), _id(_mult(_div(_id(formula_1_1), _id(formula_0_1_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a + o_(b, 1) * c + o_(d, 1) * e ==> a + e * (id(id(c) / id(e) * b) + id(d)) [[e: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(c) / id(e): 'is_constant_integer', c / e == c: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_126(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_1, formula_1_1), formula_0_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_id(_mult(_div(_id(formula_0_1_1), _id(formula_1_1->copy())), formula_0_1_0)), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + b * o_(c, 1) + b * o_(d, 1) ==> a + b * (c + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_127(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + b * o_(c, 1) + d * o_(e, 1) ==> a + b * (c + id(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_128(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _id(_mult(_div(_id(formula_1_0), _id(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + b * o_(c, 1) + d * o_(e, 1) ==> a + d * (id(b) / id(d) * c + id(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_129(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_1_0), _id(formula_1_0->copy())), formula_0_1_1), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + b * o_(c, 1) + o_(d, 1) * b ==> a + b * (c + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_130(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + b * o_(c, 1) + o_(d, 1) * e ==> a + b * (c + id(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_131(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _id(_mult(_div(_id(formula_1_1), _id(formula_0_1_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + b * o_(c, 1) + o_(d, 1) * e ==> a + e * (id(b) / id(e) * c + id(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_132(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_1_0), _id(formula_1_1->copy())), formula_0_1_1), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + o_(b, 1) * c + c * o_(d, 1) ==> a + c * (b + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_133(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + o_(b, 1) * c + d * o_(e, 1) ==> a + c * (b + id(id(d) / id(c) * e)) [[c: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(d) / id(c): 'is_constant_integer', d / c == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_134(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _id(_mult(_div(_id(formula_1_0), _id(formula_0_1_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + o_(b, 1) * c + d * o_(e, 1) ==> a + d * (id(c) / id(d) * b + id(e)) [[d: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(c) / id(d): 'is_constant_integer', d / c == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_135(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_1_1), _id(formula_1_0->copy())), formula_0_1_0), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + o_(b, 1) * c + o_(d, 1) * c ==> a + c * (b + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_136(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + o_(b, 1) * c + o_(d, 1) * e ==> a + c * (b + id(id(e) / id(c) * d)) [[c: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(e) / id(c): 'is_constant_integer', e / c == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_137(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _id(_mult(_div(_id(formula_1_1), _id(formula_0_1_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) + o_(b, 1) * c + o_(d, 1) * e ==> a + e * (id(c) / id(e) * b + id(d)) [[e: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(c) / id(e): 'is_constant_integer', e / c == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_138(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_1_1), _id(formula_1_1->copy())), formula_0_1_0), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + c + b * o_(d, 1) ==> c + b * (id(a) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_139(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(_id(formula_0_0_0), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + c + d * o_(e, 1) ==> c + b * (id(a) + id(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_140(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_0_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(_id(formula_0_0_0), _id(_mult(_div(_id(formula_1_0), _id(formula_0_0_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + c + d * o_(e, 1) ==> c + d * (id(id(b) / id(d) * a) + id(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', b / d == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_141(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_0_1, formula_1_0), formula_0_0_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_0, _plus(_id(_mult(_div(_id(formula_0_0_1), _id(formula_1_0->copy())), formula_0_0_0)), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + c + o_(d, 1) * b ==> c + b * (id(a) + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_142(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(_id(formula_0_0_0), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + c + o_(d, 1) * e ==> c + b * (id(a) + id(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_143(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_0_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(_id(formula_0_0_0), _id(_mult(_div(_id(formula_1_1), _id(formula_0_0_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + c + o_(d, 1) * e ==> c + e * (id(id(b) / id(e) * a) + id(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', b / e == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_144(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_0_1, formula_1_1), formula_0_0_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_1, _plus(_id(_mult(_div(_id(formula_0_0_1), _id(formula_1_1->copy())), formula_0_0_0)), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + o_(c, 0) + b * o_(d, 1) ==> c + b * (a + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_145(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + o_(c, 0) + d * o_(e, 1) ==> c + b * (a + id(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_146(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_0_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _id(_mult(_div(_id(formula_1_0), _id(formula_0_0_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + o_(c, 0) + d * o_(e, 1) ==> c + d * (id(b) / id(d) * a + id(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_147(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_0_1), _id(formula_1_0->copy())), formula_0_0_0), _id(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + o_(c, 0) + o_(d, 1) * b ==> c + b * (a + id(d)) {{'has_no_sideeffects'}} $10
inline bool apply__plus_148(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + o_(c, 0) + o_(d, 1) * e ==> c + b * (a + id(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_149(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_0_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _id(_mult(_div(_id(formula_1_1), _id(formula_0_0_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 1) * b + o_(c, 0) + o_(d, 1) * e ==> c + e * (id(b) / id(e) * a + id(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__plus_150(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "+") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_0_1), _id(formula_1_1->copy())), formula_0_0_0), _id(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) - b ==>  --(a + b) $10
inline bool apply__minus_151(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_neg(_plus(formula_0_0, formula_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a * o_(b, 1) + o_(c, 0)) - a * o_(d, 1) ==> c + a * (b +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_152(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a * o_(b, 1) + o_(c, 0)) - d * o_(e, 1) ==> c + a * (b +  --(id(d) / id(a) * e)) [[a: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', id(d) / id(a): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_153(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _neg(_mult(_div(_id(formula_1_0), _id(formula_0_0_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a * o_(b, 1) + o_(c, 0)) - d * o_(e, 1) ==> c + d * (id(a) / id(d) * b +  --(e)) [[d: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', id(a) / id(d): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_154(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_0_0), _id(formula_1_0->copy())), formula_0_0_1), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a * o_(b, 1) + o_(c, 0)) - o_(d, 1) * a ==> c + a * (b +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_155(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a * o_(b, 1) + o_(c, 0)) - o_(d, 1) * e ==> c + a * (b +  --(id(e) / id(a) * d)) [[a: 'is_constant_and_evaluates_to_true', a == e: 'is_constant_and_evaluates_to_false', id(e) / id(a): 'is_constant_integer', e / a == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_156(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_0, _plus(formula_0_0_1, _neg(_mult(_div(_id(formula_1_1), _id(formula_0_0_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a * o_(b, 1) + o_(c, 0)) - o_(d, 1) * e ==> c + e * (id(a) / id(e) * b +  --(d)) [[e: 'is_constant_and_evaluates_to_true', a == e: 'is_constant_and_evaluates_to_false', id(a) / id(e): 'is_constant_integer', e / a == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_157(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_0_0), _id(formula_1_1->copy())), formula_0_0_1), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b * o_(c, 1)) - b * o_(d, 1) ==> a + b * ( --(c) +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_158(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_neg(formula_0_1_1), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b * o_(c, 1)) - d * o_(e, 1) ==> a + b * ( --(c) +  --(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_159(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_neg(formula_0_1_1), _neg(_mult(_div(_id(formula_1_0), _id(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b * o_(c, 1)) - d * o_(e, 1) ==> a + d * ( --(id(b) / id(d) * c) +  --(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', b / d == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_160(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_0, formula_1_0), formula_0_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_neg(_mult(_div(_id(formula_0_1_0), _id(formula_1_0->copy())), formula_0_1_1)), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b * o_(c, 1)) - o_(d, 1) * b ==> a + b * ( --(c) +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_161(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_neg(formula_0_1_1), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b * o_(c, 1)) - o_(d, 1) * e ==> a + b * ( --(c) +  --(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_162(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(_neg(formula_0_1_1), _neg(_mult(_div(_id(formula_1_1), _id(formula_0_1_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - b * o_(c, 1)) - o_(d, 1) * e ==> a + e * ( --(id(b) / id(e) * c) +  --(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', b / e == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_163(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_0, formula_1_1), formula_0_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_neg(_mult(_div(_id(formula_0_1_0), _id(formula_1_1->copy())), formula_0_1_1)), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - o_(b, 1) * c) - c * o_(d, 1) ==> a + c * ( --(b) +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_164(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_neg(formula_0_1_0), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - o_(b, 1) * c) - d * o_(e, 1) ==> a + c * ( --(b) +  --(id(d) / id(c) * e)) [[c: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(d) / id(c): 'is_constant_integer', d / c == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_165(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_neg(formula_0_1_0), _neg(_mult(_div(_id(formula_1_0), _id(formula_0_1_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - o_(b, 1) * c) - d * o_(e, 1) ==> a + d * ( --(id(c) / id(d) * b) +  --(e)) [[d: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(c) / id(d): 'is_constant_integer', c / d == c: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_166(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_1, formula_1_0), formula_0_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_neg(_mult(_div(_id(formula_0_1_1), _id(formula_1_0->copy())), formula_0_1_0)), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - o_(b, 1) * c) - o_(d, 1) * c ==> a + c * ( --(b) +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_167(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_neg(formula_0_1_0), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - o_(b, 1) * c) - o_(d, 1) * e ==> a + c * ( --(b) +  --(id(e) / id(c) * d)) [[c: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(e) / id(c): 'is_constant_integer', e / c == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_168(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(_neg(formula_0_1_0), _neg(_mult(_div(_id(formula_1_1), _id(formula_0_1_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a - o_(b, 1) * c) - o_(d, 1) * e ==> a + e * ( --(id(c) / id(e) * b) +  --(d)) [[e: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(c) / id(e): 'is_constant_integer', c / e == c: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_169(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "-" || formula_0->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_1, formula_1_1), formula_0_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_neg(_mult(_div(_id(formula_0_1_1), _id(formula_1_1->copy())), formula_0_1_0)), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + b * o_(c, 1)) - b * o_(d, 1) ==> a + b * (c +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_170(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + b * o_(c, 1)) - d * o_(e, 1) ==> a + b * (c +  --(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_171(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _neg(_mult(_div(_id(formula_1_0), _id(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + b * o_(c, 1)) - d * o_(e, 1) ==> a + d * (id(b) / id(d) * c +  --(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_172(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_1_0), _id(formula_1_0->copy())), formula_0_1_1), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + b * o_(c, 1)) - o_(d, 1) * b ==> a + b * (c +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_173(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + b * o_(c, 1)) - o_(d, 1) * e ==> a + b * (c +  --(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_174(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_0, _plus(formula_0_1_1, _neg(_mult(_div(_id(formula_1_1), _id(formula_0_1_0->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + b * o_(c, 1)) - o_(d, 1) * e ==> a + e * (id(b) / id(e) * c +  --(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_175(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_0), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_0), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_1_0), _id(formula_1_1->copy())), formula_0_1_1), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + o_(b, 1) * c) - c * o_(d, 1) ==> a + c * (b +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_176(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + o_(b, 1) * c) - d * o_(e, 1) ==> a + c * (b +  --(id(d) / id(c) * e)) [[c: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(d) / id(c): 'is_constant_integer', d / c == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_177(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _neg(_mult(_div(_id(formula_1_0), _id(formula_0_1_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + o_(b, 1) * c) - d * o_(e, 1) ==> a + d * (id(c) / id(d) * b +  --(e)) [[d: 'is_constant_and_evaluates_to_true', c == d: 'is_constant_and_evaluates_to_false', id(c) / id(d): 'is_constant_integer', d / c == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_178(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_1_1), _id(formula_1_0->copy())), formula_0_1_0), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + o_(b, 1) * c) - o_(d, 1) * c ==> a + c * (b +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_179(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + o_(b, 1) * c) - o_(d, 1) * e ==> a + c * (b +  --(id(e) / id(c) * d)) [[c: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(e) / id(c): 'is_constant_integer', e / c == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_180(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_0_1_1, _plus(formula_0_1_0, _neg(_mult(_div(_id(formula_1_1), _id(formula_0_1_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 0) + o_(b, 1) * c) - o_(d, 1) * e ==> a + e * (id(c) / id(e) * b +  --(d)) [[e: 'is_constant_and_evaluates_to_true', c == e: 'is_constant_and_evaluates_to_false', id(c) / id(e): 'is_constant_integer', e / c == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_181(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0; // This is an optional term.
   TermPtr formula_0_1_1;
   if (formula_0_1->getOptorOnCompoundLevel() != "*") {
      formula_0_1_0 = _val_plain(1.000000);
      formula_0_1_1 = formula_0_1;
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_1_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_1_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_0, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_1_1), _id(formula_1_1->copy())), formula_0_1_0), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b + o_(c, 0)) - b * o_(d, 1) ==> c + b * (a +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_182(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b + o_(c, 0)) - d * o_(e, 1) ==> c + b * (a +  --(id(d) / id(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(d) / id(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_183(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_0), _id_plain(formula_0_0_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _neg(_mult(_div(_id(formula_1_0), _id(formula_0_0_1->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b + o_(c, 0)) - d * o_(e, 1) ==> c + d * (id(b) / id(d) * a +  --(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', id(b) / id(d): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_184(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_1), _id_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_1), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_0, _plus(_mult(_div(_id(formula_0_0_1), _id(formula_1_0->copy())), formula_0_0_0), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b + o_(c, 0)) - o_(d, 1) * b ==> c + b * (a +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__minus_185(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b + o_(c, 0)) - o_(d, 1) * e ==> c + b * (a +  --(id(e) / id(b) * d)) [[b: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(e) / id(b): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_186(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_1_1), _id_plain(formula_0_0_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_0_0_1, _plus(formula_0_0_0, _neg(_mult(_div(_id(formula_1_1), _id(formula_0_0_1->copy())), formula_1_0))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b + o_(c, 0)) - o_(d, 1) * e ==> c + e * (id(b) / id(e) * a +  --(d)) [[e: 'is_constant_and_evaluates_to_true', b == e: 'is_constant_and_evaluates_to_false', id(b) / id(e): 'is_constant_integer', e / b == e: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_187(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "+") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(0.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0; // This is an optional term.
   TermPtr formula_0_0_1;
   if (formula_0_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0_0 = _val_plain(1.000000);
      formula_0_0_1 = formula_0_0;
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0; // This is an optional term.
   TermPtr formula_1_1;
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      formula_1_0 = _val_plain(1.000000);
      formula_1_1 = formula_1;
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_1) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_1, formula_1_1)) && MetaRule::is_constant_integer(_div_plain(_id_plain(formula_0_0_1), _id_plain(formula_1_1))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_1, formula_0_0_1), formula_1_1->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_plus(formula_0_1, _mult(formula_1_1, _plus(_mult(_div(_id(formula_0_0_1), _id(formula_1_1->copy())), formula_0_0_0), _neg(formula_1_0)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 0 - a ==>  --(a) $10
inline bool apply__minus_188(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_neg(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b - a ==> (b - 1) * a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_189(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_minus(formula_0_1, _val(1.000000)), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b - b * c ==> (a - c) * b {{'has_no_sideeffects'}} $10
inline bool apply__minus_190(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_minus(formula_0_0, formula_1_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b - b ==> (a - 1) * b [[b: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_191(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_minus(formula_0_0, _val(1.000000)), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b - c * a ==> (b - c) * a {{'has_no_sideeffects'}} $10
inline bool apply__minus_192(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_minus(formula_0_1, formula_1_0), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b - c * b ==> (a - c) * b {{'has_no_sideeffects'}} $10
inline bool apply__minus_193(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_minus(formula_0_0, formula_1_0), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a -  --(b) ==> a + b $10
inline bool apply__minus_194(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_plus(formula_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - 0 ==> id(a) $10
inline bool apply__minus_195(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - b * a ==> (1 - b) * a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__minus_196(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1_1) && MetaRule::is_not_constant(formula_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(_minus(_val(1.000000), formula_1_0), formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - b ==>  --(b) + a [[b: 'is_constant', a: 'is_not_constant']] $10
inline bool apply__minus_197(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_1) && MetaRule::is_not_constant(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_plus(_neg(formula_1), formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a - b ==> a +  --(b) [[b: 'is_constant_and_evaluates_to_negative']] $10
inline bool apply__minus_198(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "-" || formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_negative(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_plus(formula_0, _neg(formula_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --( --(a)) ==> a $10
inline bool apply__minus__minus_199(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "--") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(formula_0_0);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a * b) ==>  --(a) * b [[a: 'is_constant']] $10
inline bool apply__minus__minus_200(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "--") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_0_0) && MetaRule::no_check(formula)) {
      formula->replace(_mult(_neg(formula_0_0), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a ** o_(b, 1) * o_(c, 1)) / a ** o_(d, 1) ==> c * a ** (b +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__div_201(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_0_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_0_0_0, _plus(formula_0_0_1, _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a ** o_(b, 1) * o_(c, 1)) / d ** o_(e, 1) ==> c * a ** (b +  --(ln(d) / ln(a) * e)) [[a: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(a): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__div_202(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_0_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_0_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_0_0_0, _plus(formula_0_0_1, _neg(_mult(_div(_ln(formula_1_0), _ln(formula_0_0_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a ** o_(b, 1) * o_(c, 1)) / d ** o_(e, 1) ==> c * d ** (ln(a) / ln(d) * b +  --(e)) [[d: 'is_constant_and_evaluates_to_true', a == d: 'is_constant_and_evaluates_to_false', ln(a) / ln(d): 'is_constant_integer', d / a == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__div_203(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0;
   TermPtr formula_0_1; // This is an optional term.
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = formula_0;
      formula_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_0_0;
   TermPtr formula_0_0_1; // This is an optional term.
   if (formula_0_0->getOptorOnCompoundLevel() != "**") {
      formula_0_0_0 = formula_0_0;
      formula_0_0_1 = _val_plain(1.000000);
   } else {
      formula_0_0_0 = formula_0_0->getTermsJumpIntoCompounds()[0];
      formula_0_0_1 = formula_0_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_0_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_0_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_0_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_1, _pow(formula_1_0, _plus(_mult(_div(_ln(formula_0_0_0), _ln(formula_1_0->copy())), formula_0_0_1), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a / b ** o_(c, 1)) / b ** o_(d, 1) ==> a * b ** ( --(c) +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__div_204(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "/") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(_neg(formula_0_1_1), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a / b ** o_(c, 1)) / d ** o_(e, 1) ==> a * b ** ( --(c) +  --(ln(d) / ln(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__div_205(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "/") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(_neg(formula_0_1_1), _neg(_mult(_div(_ln(formula_1_0), _ln(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a / b ** o_(c, 1)) / d ** o_(e, 1) ==> a * d ** ( --(ln(b) / ln(d) * c) +  --(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(b) / ln(d): 'is_constant_integer', b / d == b: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__div_206(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "/") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_1_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_0_1_0, formula_1_0), formula_0_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_1_0, _plus(_neg(_mult(_div(_ln(formula_0_1_0), _ln(formula_1_0->copy())), formula_0_1_1)), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b ** o_(c, 1)) / b ** o_(d, 1) ==> a * b ** (c +  --(d)) {{'has_no_sideeffects'}} $10
inline bool apply__div_207(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = _val_plain(1.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(formula_0_1_1, _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b ** o_(c, 1)) / d ** o_(e, 1) ==> a * b ** (c +  --(ln(d) / ln(b) * e)) [[b: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(d) / ln(b): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__div_208(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = _val_plain(1.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_1_0), _ln_plain(formula_0_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_0_1_0, _plus(formula_0_1_1, _neg(_mult(_div(_ln(formula_1_0), _ln(formula_0_1_0->copy())), formula_1_1))))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (o_(a, 1) * b ** o_(c, 1)) / d ** o_(e, 1) ==> a * d ** (ln(b) / ln(d) * c +  --(e)) [[d: 'is_constant_and_evaluates_to_true', b == d: 'is_constant_and_evaluates_to_false', ln(b) / ln(d): 'is_constant_integer', d / b == d: 'is_constant_and_evaluates_to_false']] {{'has_no_sideeffects'}} $10
inline bool apply__div_209(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      formula_0_0 = _val_plain(1.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_0_1_0;
   TermPtr formula_0_1_1; // This is an optional term.
   if (formula_0_1->getOptorOnCompoundLevel() != "**") {
      formula_0_1_0 = formula_0_1;
      formula_0_1_1 = _val_plain(1.000000);
   } else {
      formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
      formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   }
   TermPtr formula_1_0;
   TermPtr formula_1_1; // This is an optional term.
   if (formula_1->getOptorOnCompoundLevel() != "**") {
      formula_1_0 = formula_1;
      formula_1_1 = _val_plain(1.000000);
   } else {
      formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
      formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   }
   if (MetaRule::is_constant_and_evaluates_to_true(formula_1_0) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(formula_0_1_0, formula_1_0)) && MetaRule::is_constant_integer(_div_plain(_ln_plain(formula_0_1_0), _ln_plain(formula_1_0))) && MetaRule::is_constant_and_evaluates_to_false(_eq_plain(_div_plain(formula_1_0, formula_0_1_0), formula_1_0->copy())) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_mult(formula_0_0, _pow(formula_1_0, _plus(_mult(_div(_ln(formula_0_1_0), _ln(formula_1_0->copy())), formula_0_1_1), _neg(formula_1_1)))));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 0 / a ==> 0 [[a: 'has_no_sideeffects']] $10
inline bool apply__div_210(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a / 1 ==> id(a) $10
inline bool apply__div_211(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "/") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_id(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ; b ; c ==> a ; c [[b: 'has_no_sideeffects']] $10
inline bool apply__semicolon_212(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ";") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != ";") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula_0_1) && MetaRule::no_check(formula)) {
      formula->replace(_seq(formula_0_0, formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a ; b ==> b [[a: 'is_constant']] $10
inline bool apply__semicolon_213(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ";") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(formula_1);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) ; b = c ; b = d ==> a ; b = d [[d ; b: 'second_operand_not_contained_in_first_operand', b: 'has_no_sideeffects', c: 'has_no_sideeffects', d: 'has_no_sideeffects']] $10
inline bool apply__semicolon_214(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ";") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != ";") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1->getOptorOnCompoundLevel() != "=") {
      return false;
   }
   TermPtr formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "=") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1_0->isStructurallyEqual(formula_1_0) && MetaRule::second_operand_not_contained_in_first_operand(_seq_plain(formula_1_1, formula_0_1_0)) && MetaRule::has_no_sideeffects(formula_0_1_0) && MetaRule::has_no_sideeffects(formula_0_1_1) && MetaRule::has_no_sideeffects(formula_1_1) && MetaRule::no_check(formula)) {
      formula->replace(_seq(formula_0_0, _set_alt(formula_0_1_0, formula_1_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// o_(a, 0) ; b = c ; d = e ==> a ; d = e ; b = c [[b ; d: 'of_first_two_operands_second_is_alphabetically_above', c ; d: 'second_operand_not_contained_in_first_operand', e ; b: 'second_operand_not_contained_in_first_operand', b: 'has_no_sideeffects', c: 'has_no_sideeffects', d: 'has_no_sideeffects', e: 'has_no_sideeffects']] $10
inline bool apply__semicolon_215(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ";") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_0_0; // This is an optional term.
   TermPtr formula_0_1;
   if (formula_0->getOptorOnCompoundLevel() != ";") {
      formula_0_0 = _val_plain(0.000000);
      formula_0_1 = formula_0;
   } else {
      formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
      formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   }
   if (formula_0_1->getOptorOnCompoundLevel() != "=") {
      return false;
   }
   TermPtr formula_0_1_0 = formula_0_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1_1 = formula_0_1->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "=") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::of_first_two_operands_second_is_alphabetically_above(_seq_plain(formula_0_1_0, formula_1_0)) && MetaRule::second_operand_not_contained_in_first_operand(_seq_plain(formula_0_1_1, formula_1_0)) && MetaRule::second_operand_not_contained_in_first_operand(_seq_plain(formula_1_1, formula_0_1_0)) && MetaRule::has_no_sideeffects(formula_0_1_0) && MetaRule::has_no_sideeffects(formula_0_1_1) && MetaRule::has_no_sideeffects(formula_1_0) && MetaRule::has_no_sideeffects(formula_1_1) && MetaRule::no_check(formula)) {
      formula->replace(_seq(_seq(formula_0_0, _set_alt(formula_1_0, formula_1_1)), _set_alt(formula_0_1_0, formula_0_1_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) <  --(b) ==> a > b $10
inline bool apply__smaller_216(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "<") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_gr(formula_0_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a < a ==> 0 {{'has_no_sideeffects'}} $10
inline bool apply__smaller_217(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "<") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) <=  --(b) ==> a >= b $10
inline bool apply__smallerorequal_218(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "<=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_greq(formula_0_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a <= a ==> 1 {{'has_no_sideeffects'}} $10
inline bool apply__smallerorequal_219(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "<=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// (a = b) ==> (a = b) [[a: 'has_no_sideeffects', b: 'has_no_sideeffects', b: 'is_any_var_of_second_on_any_left_side_earlier_AND_INSERT']] $10
inline bool apply__equal_sign_220(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::has_no_sideeffects(formula_1) && MetaRule::is_any_var_of_second_on_any_left_side_earlier_AND_INSERT(formula_1) && MetaRule::no_check(formula)) {
      // formula->replace(_set_alt(formula_0, formula_1)); // Commented out due to modifying condition. Currently, rules with modifying conditions need to be of type x ==> x.
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) ==  --(b) ==> a == b $10
inline bool apply__equal_221(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "==") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_eq(formula_0_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a == a ==> 1 {{'has_no_sideeffects'}} $10
inline bool apply__equal_222(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "==") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a == b ==> !(a) [[b: 'is_constant_and_evaluates_to_false', a: 'contains_no_meta']] $10
inline bool apply__equal_223(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "==") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_1) && MetaRule::contains_no_meta(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_not(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a == b ==> !(b) [[a: 'is_constant_and_evaluates_to_false', b: 'contains_no_meta']] $10
inline bool apply__equal_224(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "==") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_0) && MetaRule::contains_no_meta(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_not(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) >  --(b) ==> a < b $10
inline bool apply__greater_225(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ">") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_sm(formula_0_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a > a ==> 0 {{'has_no_sideeffects'}} $10
inline bool apply__greater_226(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ">") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
//  --(a) >=  --(b) ==> a <= b $10
inline bool apply__greaterorequal_227(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ">=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_smeq(formula_0_0, formula_1_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a >= a ==> 1 {{'has_no_sideeffects'}} $10
inline bool apply__greaterorequal_228(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != ">=") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ~(a, ~(b, c)) ==> ~(~(a, b), c) [[~(b, c): 'is_associative_operation']] $10
inline bool apply__anyway_operation_229(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getTermsJumpIntoCompounds().size() != 2) return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula->getOptorOnCompoundLevel() != formula_1->getOptorOnCompoundLevel()) {
      return false;
   }
   if (formula_1->getTermsJumpIntoCompounds().size() != 2) {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_associative_operation(p->termFactory(formula->getOptorJumpIntoCompound(), { formula_1_0, formula_1_1 })->toTermIfApplicable()) && MetaRule::no_check(formula)) {
      formula->replace(p->termFactory(formula->getOptorJumpIntoCompound(), { p->termFactory(formula->getOptorJumpIntoCompound(), { formula_0, formula_1_0 })->setChildrensFathers(false, false)->toTermIfApplicable(), formula_1_1 })->setChildrensFathers(false, false)->toTermIfApplicable());
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// abs( --(a)) ==> abs(a) $10
inline bool apply_abs230(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "abs") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_abs(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// abs(abs(a)) ==> abs(a) $10
inline bool apply_abs231(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "abs") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "abs") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_abs(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// boolify(!(a)) ==> !(a) $10
inline bool apply_boolify232(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "boolify") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "!") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_not(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// boolify(a) ==> a [[a: 'has_boolean_result']] $10
inline bool apply_boolify233(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "boolify") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (MetaRule::has_boolean_result(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(formula_0);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// free(a) ==> 0 [[a: 'is_constant_0']] $10
inline bool apply_free234(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "free") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (MetaRule::is_constant_0(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// id(a) ==> a $10
inline bool apply_id235(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "id") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(formula_0);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, b) ==> 0 [[a: 'has_no_sideeffects', b: 'is_constant_and_evaluates_to_false']] $10
inline bool apply_if236(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::is_constant_and_evaluates_to_false(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, b) ==> 0 [[a: 'is_constant_and_evaluates_to_false']] $10
inline bool apply_if237(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, b) ==> b [[a: 'is_constant_and_evaluates_to_true']] $10
inline bool apply_if238(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(formula_1);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, b) ==> if(a, b) [[a: 'has_no_sideeffects', a: 'is_any_var_of_second_on_any_left_side_earlier_AND_INSERT']] $10
inline bool apply_if239(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::is_any_var_of_second_on_any_left_side_earlier_AND_INSERT(formula_0) && MetaRule::no_check(formula)) {
      // formula->replace(_if(formula_0, formula_1)); // Commented out due to modifying condition. Currently, rules with modifying conditions need to be of type x ==> x.
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, if(!(a), b)) ==> 0 [[a: 'has_no_sideeffects']] $10
inline bool apply_if240(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_1_0->getOptorOnCompoundLevel() != "!") {
      return false;
   }
   TermPtr formula_1_0_0 = formula_1_0->getTermsJumpIntoCompounds()[0];
   if (formula_0->isStructurallyEqual(formula_1_0_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, if(a, b)) ==> if(a, b) [[a: 'has_no_sideeffects']] $10
inline bool apply_if241(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_if(formula_0, formula_1_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, if(b, c)) ==> 0 [[a ; b: 'first_two_operands_are_negations_of_each_other', a: 'has_no_sideeffects']] $10
inline bool apply_if242(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_1_0)) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, if(b, c)) ==> if(a && b, c) $10
inline bool apply_if243(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_if(_and(formula_0, formula_1_0), formula_1_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, ifelse(a, b, c)) ==> if(a, b) [[a: 'has_no_sideeffects']] $10
inline bool apply_if244(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "ifelse") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   TermPtr formula_1_2 = formula_1->getTermsJumpIntoCompounds()[2];
   if (formula_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_if(formula_0, formula_1_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(a, ifelse(b, c, d)) ==> if(a, d) [[a ; b: 'first_two_operands_are_negations_of_each_other', a: 'has_no_sideeffects']] $10
inline bool apply_if245(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "ifelse") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   TermPtr formula_1_2 = formula_1->getTermsJumpIntoCompounds()[2];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_1_0)) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_if(formula_0, formula_1_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// if(boolify(a), b) ==> if(a, b) [[a: 'has_no_sideeffects']] $10
inline bool apply_if246(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "if") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "boolify") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::has_no_sideeffects(formula_0_0) && MetaRule::no_check(formula)) {
      formula->replace(_if(formula_0_0, formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, b) ==> b [[a: 'has_no_sideeffects']] $10
inline bool apply_ifelse247(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_1->isStructurallyEqual(formula_2) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(formula_1);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, c) ==> 0 [[a: 'has_no_sideeffects', b: 'is_constant_and_evaluates_to_false', c: 'is_constant_and_evaluates_to_false']] $10
inline bool apply_ifelse248(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::is_constant_and_evaluates_to_false(formula_1) && MetaRule::is_constant_and_evaluates_to_false(formula_2) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, c) ==> b [[a: 'is_constant_and_evaluates_to_true']] $10
inline bool apply_ifelse249(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (MetaRule::is_constant_and_evaluates_to_true(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(formula_1);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, c) ==> c [[a: 'is_constant_and_evaluates_to_false']] $10
inline bool apply_ifelse250(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(formula_2);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, c) ==> ifelse(a, b, c) [[a: 'has_no_sideeffects', a: 'is_any_var_of_second_on_any_left_side_earlier_AND_INSERT']] $10
inline bool apply_ifelse251(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::is_any_var_of_second_on_any_left_side_earlier_AND_INSERT(formula_0) && MetaRule::no_check(formula)) {
      // formula->replace(_ifelse(formula_0, formula_1, formula_2)); // Commented out due to modifying condition. Currently, rules with modifying conditions need to be of type x ==> x.
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, if(a, c)) ==> if(a, b) [[a: 'has_no_sideeffects']] $10
inline bool apply_ifelse252(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_2->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_2_0 = formula_2->getTermsJumpIntoCompounds()[0];
   TermPtr formula_2_1 = formula_2->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_2_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_if(formula_0, formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, if(c, d)) ==> ifelse(a, b, d) [[a ; c: 'first_two_operands_are_negations_of_each_other', a: 'has_no_sideeffects']] $10
inline bool apply_ifelse253(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_2->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_2_0 = formula_2->getTermsJumpIntoCompounds()[0];
   TermPtr formula_2_1 = formula_2->getTermsJumpIntoCompounds()[1];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_2_0)) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0, formula_1, formula_2_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, ifelse(a, c, d)) ==> ifelse(a, b, d) [[a: 'has_no_sideeffects']] $10
inline bool apply_ifelse254(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_2->getOptorOnCompoundLevel() != "ifelse") {
      return false;
   }
   TermPtr formula_2_0 = formula_2->getTermsJumpIntoCompounds()[0];
   TermPtr formula_2_1 = formula_2->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2_2 = formula_2->getTermsJumpIntoCompounds()[2];
   if (formula_0->isStructurallyEqual(formula_2_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0, formula_1, formula_2_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, b, ifelse(c, d, e)) ==> ifelse(a, b, d) [[a ; c: 'first_two_operands_are_negations_of_each_other', a: 'has_no_sideeffects']] $10
inline bool apply_ifelse255(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_2->getOptorOnCompoundLevel() != "ifelse") {
      return false;
   }
   TermPtr formula_2_0 = formula_2->getTermsJumpIntoCompounds()[0];
   TermPtr formula_2_1 = formula_2->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2_2 = formula_2->getTermsJumpIntoCompounds()[2];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_2_0)) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0, formula_1, formula_2_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, if(a, b), c) ==> ifelse(a, b, c) [[a: 'has_no_sideeffects']] $10
inline bool apply_ifelse256(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_1->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0, formula_1_1, formula_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, if(b, c), d) ==> if(!(a), d) [[a ; b: 'first_two_operands_are_negations_of_each_other', a: 'has_no_sideeffects']] $10
inline bool apply_ifelse257(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_1->getOptorOnCompoundLevel() != "if") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_1_0)) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_if(_not(formula_0), formula_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, ifelse(a, b, c), d) ==> ifelse(a, b, d) [[a: 'has_no_sideeffects']] $10
inline bool apply_ifelse258(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_1->getOptorOnCompoundLevel() != "ifelse") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   TermPtr formula_1_2 = formula_1->getTermsJumpIntoCompounds()[2];
   if (formula_0->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0, formula_1_1, formula_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(a, ifelse(b, c, d), e) ==> ifelse(a, d, e) [[a ; b: 'first_two_operands_are_negations_of_each_other', a: 'has_no_sideeffects']] $10
inline bool apply_ifelse259(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_1->getOptorOnCompoundLevel() != "ifelse") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   TermPtr formula_1_2 = formula_1->getTermsJumpIntoCompounds()[2];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_1_0)) && MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0, formula_1_2, formula_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// ifelse(boolify(a), b, c) ==> ifelse(a, b, c) [[a: 'has_no_sideeffects']] $10
inline bool apply_ifelse260(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "ifelse") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (formula_0->getOptorOnCompoundLevel() != "boolify") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::has_no_sideeffects(formula_0_0) && MetaRule::no_check(formula)) {
      formula->replace(_ifelse(formula_0_0, formula_1, formula_2));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// malloc(a) ==> 0 [[a: 'is_constant_0']] $10
inline bool apply_malloc261(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "malloc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (MetaRule::is_constant_0(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// max( --(a),  --(b)) ==>  --(min(a, b)) {{'has_no_sideeffects'}} $10
inline bool apply_max262(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "max") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_neg(_min(formula_0_0, formula_1_0)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// max(a, a) ==> a {{'has_no_sideeffects'}} $10
inline bool apply_max263(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "max") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(formula_0);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// min( --(a),  --(b)) ==>  --(max(a, b)) {{'has_no_sideeffects'}} $10
inline bool apply_min264(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "min") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (formula_1->getOptorOnCompoundLevel() != "--") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   if (MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_neg(_max(formula_0_0, formula_1_0)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// min(a, a) ==> a {{'has_no_sideeffects'}} $10
inline bool apply_min265(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "min") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(formula_0);
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// print_plain(a, b) ==> 0 [[a: 'has_no_sideeffects', b: 'is_constant_0']] $10
inline bool apply_print_plain266(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "print_plain") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::is_constant_0(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// sqrt(a * a) ==> abs(a) [[a: 'has_no_sideeffects']] $10
inline bool apply_sqrt267(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "sqrt") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "*") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_0_1) && MetaRule::has_no_sideeffects(formula_0_0) && MetaRule::no_check(formula)) {
      formula->replace(_abs(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc(!(a)) ==> !(a) $10
inline bool apply_trunc268(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "!") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_not(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc((a != b)) ==> a != b $10
inline bool apply_trunc269(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "!=") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_neq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc((a < b)) ==> a < b $10
inline bool apply_trunc270(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "<") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_sm(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc((a <= b)) ==> a <= b $10
inline bool apply_trunc271(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "<=") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_smeq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc((a == b)) ==> a == b $10
inline bool apply_trunc272(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "==") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_eq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc((a > b)) ==> a > b $10
inline bool apply_trunc273(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != ">") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_gr(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc((a >= b)) ==> a >= b $10
inline bool apply_trunc274(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != ">=") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_greq(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc(a && b) ==> a && b $10
inline bool apply_trunc275(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_and(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc(a || b) ==> a || b $10
inline bool apply_trunc276(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "||") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (MetaRule::no_check(formula)) {
      formula->replace(_or(formula_0_0, formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc(boolify(a)) ==> boolify(a) $10
inline bool apply_trunc277(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "boolify") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// trunc(trunc(a)) ==> trunc(a) $10
inline bool apply_trunc278(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "trunc") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   if (formula_0->getOptorOnCompoundLevel() != "trunc") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_trunc(formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// whilelim(a, b, c) ==> 0 [[a: 'is_constant_and_evaluates_to_false']] $10
inline bool apply_whilelim279(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "whilelim") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (MetaRule::is_constant_and_evaluates_to_false(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// whilelim(a, b, c) ==> 0 [[c <= 0: 'is_constant_and_evaluates_to_true']] {{'has_no_sideeffects'}} $10
inline bool apply_whilelim280(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "whilelim") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   TermPtr formula_2 = formula->getTermsJumpIntoCompounds()[2];
   if (MetaRule::is_constant_and_evaluates_to_true(_smeq_plain(formula_2, _val_plain(0.000000))) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(0.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// !(a) || b ==> a => b $10
inline bool apply__or_281(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "!") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   if (MetaRule::no_check(formula)) {
      formula->replace(_ltl_implication(formula_0_0, formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 0 || a ==> boolify(a) $10
inline bool apply__or_282(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// 1 || a ==> 1 [[a: 'has_no_sideeffects']] $10
inline bool apply__or_283(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_0->isTermVal() || formula_0->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b || a ==> (b || 1) && a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__or_284(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_and(_or(formula_0_1, _val(1.000000)), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b || b && c ==> (a || c) && b {{'has_no_sideeffects'}} $10
inline bool apply__or_285(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_and(_or(formula_0_0, formula_1_1), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b || b ==> (a || 1) && b [[b: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__or_286(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1) && MetaRule::is_not_constant(formula_0_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_and(_or(formula_0_0, _val(1.000000)), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b || c && a ==> (b || c) && a {{'has_no_sideeffects'}} $10
inline bool apply__or_287(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_0->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_and(_or(formula_0_1, formula_1_0), formula_0_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a && b || c && b ==> (a || c) && b {{'has_no_sideeffects'}} $10
inline bool apply__or_288(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_0->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_0_0 = formula_0->getTermsJumpIntoCompounds()[0];
   TermPtr formula_0_1 = formula_0->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0_1->isStructurallyEqual(formula_1_1) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_and(_or(formula_0_0, formula_1_0), formula_0_1));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || 0 ==> boolify(a) $10
inline bool apply__or_289(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 0.000000) {
      return false;
   }
   if (MetaRule::no_check(formula)) {
      formula->replace(_boolify(formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || 1 ==> 1 [[a: 'has_no_sideeffects']] $10
inline bool apply__or_290(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (!formula_1->isTermVal() || formula_1->toValueIfApplicable()->getValue() != 1.000000) {
      return false;
   }
   if (MetaRule::has_no_sideeffects(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || b && a ==> (1 || b) && a [[a: 'is_not_constant']] {{'has_no_sideeffects'}} $10
inline bool apply__or_291(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (formula_1->getOptorOnCompoundLevel() != "&&") {
      return false;
   }
   TermPtr formula_1_0 = formula_1->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1_1 = formula_1->getTermsJumpIntoCompounds()[1];
   if (formula_0->isStructurallyEqual(formula_1_1) && MetaRule::is_not_constant(formula_0) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_and(_or(_val(1.000000), formula_1_0), formula_0));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || b ==> 1 [[a ; b: 'first_two_operands_are_negations_of_each_other']] {{'has_no_sideeffects'}} $10
inline bool apply__or_292(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::first_two_operands_are_negations_of_each_other(_seq_plain(formula_0, formula_1)) && MetaRule::has_no_sideeffects(formula)) {
      formula->replace(_val(1.000000));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || b ==> a || boolify(b) [[b: 'is_non_boolean_constant']] $10
inline bool apply__or_293(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_non_boolean_constant(formula_1) && MetaRule::no_check(formula)) {
      formula->replace(_or(formula_0, _boolify(formula_1)));
      return true;
   }
   return false;
}

// Autogenerated function for meta rule:
// a || b ==> boolify(a) || b [[a: 'is_non_boolean_constant']] $10
inline bool apply__or_294(const TermPtr formula, const std::shared_ptr<FormulaParser> p)
{
   // if (formula->getOptorOnCompoundLevel() != "||") return false;
   TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
   TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
   if (MetaRule::is_non_boolean_constant(formula_0) && MetaRule::no_check(formula)) {
      formula->replace(_or(_boolify(formula_0), formula_1));
      return true;
   }
   return false;
}

// Auto-generated simplification function. When freshly generated, it should
// do the same as MathStruct::simplify, only faster.
inline TermPtr simplifyFast(const TermPtr formula_raw, const std::shared_ptr<FormulaParser> p_raw = nullptr)
{
   //static std::string last = "";
   //std::cout << " ---\n";
   auto p = p_raw ? p_raw : SingletonFormulaParser::getInstance();

   for (const auto& op : p->getAllOps()) {
      if (!OVERLOADED_OPERATORS.count(op.first) && p->getNumParams(op.first).size() > 1 && USED_OPERATORS.count(op.first)) {
         p->addWarning("(W0001) Operator '" + op.first + "' is overloaded, but has not been so at creation time of hard-coded simplification; this could lead to errors. You'll need to recreate the simplification function using the new parser.");
      }
   }

   bool changed;
   auto formula = _id(formula_raw);

   //std::cout << "Entering stage #" << 0 << " of simplification." << std::endl;
   changed = true;
   while (changed) {
      changed = false;
      //formula->checkIfAllChildrenHaveConsistentFatherQuiet();

      formula->getOperands()[0]->applyToMeAndMyChildrenIterative([&changed, p](const MathStructPtr m) {
         //std::string ser = m->getPtrToRoot()->getOperands()[0]->serialize(m);
         //if (last != ser) {
         //   std::cout << "     FAST:   " << ser << std::endl;
         //   last = ser;
         //}
         if (MetaRule::is_leaf(m)) return; // Caution, remove if simplifications on leaf level desired.
         bool changed_this_time = false;

         for (int i = 0; i < 1 && m->getFather(); i++) {
            if (!m->isCompoundOperator() && m->isOverallConstant()) {
               m->replace(_val_plain(m->constEval()));
               changed_this_time = true; // Since it's not a leaf, there was definitely a change.
            }
            else if (m->getOptor() == "!=") {
               changed_this_time = apply__notequal_0(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "!==") {
               changed_this_time = apply__not__equal_1(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "&&") {
               changed_this_time = apply__and_2(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_3(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "*") {
               changed_this_time = apply__mult_4(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_5(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "+") {
               changed_this_time = apply__plus_6(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_7(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_8(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_9(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_10(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_11(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "-") {
               if (m->getTermsJumpIntoCompounds().size() == 2) {
                  changed_this_time = apply__minus_12(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_13(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_14(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_15(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_16(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_17(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_18(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
               }
            }
            else if (m->getOptorOnCompoundLevel() == "<=>") {
               changed_this_time = apply__smallerorequal__greater_19(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__smallerorequal__greater_20(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "==") {
               changed_this_time = apply__equal_21(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "===") {
               changed_this_time = apply__equal__equal_sign_22(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "max") {
               changed_this_time = apply_max26(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "min") {
               changed_this_time = apply_min27(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "xnor") {
               changed_this_time = apply_xnor28(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_xnor29(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "xor") {
               changed_this_time = apply_xor30(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_xor31(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "||") {
               changed_this_time = apply__or_32(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_33(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            if (!changed_this_time) {
               if (m->getTermsJumpIntoCompounds().size() == 2) {
                  changed_this_time = apply__anyway_operation_23(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__anyway_operation_24(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__anyway_operation_25(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
               }
            }
         }

         changed = changed || changed_this_time;
      }, TraverseCompoundsType::go_into_compound_structures, FormulaTraversalType::PostOrder);
   }

   //std::cout << "Entering stage #" << 10 << " of simplification." << std::endl;
   changed = true;
   while (changed) {
      changed = false;
      //formula->checkIfAllChildrenHaveConsistentFatherQuiet();

      formula->getOperands()[0]->applyToMeAndMyChildrenIterative([&changed, p](const MathStructPtr m) {
         //std::string ser = m->getPtrToRoot()->getOperands()[0]->serialize(m);
         //if (last != ser) {
         //   std::cout << "     FAST:   " << ser << std::endl;
         //   last = ser;
         //}
         if (MetaRule::is_leaf(m)) return; // Caution, remove if simplifications on leaf level desired.
         bool changed_this_time = false;

         for (int i = 0; i < 1 && m->getFather(); i++) {
            if (!m->isCompoundOperator() && m->isOverallConstant()) {
               m->replace(_val_plain(m->constEval()));
               changed_this_time = true; // Since it's not a leaf, there was definitely a change.
            }
            else if (m->getOptorOnCompoundLevel() == "!") {
               changed_this_time = apply__not_34(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_35(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_36(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_37(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_38(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_39(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_40(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_41(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_42(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_43(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_44(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_45(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_46(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_47(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_48(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_49(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__not_50(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "!=") {
               changed_this_time = apply__notequal_51(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__notequal_52(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__notequal_53(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__notequal_54(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "%") {
               changed_this_time = apply__modulo_55(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "&&") {
               changed_this_time = apply__and_56(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_57(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_58(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_59(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_60(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_61(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_62(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_63(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_64(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_65(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_66(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_67(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_68(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_69(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__and_70(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "*") {
               changed_this_time = apply__mult_71(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_72(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_73(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_74(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_75(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_76(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_77(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_78(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_79(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_80(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_81(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_82(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_83(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_84(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_85(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_86(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_87(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_88(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_89(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__mult_90(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "**") {
               changed_this_time = apply__pow_91(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__pow_92(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "+") {
               changed_this_time = apply__plus_93(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_94(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_95(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_96(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_97(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_98(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_99(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_100(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_101(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_102(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_103(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_104(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_105(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_106(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_107(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_108(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_109(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_110(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_111(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_112(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_113(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_114(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_115(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_116(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_117(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_118(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_119(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_120(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_121(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_122(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_123(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_124(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_125(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_126(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_127(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_128(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_129(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_130(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_131(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_132(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_133(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_134(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_135(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_136(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_137(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_138(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_139(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_140(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_141(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_142(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_143(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_144(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_145(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_146(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_147(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_148(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_149(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__plus_150(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "-") {
               if (m->getTermsJumpIntoCompounds().size() == 2) {
                  changed_this_time = apply__minus_151(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_152(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_153(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_154(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_155(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_156(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_157(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_158(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_159(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_160(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_161(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_162(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_163(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_164(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_165(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_166(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_167(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_168(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_169(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_170(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_171(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_172(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_173(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_174(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_175(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_176(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_177(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_178(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_179(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_180(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_181(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_182(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_183(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_184(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_185(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_186(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_187(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_188(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_189(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_190(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_191(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_192(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_193(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_194(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_195(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_196(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_197(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
                  changed_this_time = apply__minus_198(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
               }
            }
            else if (m->getOptor() == "--") {
               changed_this_time = apply__minus__minus_199(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__minus__minus_200(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "/") {
               changed_this_time = apply__div_201(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_202(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_203(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_204(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_205(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_206(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_207(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_208(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_209(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_210(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__div_211(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == ";") {
               changed_this_time = apply__semicolon_212(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__semicolon_213(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__semicolon_214(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__semicolon_215(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "<") {
               changed_this_time = apply__smaller_216(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__smaller_217(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "<=") {
               changed_this_time = apply__smallerorequal_218(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__smallerorequal_219(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "=") {
               changed_this_time = apply__equal_sign_220(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "==") {
               changed_this_time = apply__equal_221(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__equal_222(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__equal_223(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__equal_224(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == ">") {
               changed_this_time = apply__greater_225(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__greater_226(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == ">=") {
               changed_this_time = apply__greaterorequal_227(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__greaterorequal_228(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "abs") {
               changed_this_time = apply_abs230(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_abs231(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "boolify") {
               changed_this_time = apply_boolify232(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_boolify233(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "free") {
               changed_this_time = apply_free234(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "id") {
               changed_this_time = apply_id235(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "if") {
               changed_this_time = apply_if236(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if237(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if238(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if239(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if240(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if241(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if242(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if243(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if244(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if245(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_if246(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptorOnCompoundLevel() == "ifelse") {
               changed_this_time = apply_ifelse247(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse248(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse249(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse250(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse251(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse252(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse253(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse254(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse255(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse256(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse257(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse258(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse259(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_ifelse260(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "malloc") {
               changed_this_time = apply_malloc261(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "max") {
               changed_this_time = apply_max262(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_max263(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "min") {
               changed_this_time = apply_min264(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_min265(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "print_plain") {
               changed_this_time = apply_print_plain266(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "sqrt") {
               changed_this_time = apply_sqrt267(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "trunc") {
               changed_this_time = apply_trunc268(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc269(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc270(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc271(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc272(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc273(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc274(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc275(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc276(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc277(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_trunc278(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "whilelim") {
               changed_this_time = apply_whilelim279(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply_whilelim280(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            else if (m->getOptor() == "||") {
               changed_this_time = apply__or_281(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_282(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_283(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_284(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_285(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_286(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_287(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_288(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_289(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_290(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_291(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_292(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_293(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
               changed_this_time = apply__or_294(m->toTermIfApplicable(), p);
               if (changed_this_time) break;
            }
            if (!changed_this_time) {
               if (m->getTermsJumpIntoCompounds().size() == 2) {
                  changed_this_time = apply__anyway_operation_229(m->toTermIfApplicable(), p);
                  if (changed_this_time) break;
               }
            }
         }

         changed = changed || changed_this_time;
      }, TraverseCompoundsType::go_into_compound_structures, FormulaTraversalType::PostOrder);
   }

   return formula->getOperands()[0];
}

// Auto-generated simplification function. When freshly generated, it should
// do the same as MathStruct::simplify and simplification::simplify, only faster.
inline TermPtr simplifyVeryFast(const TermPtr formula_raw, const std::shared_ptr<FormulaParser> p_raw = nullptr)
{
   //static std::string last = "";
   //std::cout << " ---\n";
   auto p = p_raw ? p_raw : SingletonFormulaParser::getInstance();

   for (const auto& op : p->getAllOps()) {
      if (!OVERLOADED_OPERATORS.count(op.first) && p->getNumParams(op.first).size() > 1 && USED_OPERATORS.count(op.first)) {
         p->addWarning("(W0001) Operator '" + op.first + "' is overloaded, but has not been so at creation time of hard-coded simplification; this could lead to errors. You'll need to recreate the simplification function using the new parser.");
      }
   }

   bool changed;
   auto formula = _id(formula_raw);

   //std::cout << "Entering stage #" << 0 << " of simplification." << std::endl;
   changed = true;
   while (changed) {
      changed = false;
      //formula->checkIfAllChildrenHaveConsistentFatherQuiet();

      formula->getOperands()[0]->applyToMeAndMyChildrenIterative([&changed, p](const MathStructPtr m) {
         //std::string ser = m->getPtrToRoot()->getOperands()[0]->serialize(m);
         //if (last != ser) {
         //   std::cout << "VERY FAST:   " << ser << std::endl;
         //   last = ser;
         //}
         if (MetaRule::is_leaf(m)) return; // Caution, remove if simplifications on leaf level desired.
         bool changed_this_time = false;

         for (int i = 0; i < 1 && m->getFather(); i++) {
            if (!m->isCompoundOperator() && m->isOverallConstant()) {
               m->replace(_val_plain(m->constEval()));
               changed_this_time = true; // Since it's not a leaf, there was definitely a change.
            }
            else {
               // This part is commented out for now due to something not working
               // in the 'mergeWithOtherSimplificationFunction' function. Apart from
               // some most probably minor issue, the most problematic logical problem
               // is the exponential blowup when two conditions from separate rules are
               // independent of each other, such as 'formula_0->getOptor() == "*"'
               // vs. 'formula_1->getOptor() == "+"', which needs to be solved somehow.
               // One possibility is to append such rules after each other, but this requires
               // a fundamentally different approach.
               // 
               // Note, however, that the expected speedup is very limited, measured so far
               // between about 1.01 and 1.5.
            }
         }

         changed = changed || changed_this_time;
      }, TraverseCompoundsType::go_into_compound_structures, FormulaTraversalType::PostOrder);
   }

   return formula->getOperands()[0];
}


} // simplification
} // vfm
