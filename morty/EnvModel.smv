-- ============================================================================================================
-- C O P Y R I G H T
-- ------------------------------------------------------------------------------------------------------------
-- copyright (C) 2022 Robert Bosch GmbH. All rights reserved.
-- ============================================================================================================

-- This environment model has been auto-generated by vfm at: Sun Jun 22 07:07:01 2025
-- The template files have been retrieved from C:\eig\git\very-fast-math\src\templates

-- Road Topology (terminology and basic properties):
-- * Section: straight road part, e.g., a highway chunk with length |SD|, where:
--    * S is a "source" point in 2D space denoting the entry to the section, and
--    * D is a "drain" point in 2D space denoting the exit of the section.
--    * A is the angle of the section relative to the horizontal axis.
--    * n is the maximum number of lanes the section may have on each of its "segments" (see below).
--   Originally, the EnvModel contained only 1 section with S=(0, 0), and A = 0.
-- * Segment: longitudinal part of a section (given by its begin and lasting to the begin of the next segment or the end of the section), with individual properties assigned to it, particularly number of lanes <= n. A section fully consists of segments, the first starts at the source, the last ends in the drain, all segment lengths sum up to |SD|.
--   Note that in the nuXmv implementation, a section is given by S and A, while D is derived from these two and the sum of the segments' lengths.
-- * Connection: a tuple (j, k) of sections (given by their IDs) with:
--    * k is an "outgoing connection" of j, and
--    * j is an "incoming connection" of k.
--   When a car drives beyond the drain of a section, it is associated (non-det-ically.) to one of the outgoing connections of the section, and placed on the drivable space (conjunction; see below) between those.
-- * Road Graph: a collection of sections with a set of arbitrary many outgoing connections associated to each section.
-- * Conjunction: The drivable space from the drain of one section to the source of a connected section. [TODO: might have been referred to as "junction" earlier.]
-- * Seclet: collective term for a section OR a conjunction. At any time, each car is associated to a seclet, resp. referred to as the car:
--    * being "on section i", or
--    * traversing "from section j to section k".
-- * Junction/crossing: the area built up by several overlapping conjunctions that create a common drivable space.













-- TIMESCALING((((1.000000))))GNILACSEMIT
-- DISTANCESCALING((((1.000000))))GNILACSECNATSID
-- SCALING DESCRIPTIONS
--min_time_between_lcs,time
--a_min,acceleration
--a_max,acceleration
--min_dist_long,distance
--veh_length,distance
--max_vel,velocity
--ego.max_vel,velocity
--section_0_lane_0_availability_from_segment_1,distance
--section_0_lane_0_availability_from_segment_0,distance
--ego.lane_0_availability,distance
--section_0_lane_1_availability_from_segment_1,distance
--section_0_lane_1_availability_from_segment_0,distance
--ego.lane_1_availability,distance
--section_0_lane_2_availability_from_segment_1,distance
--section_0_lane_2_availability_from_segment_0,distance
--ego.lane_2_availability,distance
--section_0_lane_3_availability_from_segment_1,distance
--section_0_lane_3_availability_from_segment_0,distance
--ego.lane_3_availability,distance
--section_0_segment_0_pos_begin,distance
--section_0_end,distance
--veh___609___.time_since_last_lc,time
--veh___609___.abs_pos,distance
--veh___609___.prev_abs_pos,distance
--veh___609___.prev_rel_pos,distance
--veh___609___.a,acceleration
--veh___609___.v,velocity
--veh___619___.time_since_last_lc,time
--veh___619___.abs_pos,distance
--veh___619___.prev_abs_pos,distance
--veh___619___.prev_rel_pos,distance
--veh___619___.a,acceleration
--veh___619___.v,velocity
--veh___629___.time_since_last_lc,time
--veh___629___.abs_pos,distance
--veh___629___.prev_abs_pos,distance
--veh___629___.prev_rel_pos,distance
--veh___629___.a,acceleration
--veh___629___.v,velocity
--veh___639___.time_since_last_lc,time
--veh___639___.abs_pos,distance
--veh___639___.prev_abs_pos,distance
--veh___639___.prev_rel_pos,distance
--veh___639___.a,acceleration
--veh___639___.v,velocity
--veh___649___.time_since_last_lc,time
--veh___649___.abs_pos,distance
--veh___649___.prev_abs_pos,distance
--veh___649___.prev_rel_pos,distance
--veh___649___.a,acceleration
--veh___649___.v,velocity
--ego.abs_pos,distance
--ego.v,velocity
-- EO SCALING DESCRIPTIONS

-- Translating TIMESCALING unit from milliseconds (old value: 1000.000000) to seconds (new value: 1.000000)
-- Translating DISTANCESCALING unit from millimeters (old value: 1000.000000) to meters (new value: 1.000000)



-- Note that the below exact formulation is used in regex for caching. 
-- Don't change...

-- Global options
-- Undeclared variable EM_LESS found during generation of EnvModel. Setting to default value false. 

-- Parametrization of road topology features
-- Found variable NUMLANES with value 4.000000 during generation of EnvModel (default would be 3).               -- Maximum number of lanes a road SEGMENT can have
-- Found variable SEGMENTS with value 1.000000 during generation of EnvModel (default would be 4).               -- Number of segments per straight road SECTION with flexible length and NUMLANES
-- Found variable SEGMENTSMINLENGTH with value 50.000000 during generation of EnvModel (default would be 30). 
-- Found variable SECTIONS with value 1.000000 during generation of EnvModel (default would be 3).               -- Number of straight road SECTIONS which form a road network
-- Found variable SECTIONSMAXLENGTH with value 10000.000000 during generation of EnvModel (default would be 150).
-- Found variable SECTIONSMINLENGTH with value 10000.000000 during generation of EnvModel (default would be 50).
-- Found variable ALLOW_ZEROLENGTH_SECTIONS with value 0.000000 during generation of EnvModel (default would be true).
-- Found variable ANGLEGRANULARITY with value 360.000000 during generation of EnvModel (default would be 45).      -- Only every n-th angle (DEG) can be used between two sections at connection points (zero degrees is straight ahead)
-- Found variable MAXOUTGOINGCONNECTIONS with value 1.000000 during generation of EnvModel (default would be 3). -- Maximum number of successors a straight road may have
-- Found variable MINDISTCONNECTIONS with value 0.000000 during generation of EnvModel (default would be 20).    -- The minimal "X" variable when going from the drain of one road to the source of a connected one
-- Found variable MAXDISTCONNECTIONS with value 0.000000 during generation of EnvModel (default would be 50).    -- The maximal "X" variable when going from the drain of one road to the source of a connected one
-- Undeclared variable MAXDISTENDPOINTS found during generation of EnvModel. Setting to default value 5.     -- Two end points must be at least this apart (approximated by maxvar method)

-- Parameters for ego and non-ego vehicles
-- Found variable EGOLESS with value 1.000000 during generation of EnvModel (default would be false).
-- Found variable NONEGOS with value 5.000000 during generation of EnvModel (default would be 5).
-- Undeclared variable LEFTLC found during generation of EnvModel. Setting to default value true. 
-- Undeclared variable RIGHTLC found during generation of EnvModel. Setting to default value false. 
-- Undeclared variable KEEPEGOFIXEDTOLANE found during generation of EnvModel. Setting to default value false. 
-- Undeclared variable VIPER found during generation of EnvModel. Setting to default value false. 
-- Undeclared variable LONGCONTROL found during generation of EnvModel. Setting to default value true. 
-- Found variable DEBUG with value 0.000000 during generation of EnvModel (default would be true).
-- Undeclared variable MAXSPEEDEGO found during generation of EnvModel. Setting to default value 34. 
-- Undeclared variable MAXSPEEDNONEGO found during generation of EnvModel. Setting to default value 70. 
-- Undeclared variable MINACCELEGO found during generation of EnvModel. Setting to default value -8. 
-- Undeclared variable MAXACCELEGO found during generation of EnvModel. Setting to default value 2. 
-- Undeclared variable MINACCELNONEGO found during generation of EnvModel. Setting to default value -8. 
-- Undeclared variable MAXACCELNONEGO found during generation of EnvModel. Setting to default value 6. 
-- Undeclared variable MAXEGOVISRANGE found during generation of EnvModel. Setting to default value 250. 
-- Undeclared variable CLOSEFRONTDIST found during generation of EnvModel. Setting to default value 10. 
-- Found variable CALCULATE_LEFT_GAP with value 0.000000 during generation of EnvModel (default would be true).
-- Found variable CALCULATE_CENTER_GAP with value 1.000000 during generation of EnvModel (default would be true).
-- Found variable CALCULATE_RIGHT_GAP with value 0.000000 during generation of EnvModel (default would be true).
-- Found variable CALCULATE_RIGHT_GAP_REAR with value 0.000000 during generation of EnvModel (default would be true). -- Flag to leave out the rear/right gap when not needed, even when right gap is calculated.
-- Undeclared variable LONGDISTMAX found during generation of EnvModel. Setting to default value 300.          -- This is the max distance to the front and back of ego.
-- Undeclared variable INITPOSRANGENONEGOS found during generation of EnvModel. Setting to default value 50.   -- Range to front where non-egos can be positioned initially. (TODO: Should be replaced by length of resp. section.)
-- Undeclared variable CLOSETOEGOPAR found during generation of EnvModel. Setting to default value 80. 
-- Found variable TIMESCALING with value 1000.000000 during generation of EnvModel (default would be 1000).        -- nondimensionalization constant for time, in milliseconds
-- Found variable DISTANCESCALING with value 1000.000000 during generation of EnvModel (default would be 1000).    -- nondimensionalization constant for distance, in millimeters
-- Found variable SIMPLE_LC with value 1.000000 during generation of EnvModel (default would be true).          -- true: Allow non-egos to switch a "half-lane" if time_since_last_lc has passed; false: Christian's version

-- Parameters for "skipping" of CEXs.
-- Found variable DOUBLEMERGEPROTECTION with value 0.000000 during generation of EnvModel (default would be true). -- Prohibits non-ego LCs when in danger of a double-merge
-- Found variable BRAKEINHIBITION with value 0.000000 during generation of EnvModel (default would be true).       -- Prohibits non-egos in the front gaps to brake so hard that ego could not react on it in one step.
-- Found variable HARDBRAKEPREVENTION with value -8.000000 during generation of EnvModel (default would be -8).     -- Cuts out traces with very hard decelerations. Set to MINACCELEGO to deactivate.
-- Undeclared variable STANDINGCARSUPTOID found during generation of EnvModel. Setting to default value -1. 
-- Found variable FARMERGINGCARS with value 0.000000 during generation of EnvModel (default would be false).
-- Found variable ABORTREVOKE with value 0.000000 during generation of EnvModel (default would be false).
-- Found variable KEEP_EGO_FROM_GREEN with value 1.000000 during generation of EnvModel (default would be true).   -- Makes sure, ego never leaves the lanes.

-- Special purpose parameters.
-- Found variable FEASIBILITY with value 0.000000 during generation of EnvModel (default would be true). -- Includes defines needed for the ACA4.1 Fesibility study.


-- EO Don't change.

------------------------------------------------------------------------------------------------------------------
-- MATH functions on vfm level which are directly converted to SMV code without further modularizing on their side
------------------------------------------------------------------------------------------------------------------

-- The vfmacro function 'syntacticSegmentAndLineIntersect' is an implementation of this C++ code:
-- bool onSegment(Vec2D p, Vec2D q, Vec2D r) {
--    return (q.x <= std::max(p.x, r.x) && q.x >= std::min(p.x, r.x) &&
--            q.y <= std::max(p.y, r.y) && q.y >= std::min(p.y, r.y));
-- }
-- bool doesLineIntersectSegment(Vec2D L1, Vec2D L2, Vec2D M1, Vec2D M2, Image&& img) {
--    float A1 = L2.y - L1.y;
--    float B1 = L1.x - L2.x;
--    float C1 = (L2.x * L1.y) - (L1.x * L2.y);
--    float A2 = M2.y - M1.y;
--    float B2 = M1.x - M2.x;
--    float C2 = (M2.x * M1.y) - (M1.x * M2.y);
-- 
--    float denominator = A1 * B2 - A2 * B1;
-- 
--    if (denominator == 0) throw std::runtime_error("The lines are parallel and do not intersect.");
-- 
--    float x = -(B1 * (-C2) - B2 * (-C1)) / denominator;
--    float y = -(A2 * (-C1) - A1 * (-C2)) / denominator;
-- 
--    // Check if the intersection Vec2D lies on the line segment
--    return onSegment(M1, {x, y}, M2);
-- }




















--------------------
-- EO MATH functions 
--------------------


MODULE EnvModel




 -- EM-full build

VAR
   cnt : integer;
   num_lanes : integer;

INIT cnt = 0;
TRANS next(cnt) = cnt + 1;

INVAR num_lanes = 4;


------------------------------------------
--
-- Begin: Constants and common definitions
--
------------------------------------------

DEFINE
    ---------------- Begin of non-ego lc parameterization -----------------


    min_time_between_lcs := 4;                      -- after finisihing one lc, how much time needs to pass before the next one may be started
---------------- End of non-ego lc parameterization -----------------


    a_min := -3;
    a_max := 3;
    min_dist_long := -1;                            -- the minimum distance kept by other vehicle to preceding ego, we use -1 meaning one meter behind
    veh_length := 5;                                -- we assume a vehicle length of 5m for distance calculation to the front
    max_vel := 70;

    ego.max_vel := 34; -- Leave this even in ego-less mode.

--------------------------------------------------------
-- End: Constants and common definitions
--------------------------------------------------------


--------------------------------------------------------
-- Sections
--  ==> Segments
--------------------------------------------------------

   DEFINE
      large_number := 10000;

   section_0_segment_1_pos_begin := section_0_segment_0_pos_begin + large_number; -- Helper variable to make below loop simpler.
   


   section_0_lane_0_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_0_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 0 & section_0_segment_0_max_lane >= 0 : section_0_lane_0_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_0_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_0_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   section_0_lane_1_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_1_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 1 & section_0_segment_0_max_lane >= 1 : section_0_lane_1_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_1_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_1_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   section_0_lane_2_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_2_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 2 & section_0_segment_0_max_lane >= 2 : section_0_lane_2_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_2_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_2_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   section_0_lane_3_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_3_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 3 & section_0_segment_0_max_lane >= 3 : section_0_lane_3_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_3_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_3_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   

   INIT 0 = section_0_segment_0_pos_begin;
INIT section_0_segment_0_pos_begin <= section_0_end;


INIT section_0_segment_0_max_lane >= section_0_segment_0_min_lane;
INIT section_0_segment_0_min_lane >= 0;
INIT section_0_segment_0_max_lane <= 3;


INIT section_0_segment_0_min_lane = 0 & section_0_segment_0_max_lane = 3; -- Make sure we always have a drivable lane at the start. TODO: Make flexible.
   FROZENVAR
         section_0_segment_0_pos_begin : integer;
            section_0_segment_0_min_lane : integer;
            section_0_segment_0_max_lane : integer;
         
   
         section_0_end : 
            10000 .. 10000; -- This is essentially the length of the section.

         section_0.source.x : integer;
         section_0.source.y : integer;
         section_0.angle_raw : 0 .. 0;

      DEFINE 
         section_0.angle := section_0.angle_raw * 360;

      -- Lookup table to speed-up non-linear calculations (sin times 100)
      sin_of_section_0_angle := case
         section_0.angle = 0 : 0;
         
      esac;

      -- Lookup table to speed-up non-linear calculations (cos times 100)
      cos_of_section_0_angle := case
         section_0.angle = 0 : 100;
         
      esac;

      section_0.drain.x := section_0.source.x + (section_0_end * cos_of_section_0_angle) / 100;
      section_0.drain.y := section_0.source.y + (section_0_end * sin_of_section_0_angle) / 100;
 
      -- INIT outgoing_connection_0_of_section_0 != outgoing_connection_1_of_section_0; -- If we want to have at least one outgoing connection for all roads.

         FROZENVAR outgoing_connection_0_of_section_0 : -1..0;
            INIT outgoing_connection_0_of_section_0 != 0; -- Don't connect to self.

            
            
          -- Several elements can be equal, so we have at least 1 and at most 1 outgoing connections.

         

      

      
      
   

   -- Section 0 always starts at (0/0) and goes horizontally to the right.
   INIT section_0.source.x = 0;
   INIT section_0.source.y = 0;
   -- INIT section_0.drain.x ==> Not specified, so the length of the section is figured out from the length of the segments.
   INIT section_0.angle = 0;

VAR    
   ego.on_section : 0 .. 0;

INIT ego.on_section = 0;

--------------------------------------------------------
-- EO Sections
--------------------------------------------------------

--------------------------------------------------------
--
-- Begin: Non-ego Spec (generate once per non-ego Vehicle)
--
--------------------------------------------------------


   VAR
      ego.a : 0..0;  -- Mock EGO interface...

	VAR

   veh___609___.time_since_last_lc : 0..min_time_between_lcs;


    veh___609___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___609___.prev_abs_pos : integer;
    veh___609___.prev_rel_pos : integer;
    veh___609___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___609___.v : integer;

    veh___609___.lane_b0 : boolean;
    veh___609___.lane_b1 : boolean;
    veh___609___.lane_b2 : boolean;
    veh___609___.lane_b3 : boolean;
    

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___609___.on_straight_section : -1 .. 0;
      veh___609___.traversion_from : -1 .. 0;
      veh___609___.traversion_to : -1 .. 0;

      INVAR veh___609___.on_straight_section = -1 -> (veh___609___.traversion_from != -1 & veh___609___.traversion_from != -1);
      INVAR (veh___609___.traversion_from != -1 | veh___609___.traversion_from != -1) -> veh___609___.on_straight_section = -1;
      INVAR veh___609___.traversion_from = -1 <-> veh___609___.traversion_to = -1;

      INIT veh___609___.traversion_from = -1; -- TODO: For now non-egos start on straight roads; there is no constraint prohibiting them being placed beyond the end of the arc.

      VAR veh___609___.is_on_sec_0 : 0..1;
         INVAR (veh___609___.is_on_sec_0 = 1) <-> (veh___609___.on_straight_section = 0);
         
         
      

	VAR

   veh___619___.time_since_last_lc : 0..min_time_between_lcs;


    veh___619___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___619___.prev_abs_pos : integer;
    veh___619___.prev_rel_pos : integer;
    veh___619___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___619___.v : integer;

    veh___619___.lane_b0 : boolean;
    veh___619___.lane_b1 : boolean;
    veh___619___.lane_b2 : boolean;
    veh___619___.lane_b3 : boolean;
    

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___619___.on_straight_section : -1 .. 0;
      veh___619___.traversion_from : -1 .. 0;
      veh___619___.traversion_to : -1 .. 0;

      INVAR veh___619___.on_straight_section = -1 -> (veh___619___.traversion_from != -1 & veh___619___.traversion_from != -1);
      INVAR (veh___619___.traversion_from != -1 | veh___619___.traversion_from != -1) -> veh___619___.on_straight_section = -1;
      INVAR veh___619___.traversion_from = -1 <-> veh___619___.traversion_to = -1;

      INIT veh___619___.traversion_from = -1; -- TODO: For now non-egos start on straight roads; there is no constraint prohibiting them being placed beyond the end of the arc.

      VAR veh___619___.is_on_sec_0 : 0..1;
         INVAR (veh___619___.is_on_sec_0 = 1) <-> (veh___619___.on_straight_section = 0);
         
         
      

	VAR

   veh___629___.time_since_last_lc : 0..min_time_between_lcs;


    veh___629___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___629___.prev_abs_pos : integer;
    veh___629___.prev_rel_pos : integer;
    veh___629___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___629___.v : integer;

    veh___629___.lane_b0 : boolean;
    veh___629___.lane_b1 : boolean;
    veh___629___.lane_b2 : boolean;
    veh___629___.lane_b3 : boolean;
    

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___629___.on_straight_section : -1 .. 0;
      veh___629___.traversion_from : -1 .. 0;
      veh___629___.traversion_to : -1 .. 0;

      INVAR veh___629___.on_straight_section = -1 -> (veh___629___.traversion_from != -1 & veh___629___.traversion_from != -1);
      INVAR (veh___629___.traversion_from != -1 | veh___629___.traversion_from != -1) -> veh___629___.on_straight_section = -1;
      INVAR veh___629___.traversion_from = -1 <-> veh___629___.traversion_to = -1;

      INIT veh___629___.traversion_from = -1; -- TODO: For now non-egos start on straight roads; there is no constraint prohibiting them being placed beyond the end of the arc.

      VAR veh___629___.is_on_sec_0 : 0..1;
         INVAR (veh___629___.is_on_sec_0 = 1) <-> (veh___629___.on_straight_section = 0);
         
         
      

	VAR

   veh___639___.time_since_last_lc : 0..min_time_between_lcs;


    veh___639___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___639___.prev_abs_pos : integer;
    veh___639___.prev_rel_pos : integer;
    veh___639___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___639___.v : integer;

    veh___639___.lane_b0 : boolean;
    veh___639___.lane_b1 : boolean;
    veh___639___.lane_b2 : boolean;
    veh___639___.lane_b3 : boolean;
    

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___639___.on_straight_section : -1 .. 0;
      veh___639___.traversion_from : -1 .. 0;
      veh___639___.traversion_to : -1 .. 0;

      INVAR veh___639___.on_straight_section = -1 -> (veh___639___.traversion_from != -1 & veh___639___.traversion_from != -1);
      INVAR (veh___639___.traversion_from != -1 | veh___639___.traversion_from != -1) -> veh___639___.on_straight_section = -1;
      INVAR veh___639___.traversion_from = -1 <-> veh___639___.traversion_to = -1;

      INIT veh___639___.traversion_from = -1; -- TODO: For now non-egos start on straight roads; there is no constraint prohibiting them being placed beyond the end of the arc.

      VAR veh___639___.is_on_sec_0 : 0..1;
         INVAR (veh___639___.is_on_sec_0 = 1) <-> (veh___639___.on_straight_section = 0);
         
         
      

	VAR

   veh___649___.time_since_last_lc : 0..min_time_between_lcs;


    veh___649___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___649___.prev_abs_pos : integer;
    veh___649___.prev_rel_pos : integer;
    veh___649___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___649___.v : integer;

    veh___649___.lane_b0 : boolean;
    veh___649___.lane_b1 : boolean;
    veh___649___.lane_b2 : boolean;
    veh___649___.lane_b3 : boolean;
    

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___649___.on_straight_section : -1 .. 0;
      veh___649___.traversion_from : -1 .. 0;
      veh___649___.traversion_to : -1 .. 0;

      INVAR veh___649___.on_straight_section = -1 -> (veh___649___.traversion_from != -1 & veh___649___.traversion_from != -1);
      INVAR (veh___649___.traversion_from != -1 | veh___649___.traversion_from != -1) -> veh___649___.on_straight_section = -1;
      INVAR veh___649___.traversion_from = -1 <-> veh___649___.traversion_to = -1;

      INIT veh___649___.traversion_from = -1; -- TODO: For now non-egos start on straight roads; there is no constraint prohibiting them being placed beyond the end of the arc.

      VAR veh___649___.is_on_sec_0 : 0..1;
         INVAR (veh___649___.is_on_sec_0 = 1) <-> (veh___649___.on_straight_section = 0);
         
         
      

	

   
   INVAR veh___609___.is_on_sec_0
          = 1;

      TRANS veh___609___.time_since_last_lc < min_time_between_lcs | veh___609___.v < 10 -> veh___609___.lane_unchanged;
      TRANS veh___609___.lane_unchanged | veh___609___.lane_move_down | veh___609___.lane_move_up;

      -- TRANS 
      --   (veh___609___.lane_unchanged | veh___619___.lane_unchanged)
      -- & (veh___619___.lane_unchanged | veh___629___.lane_unchanged)
      -- & (veh___629___.lane_unchanged | veh___639___.lane_unchanged)
      -- & (veh___639___.lane_unchanged | veh___649___.lane_unchanged)
      -- ;

	INVAR veh___619___.is_on_sec_0
          = 1;

      TRANS veh___619___.time_since_last_lc < min_time_between_lcs | veh___619___.v < 10 -> veh___619___.lane_unchanged;
      TRANS veh___619___.lane_unchanged | veh___619___.lane_move_down | veh___619___.lane_move_up;

	INVAR veh___629___.is_on_sec_0
          = 1;

      TRANS veh___629___.time_since_last_lc < min_time_between_lcs | veh___629___.v < 10 -> veh___629___.lane_unchanged;
      TRANS veh___629___.lane_unchanged | veh___629___.lane_move_down | veh___629___.lane_move_up;

	INVAR veh___639___.is_on_sec_0
          = 1;

      TRANS veh___639___.time_since_last_lc < min_time_between_lcs | veh___639___.v < 10 -> veh___639___.lane_unchanged;
      TRANS veh___639___.lane_unchanged | veh___639___.lane_move_down | veh___639___.lane_move_up;

	INVAR veh___649___.is_on_sec_0
          = 1;

      TRANS veh___649___.time_since_last_lc < min_time_between_lcs | veh___649___.v < 10 -> veh___649___.lane_unchanged;
      TRANS veh___649___.lane_unchanged | veh___649___.lane_move_down | veh___649___.lane_move_up;

	


DEFINE

-- Make sure non-egos do not drive on the GREEN.

veh___609___.on_lane_min := case
   veh___609___.lane_b0 : 0;
   veh___609___.lane_b1 : 1;
   veh___609___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___619___.on_lane_min := case
   veh___619___.lane_b0 : 0;
   veh___619___.lane_b1 : 1;
   veh___619___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___629___.on_lane_min := case
   veh___629___.lane_b0 : 0;
   veh___629___.lane_b1 : 1;
   veh___629___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___639___.on_lane_min := case
   veh___639___.lane_b0 : 0;
   veh___639___.lane_b1 : 1;
   veh___639___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___649___.on_lane_min := case
   veh___649___.lane_b0 : 0;
   veh___649___.lane_b1 : 1;
   veh___649___.lane_b2 : 2;
   TRUE : 3;
esac;


veh___609___.on_lane_max := case
   veh___609___.lane_b3 : 3;
   veh___609___.lane_b2 : 2;
   veh___609___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___619___.on_lane_max := case
   veh___619___.lane_b3 : 3;
   veh___619___.lane_b2 : 2;
   veh___619___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___629___.on_lane_max := case
   veh___629___.lane_b3 : 3;
   veh___629___.lane_b2 : 2;
   veh___629___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___639___.on_lane_max := case
   veh___639___.lane_b3 : 3;
   veh___639___.lane_b2 : 2;
   veh___639___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___649___.on_lane_max := case
   veh___649___.lane_b3 : 3;
   veh___649___.lane_b2 : 2;
   veh___649___.lane_b1 : 1;
   TRUE : 0;
esac;







INVAR veh___609___.on_straight_section = 0
   -> ((veh___609___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___609___.on_lane_min >= section_0_segment_0_min_lane & veh___609___.on_lane_max <= section_0_segment_0_max_lane));

   

   INVAR veh___609___.on_straight_section = 0
   -> ((veh___609___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___609___.on_lane_min >= section_0_segment_0_min_lane & veh___609___.on_lane_max <= section_0_segment_0_max_lane));

INVAR veh___619___.on_straight_section = 0
   -> ((veh___619___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___619___.on_lane_min >= section_0_segment_0_min_lane & veh___619___.on_lane_max <= section_0_segment_0_max_lane));

   

   INVAR veh___619___.on_straight_section = 0
   -> ((veh___619___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___619___.on_lane_min >= section_0_segment_0_min_lane & veh___619___.on_lane_max <= section_0_segment_0_max_lane));

INVAR veh___629___.on_straight_section = 0
   -> ((veh___629___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___629___.on_lane_min >= section_0_segment_0_min_lane & veh___629___.on_lane_max <= section_0_segment_0_max_lane));

   

   INVAR veh___629___.on_straight_section = 0
   -> ((veh___629___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___629___.on_lane_min >= section_0_segment_0_min_lane & veh___629___.on_lane_max <= section_0_segment_0_max_lane));

INVAR veh___639___.on_straight_section = 0
   -> ((veh___639___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___639___.on_lane_min >= section_0_segment_0_min_lane & veh___639___.on_lane_max <= section_0_segment_0_max_lane));

   

   INVAR veh___639___.on_straight_section = 0
   -> ((veh___639___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___639___.on_lane_min >= section_0_segment_0_min_lane & veh___639___.on_lane_max <= section_0_segment_0_max_lane));

INVAR veh___649___.on_straight_section = 0
   -> ((veh___649___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___649___.on_lane_min >= section_0_segment_0_min_lane & veh___649___.on_lane_max <= section_0_segment_0_max_lane));

   

   INVAR veh___649___.on_straight_section = 0
   -> ((veh___649___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___649___.on_lane_min >= section_0_segment_0_min_lane & veh___649___.on_lane_max <= section_0_segment_0_max_lane));




-- EO Make sure non-egos do not drive on the GREEN.


DEFINE

	-- >>> Car 0 <<<
    veh___609___.lane_0 := veh___609___.lane_b0 & !veh___609___.lane_b1& !veh___609___.lane_b2& !veh___609___.lane_b3;
    veh___609___.lane_01 := veh___609___.lane_b0 &veh___609___.lane_b1 &!veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_1 := !veh___609___.lane_b0 &veh___609___.lane_b1 &!veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_12 := !veh___609___.lane_b0 &veh___609___.lane_b1 &veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_2 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_23 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &veh___609___.lane_b2 &veh___609___.lane_b3 ;
    veh___609___.lane_3 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &!veh___609___.lane_b2 &veh___609___.lane_b3 ;
    

    veh___609___.lane_min := veh___609___.lane_0;
    veh___609___.lane_max := veh___609___.lane_3;
    veh___609___.lane_single := veh___609___.lane_0 |veh___609___.lane_1 |veh___609___.lane_2 |veh___609___.lane_3 ;
    veh___609___.lane_crossing := FALSE | veh___609___.lane_01| veh___609___.lane_12| veh___609___.lane_23;
    veh___609___.lane_unchanged := veh___609___.lane_b0 = next(veh___609___.lane_b0)&veh___609___.lane_b1 = next(veh___609___.lane_b1)&veh___609___.lane_b2 = next(veh___609___.lane_b2)&veh___609___.lane_b3 = next(veh___609___.lane_b3);
    veh___609___.lane_move_down := 
                      (veh___609___.lane_0 -> next(veh___609___.lane_0))
                      & (veh___609___.lane_01 -> next(veh___609___.lane_0))
                      & (veh___609___.lane_1 -> next(veh___609___.lane_01))
                      & (veh___609___.lane_12 -> next(veh___609___.lane_1))
                      & (veh___609___.lane_2 -> next(veh___609___.lane_12))
                      & (veh___609___.lane_23 -> next(veh___609___.lane_2))
                      & (veh___609___.lane_3 -> next(veh___609___.lane_23))
                      ;
    veh___609___.lane_move_up :=
                      (veh___609___.lane_3 -> next(veh___609___.lane_3))
                      & (veh___609___.lane_01 -> next(veh___609___.lane_1))
                      & (veh___609___.lane_0 -> next(veh___609___.lane_01))
                      & (veh___609___.lane_12 -> next(veh___609___.lane_2))
                      & (veh___609___.lane_1 -> next(veh___609___.lane_12))
                      & (veh___609___.lane_23 -> next(veh___609___.lane_3))
                      & (veh___609___.lane_2 -> next(veh___609___.lane_23))
                      ;


   
   
	
	
	-- >>> Car 1 <<<
    veh___619___.lane_0 := veh___619___.lane_b0 & !veh___619___.lane_b1& !veh___619___.lane_b2& !veh___619___.lane_b3;
    veh___619___.lane_01 := veh___619___.lane_b0 &veh___619___.lane_b1 &!veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_1 := !veh___619___.lane_b0 &veh___619___.lane_b1 &!veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_12 := !veh___619___.lane_b0 &veh___619___.lane_b1 &veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_2 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_23 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &veh___619___.lane_b2 &veh___619___.lane_b3 ;
    veh___619___.lane_3 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &!veh___619___.lane_b2 &veh___619___.lane_b3 ;
    

    veh___619___.lane_min := veh___619___.lane_0;
    veh___619___.lane_max := veh___619___.lane_3;
    veh___619___.lane_single := veh___619___.lane_0 |veh___619___.lane_1 |veh___619___.lane_2 |veh___619___.lane_3 ;
    veh___619___.lane_crossing := FALSE | veh___619___.lane_01| veh___619___.lane_12| veh___619___.lane_23;
    veh___619___.lane_unchanged := veh___619___.lane_b0 = next(veh___619___.lane_b0)&veh___619___.lane_b1 = next(veh___619___.lane_b1)&veh___619___.lane_b2 = next(veh___619___.lane_b2)&veh___619___.lane_b3 = next(veh___619___.lane_b3);
    veh___619___.lane_move_down := 
                      (veh___619___.lane_0 -> next(veh___619___.lane_0))
                      & (veh___619___.lane_01 -> next(veh___619___.lane_0))
                      & (veh___619___.lane_1 -> next(veh___619___.lane_01))
                      & (veh___619___.lane_12 -> next(veh___619___.lane_1))
                      & (veh___619___.lane_2 -> next(veh___619___.lane_12))
                      & (veh___619___.lane_23 -> next(veh___619___.lane_2))
                      & (veh___619___.lane_3 -> next(veh___619___.lane_23))
                      ;
    veh___619___.lane_move_up :=
                      (veh___619___.lane_3 -> next(veh___619___.lane_3))
                      & (veh___619___.lane_01 -> next(veh___619___.lane_1))
                      & (veh___619___.lane_0 -> next(veh___619___.lane_01))
                      & (veh___619___.lane_12 -> next(veh___619___.lane_2))
                      & (veh___619___.lane_1 -> next(veh___619___.lane_12))
                      & (veh___619___.lane_23 -> next(veh___619___.lane_3))
                      & (veh___619___.lane_2 -> next(veh___619___.lane_23))
                      ;


   
   
	veh___619___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___619___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___619___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___619___.lane_b2) & !(veh___609___.lane_b2 & veh___619___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___619___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___619___.lane_b3) & !(veh___609___.lane_b3 & veh___619___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___619___.lane_b3) ) --   )
      
   );
   
	
	-- >>> Car 2 <<<
    veh___629___.lane_0 := veh___629___.lane_b0 & !veh___629___.lane_b1& !veh___629___.lane_b2& !veh___629___.lane_b3;
    veh___629___.lane_01 := veh___629___.lane_b0 &veh___629___.lane_b1 &!veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_1 := !veh___629___.lane_b0 &veh___629___.lane_b1 &!veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_12 := !veh___629___.lane_b0 &veh___629___.lane_b1 &veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_2 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_23 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &veh___629___.lane_b2 &veh___629___.lane_b3 ;
    veh___629___.lane_3 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &!veh___629___.lane_b2 &veh___629___.lane_b3 ;
    

    veh___629___.lane_min := veh___629___.lane_0;
    veh___629___.lane_max := veh___629___.lane_3;
    veh___629___.lane_single := veh___629___.lane_0 |veh___629___.lane_1 |veh___629___.lane_2 |veh___629___.lane_3 ;
    veh___629___.lane_crossing := FALSE | veh___629___.lane_01| veh___629___.lane_12| veh___629___.lane_23;
    veh___629___.lane_unchanged := veh___629___.lane_b0 = next(veh___629___.lane_b0)&veh___629___.lane_b1 = next(veh___629___.lane_b1)&veh___629___.lane_b2 = next(veh___629___.lane_b2)&veh___629___.lane_b3 = next(veh___629___.lane_b3);
    veh___629___.lane_move_down := 
                      (veh___629___.lane_0 -> next(veh___629___.lane_0))
                      & (veh___629___.lane_01 -> next(veh___629___.lane_0))
                      & (veh___629___.lane_1 -> next(veh___629___.lane_01))
                      & (veh___629___.lane_12 -> next(veh___629___.lane_1))
                      & (veh___629___.lane_2 -> next(veh___629___.lane_12))
                      & (veh___629___.lane_23 -> next(veh___629___.lane_2))
                      & (veh___629___.lane_3 -> next(veh___629___.lane_23))
                      ;
    veh___629___.lane_move_up :=
                      (veh___629___.lane_3 -> next(veh___629___.lane_3))
                      & (veh___629___.lane_01 -> next(veh___629___.lane_1))
                      & (veh___629___.lane_0 -> next(veh___629___.lane_01))
                      & (veh___629___.lane_12 -> next(veh___629___.lane_2))
                      & (veh___629___.lane_1 -> next(veh___629___.lane_12))
                      & (veh___629___.lane_23 -> next(veh___629___.lane_3))
                      & (veh___629___.lane_2 -> next(veh___629___.lane_23))
                      ;


   
   
	veh___629___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___629___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___629___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___629___.lane_b2) & !(veh___609___.lane_b2 & veh___629___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___629___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___629___.lane_b3) & !(veh___609___.lane_b3 & veh___629___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___629___.lane_b3) ) --   )
      
   );
   veh___629___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___629___.lane_b0) ) --   )
      | ((veh___619___.lane_b1 & veh___629___.lane_b1) ) --  & !(veh___619___.lane_b0 & veh___629___.lane_b2) & !(veh___619___.lane_b2 & veh___629___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___629___.lane_b2) ) --  & !(veh___619___.lane_b1 & veh___629___.lane_b3) & !(veh___619___.lane_b3 & veh___629___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___629___.lane_b3) ) --   )
      
   );
   
	
	-- >>> Car 3 <<<
    veh___639___.lane_0 := veh___639___.lane_b0 & !veh___639___.lane_b1& !veh___639___.lane_b2& !veh___639___.lane_b3;
    veh___639___.lane_01 := veh___639___.lane_b0 &veh___639___.lane_b1 &!veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_1 := !veh___639___.lane_b0 &veh___639___.lane_b1 &!veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_12 := !veh___639___.lane_b0 &veh___639___.lane_b1 &veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_2 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_23 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &veh___639___.lane_b2 &veh___639___.lane_b3 ;
    veh___639___.lane_3 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &!veh___639___.lane_b2 &veh___639___.lane_b3 ;
    

    veh___639___.lane_min := veh___639___.lane_0;
    veh___639___.lane_max := veh___639___.lane_3;
    veh___639___.lane_single := veh___639___.lane_0 |veh___639___.lane_1 |veh___639___.lane_2 |veh___639___.lane_3 ;
    veh___639___.lane_crossing := FALSE | veh___639___.lane_01| veh___639___.lane_12| veh___639___.lane_23;
    veh___639___.lane_unchanged := veh___639___.lane_b0 = next(veh___639___.lane_b0)&veh___639___.lane_b1 = next(veh___639___.lane_b1)&veh___639___.lane_b2 = next(veh___639___.lane_b2)&veh___639___.lane_b3 = next(veh___639___.lane_b3);
    veh___639___.lane_move_down := 
                      (veh___639___.lane_0 -> next(veh___639___.lane_0))
                      & (veh___639___.lane_01 -> next(veh___639___.lane_0))
                      & (veh___639___.lane_1 -> next(veh___639___.lane_01))
                      & (veh___639___.lane_12 -> next(veh___639___.lane_1))
                      & (veh___639___.lane_2 -> next(veh___639___.lane_12))
                      & (veh___639___.lane_23 -> next(veh___639___.lane_2))
                      & (veh___639___.lane_3 -> next(veh___639___.lane_23))
                      ;
    veh___639___.lane_move_up :=
                      (veh___639___.lane_3 -> next(veh___639___.lane_3))
                      & (veh___639___.lane_01 -> next(veh___639___.lane_1))
                      & (veh___639___.lane_0 -> next(veh___639___.lane_01))
                      & (veh___639___.lane_12 -> next(veh___639___.lane_2))
                      & (veh___639___.lane_1 -> next(veh___639___.lane_12))
                      & (veh___639___.lane_23 -> next(veh___639___.lane_3))
                      & (veh___639___.lane_2 -> next(veh___639___.lane_23))
                      ;


   
   
	veh___639___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___639___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___639___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___639___.lane_b2) & !(veh___609___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___639___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___639___.lane_b3) & !(veh___609___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___639___.lane_b3) ) --   )
      
   );
   veh___639___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___639___.lane_b0) ) --   )
      | ((veh___619___.lane_b1 & veh___639___.lane_b1) ) --  & !(veh___619___.lane_b0 & veh___639___.lane_b2) & !(veh___619___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___639___.lane_b2) ) --  & !(veh___619___.lane_b1 & veh___639___.lane_b3) & !(veh___619___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___639___.lane_b3) ) --   )
      
   );
   veh___639___.same_lane_as_veh_2 := (FALSE
      | ((veh___629___.lane_b0 & veh___639___.lane_b0) ) --   )
      | ((veh___629___.lane_b1 & veh___639___.lane_b1) ) --  & !(veh___629___.lane_b0 & veh___639___.lane_b2) & !(veh___629___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___629___.lane_b2 & veh___639___.lane_b2) ) --  & !(veh___629___.lane_b1 & veh___639___.lane_b3) & !(veh___629___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___629___.lane_b3 & veh___639___.lane_b3) ) --   )
      
   );
   
	
	-- >>> Car 4 <<<
    veh___649___.lane_0 := veh___649___.lane_b0 & !veh___649___.lane_b1& !veh___649___.lane_b2& !veh___649___.lane_b3;
    veh___649___.lane_01 := veh___649___.lane_b0 &veh___649___.lane_b1 &!veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_1 := !veh___649___.lane_b0 &veh___649___.lane_b1 &!veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_12 := !veh___649___.lane_b0 &veh___649___.lane_b1 &veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_2 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_23 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &veh___649___.lane_b2 &veh___649___.lane_b3 ;
    veh___649___.lane_3 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &!veh___649___.lane_b2 &veh___649___.lane_b3 ;
    

    veh___649___.lane_min := veh___649___.lane_0;
    veh___649___.lane_max := veh___649___.lane_3;
    veh___649___.lane_single := veh___649___.lane_0 |veh___649___.lane_1 |veh___649___.lane_2 |veh___649___.lane_3 ;
    veh___649___.lane_crossing := FALSE | veh___649___.lane_01| veh___649___.lane_12| veh___649___.lane_23;
    veh___649___.lane_unchanged := veh___649___.lane_b0 = next(veh___649___.lane_b0)&veh___649___.lane_b1 = next(veh___649___.lane_b1)&veh___649___.lane_b2 = next(veh___649___.lane_b2)&veh___649___.lane_b3 = next(veh___649___.lane_b3);
    veh___649___.lane_move_down := 
                      (veh___649___.lane_0 -> next(veh___649___.lane_0))
                      & (veh___649___.lane_01 -> next(veh___649___.lane_0))
                      & (veh___649___.lane_1 -> next(veh___649___.lane_01))
                      & (veh___649___.lane_12 -> next(veh___649___.lane_1))
                      & (veh___649___.lane_2 -> next(veh___649___.lane_12))
                      & (veh___649___.lane_23 -> next(veh___649___.lane_2))
                      & (veh___649___.lane_3 -> next(veh___649___.lane_23))
                      ;
    veh___649___.lane_move_up :=
                      (veh___649___.lane_3 -> next(veh___649___.lane_3))
                      & (veh___649___.lane_01 -> next(veh___649___.lane_1))
                      & (veh___649___.lane_0 -> next(veh___649___.lane_01))
                      & (veh___649___.lane_12 -> next(veh___649___.lane_2))
                      & (veh___649___.lane_1 -> next(veh___649___.lane_12))
                      & (veh___649___.lane_23 -> next(veh___649___.lane_3))
                      & (veh___649___.lane_2 -> next(veh___649___.lane_23))
                      ;


   
   
	veh___649___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___649___.lane_b2) & !(veh___609___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___649___.lane_b3) & !(veh___609___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   veh___649___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___619___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___619___.lane_b0 & veh___649___.lane_b2) & !(veh___619___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___619___.lane_b1 & veh___649___.lane_b3) & !(veh___619___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   veh___649___.same_lane_as_veh_2 := (FALSE
      | ((veh___629___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___629___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___629___.lane_b0 & veh___649___.lane_b2) & !(veh___629___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___629___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___629___.lane_b1 & veh___649___.lane_b3) & !(veh___629___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___629___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   veh___649___.same_lane_as_veh_3 := (FALSE
      | ((veh___639___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___639___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___639___.lane_b0 & veh___649___.lane_b2) & !(veh___639___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___639___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___639___.lane_b1 & veh___649___.lane_b3) & !(veh___639___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___639___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   
	
	


-- >>> Car 0 <<<


DEFINE
   veh___609___.rel_pos := veh___609___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___609___.next_abs_pos := veh___609___.abs_pos + next(veh___609___.v);

INVAR
    veh___609___.lane_single | veh___609___.lane_crossing;

INVAR
    (max(-veh___609___.v, a_min) <= veh___609___.a & veh___609___.a <= a_max) &
    (0 <= veh___609___.v & veh___609___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_0 := case
   veh___609___.v = 0 : 0;
   veh___609___.v = 1 : 1;
   veh___609___.v = 2 : 4;
   veh___609___.v = 3 : 9;
   veh___609___.v = 4 : 16;
   veh___609___.v = 5 : 25;
   veh___609___.v = 6 : 36;
   veh___609___.v = 7 : 49;
   veh___609___.v = 8 : 64;
   veh___609___.v = 9 : 81;
   veh___609___.v = 10 : 100;
   veh___609___.v = 11 : 121;
   veh___609___.v = 12 : 144;
   veh___609___.v = 13 : 169;
   veh___609___.v = 14 : 196;
   veh___609___.v = 15 : 225;
   veh___609___.v = 16 : 256;
   veh___609___.v = 17 : 289;
   veh___609___.v = 18 : 324;
   veh___609___.v = 19 : 361;
   veh___609___.v = 20 : 400;
   veh___609___.v = 21 : 441;
   veh___609___.v = 22 : 484;
   veh___609___.v = 23 : 529;
   veh___609___.v = 24 : 576;
   veh___609___.v = 25 : 625;
   veh___609___.v = 26 : 676;
   veh___609___.v = 27 : 729;
   veh___609___.v = 28 : 784;
   veh___609___.v = 29 : 841;
   veh___609___.v = 30 : 900;
   veh___609___.v = 31 : 961;
   veh___609___.v = 32 : 1024;
   veh___609___.v = 33 : 1089;
   veh___609___.v = 34 : 1156;
   veh___609___.v = 35 : 1225;
   veh___609___.v = 36 : 1296;
   veh___609___.v = 37 : 1369;
   veh___609___.v = 38 : 1444;
   veh___609___.v = 39 : 1521;
   veh___609___.v = 40 : 1600;
   veh___609___.v = 41 : 1681;
   veh___609___.v = 42 : 1764;
   veh___609___.v = 43 : 1849;
   veh___609___.v = 44 : 1936;
   veh___609___.v = 45 : 2025;
   veh___609___.v = 46 : 2116;
   veh___609___.v = 47 : 2209;
   veh___609___.v = 48 : 2304;
   veh___609___.v = 49 : 2401;
   veh___609___.v = 50 : 2500;
   veh___609___.v = 51 : 2601;
   veh___609___.v = 52 : 2704;
   veh___609___.v = 53 : 2809;
   veh___609___.v = 54 : 2916;
   veh___609___.v = 55 : 3025;
   veh___609___.v = 56 : 3136;
   veh___609___.v = 57 : 3249;
   veh___609___.v = 58 : 3364;
   veh___609___.v = 59 : 3481;
   veh___609___.v = 60 : 3600;
   veh___609___.v = 61 : 3721;
   veh___609___.v = 62 : 3844;
   veh___609___.v = 63 : 3969;
   veh___609___.v = 64 : 4096;
   veh___609___.v = 65 : 4225;
   veh___609___.v = 66 : 4356;
   veh___609___.v = 67 : 4489;
   veh___609___.v = 68 : 4624;
   veh___609___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

-- >>> Car 1 <<<


DEFINE
   veh___619___.rel_pos := veh___619___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___619___.next_abs_pos := veh___619___.abs_pos + next(veh___619___.v);

INVAR
    veh___619___.lane_single | veh___619___.lane_crossing;

INVAR
    (max(-veh___619___.v, a_min) <= veh___619___.a & veh___619___.a <= a_max) &
    (0 <= veh___619___.v & veh___619___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_1 := case
   veh___619___.v = 0 : 0;
   veh___619___.v = 1 : 1;
   veh___619___.v = 2 : 4;
   veh___619___.v = 3 : 9;
   veh___619___.v = 4 : 16;
   veh___619___.v = 5 : 25;
   veh___619___.v = 6 : 36;
   veh___619___.v = 7 : 49;
   veh___619___.v = 8 : 64;
   veh___619___.v = 9 : 81;
   veh___619___.v = 10 : 100;
   veh___619___.v = 11 : 121;
   veh___619___.v = 12 : 144;
   veh___619___.v = 13 : 169;
   veh___619___.v = 14 : 196;
   veh___619___.v = 15 : 225;
   veh___619___.v = 16 : 256;
   veh___619___.v = 17 : 289;
   veh___619___.v = 18 : 324;
   veh___619___.v = 19 : 361;
   veh___619___.v = 20 : 400;
   veh___619___.v = 21 : 441;
   veh___619___.v = 22 : 484;
   veh___619___.v = 23 : 529;
   veh___619___.v = 24 : 576;
   veh___619___.v = 25 : 625;
   veh___619___.v = 26 : 676;
   veh___619___.v = 27 : 729;
   veh___619___.v = 28 : 784;
   veh___619___.v = 29 : 841;
   veh___619___.v = 30 : 900;
   veh___619___.v = 31 : 961;
   veh___619___.v = 32 : 1024;
   veh___619___.v = 33 : 1089;
   veh___619___.v = 34 : 1156;
   veh___619___.v = 35 : 1225;
   veh___619___.v = 36 : 1296;
   veh___619___.v = 37 : 1369;
   veh___619___.v = 38 : 1444;
   veh___619___.v = 39 : 1521;
   veh___619___.v = 40 : 1600;
   veh___619___.v = 41 : 1681;
   veh___619___.v = 42 : 1764;
   veh___619___.v = 43 : 1849;
   veh___619___.v = 44 : 1936;
   veh___619___.v = 45 : 2025;
   veh___619___.v = 46 : 2116;
   veh___619___.v = 47 : 2209;
   veh___619___.v = 48 : 2304;
   veh___619___.v = 49 : 2401;
   veh___619___.v = 50 : 2500;
   veh___619___.v = 51 : 2601;
   veh___619___.v = 52 : 2704;
   veh___619___.v = 53 : 2809;
   veh___619___.v = 54 : 2916;
   veh___619___.v = 55 : 3025;
   veh___619___.v = 56 : 3136;
   veh___619___.v = 57 : 3249;
   veh___619___.v = 58 : 3364;
   veh___619___.v = 59 : 3481;
   veh___619___.v = 60 : 3600;
   veh___619___.v = 61 : 3721;
   veh___619___.v = 62 : 3844;
   veh___619___.v = 63 : 3969;
   veh___619___.v = 64 : 4096;
   veh___619___.v = 65 : 4225;
   veh___619___.v = 66 : 4356;
   veh___619___.v = 67 : 4489;
   veh___619___.v = 68 : 4624;
   veh___619___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_1_and_veh_0_on_same_seclet := 
veh___619___.on_straight_section = veh___609___.on_straight_section & veh___619___.traversion_from = veh___609___.traversion_from & veh___619___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_1_and_veh_0_on_same_seclet -> (veh___619___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___619___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_1_and_veh_0_on_same_seclet -> (
       !(veh___619___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___609___.abs_pos >= veh___619___.abs_pos)) &
       !(veh___619___.same_lane_as_veh_0 & (veh___619___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___619___.abs_pos >= veh___609___.abs_pos)));
	
-- >>> Car 2 <<<


DEFINE
   veh___629___.rel_pos := veh___629___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___629___.next_abs_pos := veh___629___.abs_pos + next(veh___629___.v);

INVAR
    veh___629___.lane_single | veh___629___.lane_crossing;

INVAR
    (max(-veh___629___.v, a_min) <= veh___629___.a & veh___629___.a <= a_max) &
    (0 <= veh___629___.v & veh___629___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_2 := case
   veh___629___.v = 0 : 0;
   veh___629___.v = 1 : 1;
   veh___629___.v = 2 : 4;
   veh___629___.v = 3 : 9;
   veh___629___.v = 4 : 16;
   veh___629___.v = 5 : 25;
   veh___629___.v = 6 : 36;
   veh___629___.v = 7 : 49;
   veh___629___.v = 8 : 64;
   veh___629___.v = 9 : 81;
   veh___629___.v = 10 : 100;
   veh___629___.v = 11 : 121;
   veh___629___.v = 12 : 144;
   veh___629___.v = 13 : 169;
   veh___629___.v = 14 : 196;
   veh___629___.v = 15 : 225;
   veh___629___.v = 16 : 256;
   veh___629___.v = 17 : 289;
   veh___629___.v = 18 : 324;
   veh___629___.v = 19 : 361;
   veh___629___.v = 20 : 400;
   veh___629___.v = 21 : 441;
   veh___629___.v = 22 : 484;
   veh___629___.v = 23 : 529;
   veh___629___.v = 24 : 576;
   veh___629___.v = 25 : 625;
   veh___629___.v = 26 : 676;
   veh___629___.v = 27 : 729;
   veh___629___.v = 28 : 784;
   veh___629___.v = 29 : 841;
   veh___629___.v = 30 : 900;
   veh___629___.v = 31 : 961;
   veh___629___.v = 32 : 1024;
   veh___629___.v = 33 : 1089;
   veh___629___.v = 34 : 1156;
   veh___629___.v = 35 : 1225;
   veh___629___.v = 36 : 1296;
   veh___629___.v = 37 : 1369;
   veh___629___.v = 38 : 1444;
   veh___629___.v = 39 : 1521;
   veh___629___.v = 40 : 1600;
   veh___629___.v = 41 : 1681;
   veh___629___.v = 42 : 1764;
   veh___629___.v = 43 : 1849;
   veh___629___.v = 44 : 1936;
   veh___629___.v = 45 : 2025;
   veh___629___.v = 46 : 2116;
   veh___629___.v = 47 : 2209;
   veh___629___.v = 48 : 2304;
   veh___629___.v = 49 : 2401;
   veh___629___.v = 50 : 2500;
   veh___629___.v = 51 : 2601;
   veh___629___.v = 52 : 2704;
   veh___629___.v = 53 : 2809;
   veh___629___.v = 54 : 2916;
   veh___629___.v = 55 : 3025;
   veh___629___.v = 56 : 3136;
   veh___629___.v = 57 : 3249;
   veh___629___.v = 58 : 3364;
   veh___629___.v = 59 : 3481;
   veh___629___.v = 60 : 3600;
   veh___629___.v = 61 : 3721;
   veh___629___.v = 62 : 3844;
   veh___629___.v = 63 : 3969;
   veh___629___.v = 64 : 4096;
   veh___629___.v = 65 : 4225;
   veh___629___.v = 66 : 4356;
   veh___629___.v = 67 : 4489;
   veh___629___.v = 68 : 4624;
   veh___629___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_2_and_veh_0_on_same_seclet := 
veh___629___.on_straight_section = veh___609___.on_straight_section & veh___629___.traversion_from = veh___609___.traversion_from & veh___629___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_2_and_veh_0_on_same_seclet -> (veh___629___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___629___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_2_and_veh_0_on_same_seclet -> (
       !(veh___629___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___609___.abs_pos >= veh___629___.abs_pos)) &
       !(veh___629___.same_lane_as_veh_0 & (veh___629___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___629___.abs_pos >= veh___609___.abs_pos)));
	
DEFINE veh_2_and_veh_1_on_same_seclet := 
veh___629___.on_straight_section = veh___619___.on_straight_section & veh___629___.traversion_from = veh___619___.traversion_from & veh___629___.traversion_to = veh___619___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_2_and_veh_1_on_same_seclet -> (veh___629___.same_lane_as_veh_1 -> (abs(veh___619___.abs_pos - veh___629___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_2_and_veh_1_on_same_seclet -> (
       !(veh___629___.same_lane_as_veh_1 & (veh___619___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___619___.abs_pos >= veh___629___.abs_pos)) &
       !(veh___629___.same_lane_as_veh_1 & (veh___629___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___629___.abs_pos >= veh___619___.abs_pos)));
	
-- >>> Car 3 <<<


DEFINE
   veh___639___.rel_pos := veh___639___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___639___.next_abs_pos := veh___639___.abs_pos + next(veh___639___.v);

INVAR
    veh___639___.lane_single | veh___639___.lane_crossing;

INVAR
    (max(-veh___639___.v, a_min) <= veh___639___.a & veh___639___.a <= a_max) &
    (0 <= veh___639___.v & veh___639___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_3 := case
   veh___639___.v = 0 : 0;
   veh___639___.v = 1 : 1;
   veh___639___.v = 2 : 4;
   veh___639___.v = 3 : 9;
   veh___639___.v = 4 : 16;
   veh___639___.v = 5 : 25;
   veh___639___.v = 6 : 36;
   veh___639___.v = 7 : 49;
   veh___639___.v = 8 : 64;
   veh___639___.v = 9 : 81;
   veh___639___.v = 10 : 100;
   veh___639___.v = 11 : 121;
   veh___639___.v = 12 : 144;
   veh___639___.v = 13 : 169;
   veh___639___.v = 14 : 196;
   veh___639___.v = 15 : 225;
   veh___639___.v = 16 : 256;
   veh___639___.v = 17 : 289;
   veh___639___.v = 18 : 324;
   veh___639___.v = 19 : 361;
   veh___639___.v = 20 : 400;
   veh___639___.v = 21 : 441;
   veh___639___.v = 22 : 484;
   veh___639___.v = 23 : 529;
   veh___639___.v = 24 : 576;
   veh___639___.v = 25 : 625;
   veh___639___.v = 26 : 676;
   veh___639___.v = 27 : 729;
   veh___639___.v = 28 : 784;
   veh___639___.v = 29 : 841;
   veh___639___.v = 30 : 900;
   veh___639___.v = 31 : 961;
   veh___639___.v = 32 : 1024;
   veh___639___.v = 33 : 1089;
   veh___639___.v = 34 : 1156;
   veh___639___.v = 35 : 1225;
   veh___639___.v = 36 : 1296;
   veh___639___.v = 37 : 1369;
   veh___639___.v = 38 : 1444;
   veh___639___.v = 39 : 1521;
   veh___639___.v = 40 : 1600;
   veh___639___.v = 41 : 1681;
   veh___639___.v = 42 : 1764;
   veh___639___.v = 43 : 1849;
   veh___639___.v = 44 : 1936;
   veh___639___.v = 45 : 2025;
   veh___639___.v = 46 : 2116;
   veh___639___.v = 47 : 2209;
   veh___639___.v = 48 : 2304;
   veh___639___.v = 49 : 2401;
   veh___639___.v = 50 : 2500;
   veh___639___.v = 51 : 2601;
   veh___639___.v = 52 : 2704;
   veh___639___.v = 53 : 2809;
   veh___639___.v = 54 : 2916;
   veh___639___.v = 55 : 3025;
   veh___639___.v = 56 : 3136;
   veh___639___.v = 57 : 3249;
   veh___639___.v = 58 : 3364;
   veh___639___.v = 59 : 3481;
   veh___639___.v = 60 : 3600;
   veh___639___.v = 61 : 3721;
   veh___639___.v = 62 : 3844;
   veh___639___.v = 63 : 3969;
   veh___639___.v = 64 : 4096;
   veh___639___.v = 65 : 4225;
   veh___639___.v = 66 : 4356;
   veh___639___.v = 67 : 4489;
   veh___639___.v = 68 : 4624;
   veh___639___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_3_and_veh_0_on_same_seclet := 
veh___639___.on_straight_section = veh___609___.on_straight_section & veh___639___.traversion_from = veh___609___.traversion_from & veh___639___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_3_and_veh_0_on_same_seclet -> (veh___639___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___639___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_3_and_veh_0_on_same_seclet -> (
       !(veh___639___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___609___.abs_pos >= veh___639___.abs_pos)) &
       !(veh___639___.same_lane_as_veh_0 & (veh___639___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___639___.abs_pos >= veh___609___.abs_pos)));
	
DEFINE veh_3_and_veh_1_on_same_seclet := 
veh___639___.on_straight_section = veh___619___.on_straight_section & veh___639___.traversion_from = veh___619___.traversion_from & veh___639___.traversion_to = veh___619___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_3_and_veh_1_on_same_seclet -> (veh___639___.same_lane_as_veh_1 -> (abs(veh___619___.abs_pos - veh___639___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_3_and_veh_1_on_same_seclet -> (
       !(veh___639___.same_lane_as_veh_1 & (veh___619___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___619___.abs_pos >= veh___639___.abs_pos)) &
       !(veh___639___.same_lane_as_veh_1 & (veh___639___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___639___.abs_pos >= veh___619___.abs_pos)));
	
DEFINE veh_3_and_veh_2_on_same_seclet := 
veh___639___.on_straight_section = veh___629___.on_straight_section & veh___639___.traversion_from = veh___629___.traversion_from & veh___639___.traversion_to = veh___629___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_3_and_veh_2_on_same_seclet -> (veh___639___.same_lane_as_veh_2 -> (abs(veh___629___.abs_pos - veh___639___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_3_and_veh_2_on_same_seclet -> (
       !(veh___639___.same_lane_as_veh_2 & (veh___629___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___629___.abs_pos >= veh___639___.abs_pos)) &
       !(veh___639___.same_lane_as_veh_2 & (veh___639___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___639___.abs_pos >= veh___629___.abs_pos)));
	
-- >>> Car 4 <<<


DEFINE
   veh___649___.rel_pos := veh___649___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___649___.next_abs_pos := veh___649___.abs_pos + next(veh___649___.v);

INVAR
    veh___649___.lane_single | veh___649___.lane_crossing;

INVAR
    (max(-veh___649___.v, a_min) <= veh___649___.a & veh___649___.a <= a_max) &
    (0 <= veh___649___.v & veh___649___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_4 := case
   veh___649___.v = 0 : 0;
   veh___649___.v = 1 : 1;
   veh___649___.v = 2 : 4;
   veh___649___.v = 3 : 9;
   veh___649___.v = 4 : 16;
   veh___649___.v = 5 : 25;
   veh___649___.v = 6 : 36;
   veh___649___.v = 7 : 49;
   veh___649___.v = 8 : 64;
   veh___649___.v = 9 : 81;
   veh___649___.v = 10 : 100;
   veh___649___.v = 11 : 121;
   veh___649___.v = 12 : 144;
   veh___649___.v = 13 : 169;
   veh___649___.v = 14 : 196;
   veh___649___.v = 15 : 225;
   veh___649___.v = 16 : 256;
   veh___649___.v = 17 : 289;
   veh___649___.v = 18 : 324;
   veh___649___.v = 19 : 361;
   veh___649___.v = 20 : 400;
   veh___649___.v = 21 : 441;
   veh___649___.v = 22 : 484;
   veh___649___.v = 23 : 529;
   veh___649___.v = 24 : 576;
   veh___649___.v = 25 : 625;
   veh___649___.v = 26 : 676;
   veh___649___.v = 27 : 729;
   veh___649___.v = 28 : 784;
   veh___649___.v = 29 : 841;
   veh___649___.v = 30 : 900;
   veh___649___.v = 31 : 961;
   veh___649___.v = 32 : 1024;
   veh___649___.v = 33 : 1089;
   veh___649___.v = 34 : 1156;
   veh___649___.v = 35 : 1225;
   veh___649___.v = 36 : 1296;
   veh___649___.v = 37 : 1369;
   veh___649___.v = 38 : 1444;
   veh___649___.v = 39 : 1521;
   veh___649___.v = 40 : 1600;
   veh___649___.v = 41 : 1681;
   veh___649___.v = 42 : 1764;
   veh___649___.v = 43 : 1849;
   veh___649___.v = 44 : 1936;
   veh___649___.v = 45 : 2025;
   veh___649___.v = 46 : 2116;
   veh___649___.v = 47 : 2209;
   veh___649___.v = 48 : 2304;
   veh___649___.v = 49 : 2401;
   veh___649___.v = 50 : 2500;
   veh___649___.v = 51 : 2601;
   veh___649___.v = 52 : 2704;
   veh___649___.v = 53 : 2809;
   veh___649___.v = 54 : 2916;
   veh___649___.v = 55 : 3025;
   veh___649___.v = 56 : 3136;
   veh___649___.v = 57 : 3249;
   veh___649___.v = 58 : 3364;
   veh___649___.v = 59 : 3481;
   veh___649___.v = 60 : 3600;
   veh___649___.v = 61 : 3721;
   veh___649___.v = 62 : 3844;
   veh___649___.v = 63 : 3969;
   veh___649___.v = 64 : 4096;
   veh___649___.v = 65 : 4225;
   veh___649___.v = 66 : 4356;
   veh___649___.v = 67 : 4489;
   veh___649___.v = 68 : 4624;
   veh___649___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

-- DEFINE veh___609___.same_lane_as_veh_1 := veh___619___.same_lane_as_veh_0;
-- DEFINE veh___609___.same_lane_as_veh_2 := veh___629___.same_lane_as_veh_0;
-- DEFINE veh___609___.same_lane_as_veh_3 := veh___639___.same_lane_as_veh_0;
-- DEFINE veh___609___.same_lane_as_veh_4 := veh___649___.same_lane_as_veh_0;
-- DEFINE veh___619___.same_lane_as_veh_2 := veh___629___.same_lane_as_veh_1;
-- DEFINE veh___619___.same_lane_as_veh_3 := veh___639___.same_lane_as_veh_1;
-- DEFINE veh___619___.same_lane_as_veh_4 := veh___649___.same_lane_as_veh_1;
-- DEFINE veh___629___.same_lane_as_veh_3 := veh___639___.same_lane_as_veh_2;
-- DEFINE veh___629___.same_lane_as_veh_4 := veh___649___.same_lane_as_veh_2;
-- DEFINE veh___639___.same_lane_as_veh_4 := veh___649___.same_lane_as_veh_3;

-- INVAR (veh___609___.same_lane_as_veh_1 & veh___609___.abs_pos < veh___619___.abs_pos & veh___619___.abs_pos - veh___609___.abs_pos < 10) -> (veh___609___.v < veh___619___.v + 5);
-- INVAR (veh___609___.same_lane_as_veh_2 & veh___609___.abs_pos < veh___629___.abs_pos & veh___629___.abs_pos - veh___609___.abs_pos < 10) -> (veh___609___.v < veh___629___.v + 5);
-- INVAR (veh___609___.same_lane_as_veh_3 & veh___609___.abs_pos < veh___639___.abs_pos & veh___639___.abs_pos - veh___609___.abs_pos < 10) -> (veh___609___.v < veh___639___.v + 5);
-- INVAR (veh___609___.same_lane_as_veh_4 & veh___609___.abs_pos < veh___649___.abs_pos & veh___649___.abs_pos - veh___609___.abs_pos < 10) -> (veh___609___.v < veh___649___.v + 5);

-- INVAR (veh___619___.same_lane_as_veh_0 & veh___619___.abs_pos < veh___609___.abs_pos & veh___609___.abs_pos - veh___619___.abs_pos < 10) -> (veh___619___.v < veh___609___.v + 5);
-- INVAR (veh___619___.same_lane_as_veh_2 & veh___619___.abs_pos < veh___629___.abs_pos & veh___629___.abs_pos - veh___619___.abs_pos < 10) -> (veh___619___.v < veh___629___.v + 5);
-- INVAR (veh___619___.same_lane_as_veh_3 & veh___619___.abs_pos < veh___639___.abs_pos & veh___639___.abs_pos - veh___619___.abs_pos < 10) -> (veh___619___.v < veh___639___.v + 5);
-- INVAR (veh___619___.same_lane_as_veh_4 & veh___619___.abs_pos < veh___649___.abs_pos & veh___649___.abs_pos - veh___619___.abs_pos < 10) -> (veh___619___.v < veh___649___.v + 5);

-- INVAR (veh___629___.same_lane_as_veh_0 & veh___629___.abs_pos < veh___609___.abs_pos & veh___609___.abs_pos - veh___629___.abs_pos < 10) -> (veh___629___.v < veh___609___.v + 5);
-- INVAR (veh___629___.same_lane_as_veh_1 & veh___629___.abs_pos < veh___619___.abs_pos & veh___619___.abs_pos - veh___629___.abs_pos < 10) -> (veh___629___.v < veh___619___.v + 5);
-- INVAR (veh___629___.same_lane_as_veh_3 & veh___629___.abs_pos < veh___639___.abs_pos & veh___639___.abs_pos - veh___629___.abs_pos < 10) -> (veh___629___.v < veh___639___.v + 5);
-- INVAR (veh___629___.same_lane_as_veh_4 & veh___629___.abs_pos < veh___649___.abs_pos & veh___649___.abs_pos - veh___629___.abs_pos < 10) -> (veh___629___.v < veh___649___.v + 5);

-- INVAR (veh___639___.same_lane_as_veh_0 & veh___639___.abs_pos < veh___609___.abs_pos & veh___609___.abs_pos - veh___639___.abs_pos < 10) -> (veh___639___.v < veh___609___.v + 5);
-- INVAR (veh___639___.same_lane_as_veh_1 & veh___639___.abs_pos < veh___619___.abs_pos & veh___619___.abs_pos - veh___639___.abs_pos < 10) -> (veh___639___.v < veh___619___.v + 5);
-- INVAR (veh___639___.same_lane_as_veh_2 & veh___639___.abs_pos < veh___629___.abs_pos & veh___629___.abs_pos - veh___639___.abs_pos < 10) -> (veh___639___.v < veh___629___.v + 5);
-- INVAR (veh___639___.same_lane_as_veh_4 & veh___639___.abs_pos < veh___649___.abs_pos & veh___649___.abs_pos - veh___639___.abs_pos < 10) -> (veh___639___.v < veh___649___.v + 5);

-- INVAR (veh___649___.same_lane_as_veh_0 & veh___649___.abs_pos < veh___609___.abs_pos & veh___609___.abs_pos - veh___649___.abs_pos < 10) -> (veh___649___.v < veh___609___.v + 5);
-- INVAR (veh___649___.same_lane_as_veh_1 & veh___649___.abs_pos < veh___619___.abs_pos & veh___619___.abs_pos - veh___649___.abs_pos < 10) -> (veh___649___.v < veh___619___.v + 5);
-- INVAR (veh___649___.same_lane_as_veh_2 & veh___649___.abs_pos < veh___629___.abs_pos & veh___629___.abs_pos - veh___649___.abs_pos < 10) -> (veh___649___.v < veh___629___.v + 5);
-- INVAR (veh___649___.same_lane_as_veh_3 & veh___649___.abs_pos < veh___639___.abs_pos & veh___639___.abs_pos - veh___649___.abs_pos < 10) -> (veh___649___.v < veh___639___.v + 5);

DEFINE veh_4_and_veh_0_on_same_seclet := 
veh___649___.on_straight_section = veh___609___.on_straight_section & veh___649___.traversion_from = veh___609___.traversion_from & veh___649___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_0_on_same_seclet -> (veh___649___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_0_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___609___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_0 & (veh___649___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___649___.abs_pos >= veh___609___.abs_pos)));
	
DEFINE veh_4_and_veh_1_on_same_seclet := 
veh___649___.on_straight_section = veh___619___.on_straight_section & veh___649___.traversion_from = veh___619___.traversion_from & veh___649___.traversion_to = veh___619___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_1_on_same_seclet -> (veh___649___.same_lane_as_veh_1 -> (abs(veh___619___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_1_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_1 & (veh___619___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___619___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_1 & (veh___649___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___649___.abs_pos >= veh___619___.abs_pos)));
	
DEFINE veh_4_and_veh_2_on_same_seclet := 
veh___649___.on_straight_section = veh___629___.on_straight_section & veh___649___.traversion_from = veh___629___.traversion_from & veh___649___.traversion_to = veh___629___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_2_on_same_seclet -> (veh___649___.same_lane_as_veh_2 -> (abs(veh___629___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_2_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_2 & (veh___629___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___629___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_2 & (veh___649___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___649___.abs_pos >= veh___629___.abs_pos)));
	
DEFINE veh_4_and_veh_3_on_same_seclet := 
veh___649___.on_straight_section = veh___639___.on_straight_section & veh___649___.traversion_from = veh___639___.traversion_from & veh___649___.traversion_to = veh___639___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_3_on_same_seclet -> (veh___649___.same_lane_as_veh_3 -> (abs(veh___639___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_3_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_3 & (veh___639___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___639___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_3 & (veh___649___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___649___.abs_pos >= veh___639___.abs_pos)));
	




-- >>> Car 0 <<<
ASSIGN

    init(veh___609___.time_since_last_lc) := 0;


    init(veh___609___.prev_rel_pos) := 0;
    init(veh___609___.prev_abs_pos) := 0;
    -- init(veh___609___.v) := 35;
    


   next(veh___609___.time_since_last_lc) := case
      veh___609___.time_since_last_lc < min_time_between_lcs : veh___609___.time_since_last_lc + 1;
      TRUE : 0;
   esac;



    -- update position (directly feed-through new velocity)
    next(veh___609___.prev_rel_pos) := veh___609___.rel_pos;
    next(veh___609___.prev_abs_pos) := veh___609___.abs_pos;


    next(veh___609___.abs_pos) := case
       veh___609___.is_on_sec_0 = 1 & veh___609___.next_abs_pos > section_0_end : veh___609___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___609___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___609___.v) := min(max(veh___609___.v + veh___609___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___609___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___609___.is_on_sec_0 = 1 & veh___609___.next_abs_pos > section_0_end : 0;
             TRUE : veh___609___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
    -- TODO: There is quite some double code between the "{0, 1}" cases. It might be more efficient to merge them into a single case.
       
             
       

    
          
       
    
-- >>> Car 1 <<<
ASSIGN

    init(veh___619___.time_since_last_lc) := 0;


    init(veh___619___.prev_rel_pos) := 0;
    init(veh___619___.prev_abs_pos) := 0;
    -- init(veh___619___.v) := 35;
    


   next(veh___619___.time_since_last_lc) := case
      veh___619___.time_since_last_lc < min_time_between_lcs : veh___619___.time_since_last_lc + 1;
      TRUE : 0;
   esac;



    -- update position (directly feed-through new velocity)
    next(veh___619___.prev_rel_pos) := veh___619___.rel_pos;
    next(veh___619___.prev_abs_pos) := veh___619___.abs_pos;


    next(veh___619___.abs_pos) := case
       veh___619___.is_on_sec_0 = 1 & veh___619___.next_abs_pos > section_0_end : veh___619___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___619___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___619___.v) := min(max(veh___619___.v + veh___619___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___619___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___619___.is_on_sec_0 = 1 & veh___619___.next_abs_pos > section_0_end : 0;
             TRUE : veh___619___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
    -- TODO: There is quite some double code between the "{0, 1}" cases. It might be more efficient to merge them into a single case.
       
             
       

    
          
       
    
-- >>> Car 2 <<<
ASSIGN

    init(veh___629___.time_since_last_lc) := 0;


    init(veh___629___.prev_rel_pos) := 0;
    init(veh___629___.prev_abs_pos) := 0;
    -- init(veh___629___.v) := 35;
    


   next(veh___629___.time_since_last_lc) := case
      veh___629___.time_since_last_lc < min_time_between_lcs : veh___629___.time_since_last_lc + 1;
      TRUE : 0;
   esac;



    -- update position (directly feed-through new velocity)
    next(veh___629___.prev_rel_pos) := veh___629___.rel_pos;
    next(veh___629___.prev_abs_pos) := veh___629___.abs_pos;


    next(veh___629___.abs_pos) := case
       veh___629___.is_on_sec_0 = 1 & veh___629___.next_abs_pos > section_0_end : veh___629___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___629___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___629___.v) := min(max(veh___629___.v + veh___629___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___629___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___629___.is_on_sec_0 = 1 & veh___629___.next_abs_pos > section_0_end : 0;
             TRUE : veh___629___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
    -- TODO: There is quite some double code between the "{0, 1}" cases. It might be more efficient to merge them into a single case.
       
             
       

    
          
       
    
-- >>> Car 3 <<<
ASSIGN

    init(veh___639___.time_since_last_lc) := 0;


    init(veh___639___.prev_rel_pos) := 0;
    init(veh___639___.prev_abs_pos) := 0;
    -- init(veh___639___.v) := 35;
    


   next(veh___639___.time_since_last_lc) := case
      veh___639___.time_since_last_lc < min_time_between_lcs : veh___639___.time_since_last_lc + 1;
      TRUE : 0;
   esac;



    -- update position (directly feed-through new velocity)
    next(veh___639___.prev_rel_pos) := veh___639___.rel_pos;
    next(veh___639___.prev_abs_pos) := veh___639___.abs_pos;


    next(veh___639___.abs_pos) := case
       veh___639___.is_on_sec_0 = 1 & veh___639___.next_abs_pos > section_0_end : veh___639___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___639___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___639___.v) := min(max(veh___639___.v + veh___639___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___639___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___639___.is_on_sec_0 = 1 & veh___639___.next_abs_pos > section_0_end : 0;
             TRUE : veh___639___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
    -- TODO: There is quite some double code between the "{0, 1}" cases. It might be more efficient to merge them into a single case.
       
             
       

    
          
       
    
-- >>> Car 4 <<<
ASSIGN

    init(veh___649___.time_since_last_lc) := 0;


    init(veh___649___.prev_rel_pos) := 0;
    init(veh___649___.prev_abs_pos) := 0;
    -- init(veh___649___.v) := 35;
    


   next(veh___649___.time_since_last_lc) := case
      veh___649___.time_since_last_lc < min_time_between_lcs : veh___649___.time_since_last_lc + 1;
      TRUE : 0;
   esac;



    -- update position (directly feed-through new velocity)
    next(veh___649___.prev_rel_pos) := veh___649___.rel_pos;
    next(veh___649___.prev_abs_pos) := veh___649___.abs_pos;


    next(veh___649___.abs_pos) := case
       veh___649___.is_on_sec_0 = 1 & veh___649___.next_abs_pos > section_0_end : veh___649___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___649___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___649___.v) := min(max(veh___649___.v + veh___649___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___649___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___649___.is_on_sec_0 = 1 & veh___649___.next_abs_pos > section_0_end : 0;
             TRUE : veh___649___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
    -- TODO: There is quite some double code between the "{0, 1}" cases. It might be more efficient to merge them into a single case.
       
             
       

    
          
       
    


-- >>> Car 0 <<<




-- >>> Car 1 <<<




-- >>> Car 2 <<<




-- >>> Car 3 <<<




-- >>> Car 4 <<<






--------------------------------------------------------
-- End: Non-ego Spec 
--------------------------------------------------------



---------------------------------------------------------------------
-- Here comes logic which is independent of EGO-less or EGO-full mode
---------------------------------------------------------------------
-- TODO: The ego not driving on the green stuff should be probably here, as well, once the section logic is there.
-- TODO: The ego lane logic (without lane change) should be probably here, as well.

VAR
   -- "cond" variables are in ego-less mode only there to mock the interface towards the BP
   ego.flCond_full : boolean; -- conditions for lane change to fast lane (lc allowed and desired)
   ego.slCond_full : boolean; -- conditions for lane change to slow lane (lc allowed and desired)
   ego.abCond_full : boolean; -- conditions for abort of lane change 
   -- EO "cond" variables are in ego-less mode only there to mock the interface towards the BP

   ego.abs_pos : integer;

FROZENVAR
   ego.v : 0 .. 0; -- ego.max_vel;

ASSIGN
   next(ego.abs_pos) := next(veh___609___.abs_pos);


---------------------------------------------------------------------
-- EO logic which is independent of EGO-less or EGO-full mode
---------------------------------------------------------------------
