
MODULE EnvModel


-- TIMESCALING((((1.000000))))GNILACSEMIT
-- DISTANCESCALING((((1.000000))))GNILACSECNATSID
-- SCALING DESCRIPTIONS
--no,time
-- EO SCALING DESCRIPTIONS


DEFINE
    leave_src_lane_earliest_after := 1;             -- earliest point in time where the vehicle may cross the lane border, i.e., after this transition the vehicle occupies two lanes 
    leave_src_lane_latest_after := 5;
    complete_lane_change_earliest_after := 1;       -- earliest point in time where the vehicle is entirely on its target lane, i.e., after this transition the vehicle only occupies one lane
    complete_lane_change_latest_after := 7;
    abort_lane_change_complete_earliest_after := 1; -- earliest point in time where the vehicle is entirely back on its source lane after a lane change abort
    abort_lane_change_complete_latest_after := 3;
    min_time_between_lcs := 1;                      -- after finisihing one lc, how much time needs to pass before the next one may be started

---------------- End of lc parameterization -----------------

    a_min := -8;
    a_max := 6;
    min_dist_long := -1;                            -- the minimum distance kept by other vehicle to preceding ego, we use -1 meaning one meter behind
    veh_length := 5;                                -- we assume a vehicle length of 5m for distance calculation to the front
    max_vel := 70;

    params.turn_signal_duration := 2; -- turn signals will be on for this amount of time -- TODO: Connection via vfm-aka not working, has to be investigated.
    -- total lc duration shall be 5 s according to code documentation
    -- src lane is left 1s or 2s after end of turn signal duration, tgt lane is reached after 5s
    ego.leave_src_lane_earliest_after := 1 + params.turn_signal_duration;  -- 1 s after end of turn signal duration
    ego.leave_src_lane_latest_after := 2 + params.turn_signal_duration;    -- 2 s after end of turn signal duration
    ego.complete_lane_change_earliest_after := 2 + params.turn_signal_duration;
    ego.complete_lane_change_latest_after := 2 + params.turn_signal_duration;
    -- it seems that there is no parameter given for the duration of the abort, assume same duration to roll back that it took to get to the current pos
    ego.min_time_between_lcs := 2;                      -- after finisihing one lc, how much time needs to pass before the next one may be started

    max_ego_visibility_range := 250;                      --how far can the ego sensors see? Vehicles being further away than this cannot be detected and will not be considered

    empty_gap_indicator := -1; --Counterpart to i_FREE_LANE in Viper, could be AKA-d but for now should be fine to have twice.
--------------------------------------------------------
-- End: Constants and common definitions
--------------------------------------------------------


--------------------------------------------------------
--
-- Begin: Non-ego Spec (generate once per non-ego Vehicle)
--
--------------------------------------------------------

VAR
   cnt : integer;
   num_lanes : integer;

   segment_0_pos_begin : integer;
   segment_0_min_lane : integer;
   segment_0_max_lane : integer;
   segment_1_pos_begin : integer;
   segment_1_min_lane : integer;
   segment_1_max_lane : integer;
   
   ego.a : 0..0;
   ego.v : 0..0;

	-- >>> Car 0 <<<
    veh___609___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___609___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___609___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___609___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___609___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___609___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___609___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___609___.rel_pos : integer; -- relative position to ego in m, rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
    veh___609___.prev_rel_pos : integer;
    veh___609___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___609___.v : integer;

    veh___609___.lane_b0 : boolean;
    veh___609___.lane_b1 : boolean;
    veh___609___.lane_b2 : boolean;
    veh___609___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___609___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile
	
	-- >>> Car 1 <<<
    veh___619___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___619___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___619___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___619___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___619___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___619___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___619___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___619___.rel_pos : integer; -- relative position to ego in m, rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
    veh___619___.prev_rel_pos : integer;
    veh___619___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___619___.v : integer;

    veh___619___.lane_b0 : boolean;
    veh___619___.lane_b1 : boolean;
    veh___619___.lane_b2 : boolean;
    veh___619___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___619___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile
	
	-- >>> Car 2 <<<
    veh___629___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___629___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___629___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___629___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___629___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___629___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___629___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___629___.rel_pos : integer; -- relative position to ego in m, rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
    veh___629___.prev_rel_pos : integer;
    veh___629___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___629___.v : integer;

    veh___629___.lane_b0 : boolean;
    veh___629___.lane_b1 : boolean;
    veh___629___.lane_b2 : boolean;
    veh___629___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___629___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile
	
	-- >>> Car 3 <<<
    veh___639___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___639___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___639___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___639___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___639___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___639___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___639___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___639___.rel_pos : integer; -- relative position to ego in m, rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
    veh___639___.prev_rel_pos : integer;
    veh___639___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___639___.v : integer;

    veh___639___.lane_b0 : boolean;
    veh___639___.lane_b1 : boolean;
    veh___639___.lane_b2 : boolean;
    veh___639___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___639___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile
	
	-- >>> Car 4 <<<
    veh___649___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___649___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___649___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___649___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___649___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___649___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___649___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___649___.rel_pos : integer; -- relative position to ego in m, rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
    veh___649___.prev_rel_pos : integer;
    veh___649___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___649___.v : integer;

    veh___649___.lane_b0 : boolean;
    veh___649___.lane_b1 : boolean;
    veh___649___.lane_b2 : boolean;
    veh___649___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___649___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile
	
	

    tar_dir : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};

   section___609___.source.x : integer;
      section___609___.source.y : integer;
      section___609___.drain.x : integer;
      section___609___.drain.y : integer;
   section___619___.source.x : integer;
      section___619___.source.y : integer;
      section___619___.drain.x : integer;
      section___619___.drain.y : integer;
   section___629___.source.x : integer;
      section___629___.source.y : integer;
      section___629___.drain.x : integer;
      section___629___.drain.y : integer;
   section___639___.source.x : integer;
      section___639___.source.y : integer;
      section___639___.drain.x : integer;
      section___639___.drain.y : integer;
   section___649___.source.x : integer;
      section___649___.source.y : integer;
      section___649___.drain.x : integer;
      section___649___.drain.y : integer;
   

ASSIGN
   next(section___609___.source.x) := section___609___.source.x;
      next(section___609___.source.y) := section___609___.source.y;
      next(section___609___.drain.x) := section___609___.drain.x;
      next(section___609___.drain.y) := section___609___.drain.y;
   next(section___619___.source.x) := section___619___.source.x;
      next(section___619___.source.y) := section___619___.source.y;
      next(section___619___.drain.x) := section___619___.drain.x;
      next(section___619___.drain.y) := section___619___.drain.y;
   next(section___629___.source.x) := section___629___.source.x;
      next(section___629___.source.y) := section___629___.source.y;
      next(section___629___.drain.x) := section___629___.drain.x;
      next(section___629___.drain.y) := section___629___.drain.y;
   next(section___639___.source.x) := section___639___.source.x;
      next(section___639___.source.y) := section___639___.source.y;
      next(section___639___.drain.x) := section___639___.drain.x;
      next(section___639___.drain.y) := section___639___.drain.y;
   next(section___649___.source.x) := section___649___.source.x;
      next(section___649___.source.y) := section___649___.source.y;
      next(section___649___.drain.x) := section___649___.drain.x;
      next(section___649___.drain.y) := section___649___.drain.y;
   


   next(segment_0_pos_begin) := segment_0_pos_begin;
   next(segment_0_min_lane) := segment_0_min_lane;
   next(segment_0_max_lane) := segment_0_max_lane;
   next(segment_1_pos_begin) := segment_1_pos_begin;
   next(segment_1_min_lane) := segment_1_min_lane;
   next(segment_1_max_lane) := segment_1_max_lane;
   

   INIT section___609___.source.x = 0;
   INIT section___609___.source.y = 0;
   -- INIT section___609___.drain.x ==> Not specified, so the length of the section is figured out from the length of the segments.
   INIT section___609___.drain.y = 0;

   INIT section___619___.source.x <= 1000  & section___619___.source.x >= -1000;
      INIT section___619___.source.y <= 1000 & section___619___.source.y >= -1000;
      INIT section___619___.drain.x  <= 1000  & section___619___.drain.x >= -1000;
      INIT section___619___.drain.y  <= 1000 & section___619___.drain.y >= -1000;
   INIT section___629___.source.x <= 1000  & section___629___.source.x >= -1000;
      INIT section___629___.source.y <= 1000 & section___629___.source.y >= -1000;
      INIT section___629___.drain.x  <= 1000  & section___629___.drain.x >= -1000;
      INIT section___629___.drain.y  <= 1000 & section___629___.drain.y >= -1000;
   INIT section___639___.source.x <= 1000  & section___639___.source.x >= -1000;
      INIT section___639___.source.y <= 1000 & section___639___.source.y >= -1000;
      INIT section___639___.drain.x  <= 1000  & section___639___.drain.x >= -1000;
      INIT section___639___.drain.y  <= 1000 & section___639___.drain.y >= -1000;
   INIT section___649___.source.x <= 1000  & section___649___.source.x >= -1000;
      INIT section___649___.source.y <= 1000 & section___649___.source.y >= -1000;
      INIT section___649___.drain.x  <= 1000  & section___649___.drain.x >= -1000;
      INIT section___649___.drain.y  <= 1000 & section___649___.drain.y >= -1000;
   

INVAR tar_dir = ActionDir____LEFT;
INIT cnt = 0;

INIT 0 = segment_0_pos_begin;
INIT segment_1_pos_begin < 200;
INIT segment_0_pos_begin + 30 < segment_1_pos_begin;
INIT abs(segment_0_min_lane - segment_1_min_lane) <= 1;
INIT abs(segment_0_max_lane - segment_1_max_lane) <= 1;


INIT segment_0_max_lane >= segment_0_min_lane;
INIT segment_0_min_lane >= 0;
INIT segment_0_max_lane <= 3;
INIT segment_1_max_lane >= segment_1_min_lane;
INIT segment_1_min_lane >= 0;
INIT segment_1_max_lane <= 3;


INIT segment_0_min_lane = 0 & segment_0_max_lane = 3; -- Make sure we always have a drivable lane at the start. TODO: Make flexible.

TRANS next(cnt) = cnt + 1;

DEFINE
ego.abs_pos := 0;

large_number := 10000;

   segment_2_pos_begin := segment_1_pos_begin + large_number; -- Helper variable to make below loop simpler.

   lane_0_availability_from_segment_2 := 0;          -- Helper variable to make below loop simpler.
   
   lane_0_availability_from_segment_0 := case
      segment_0_min_lane <= 0 & segment_0_max_lane >= 0 : lane_0_availability_from_segment_1 + segment_1_pos_begin - segment_0_pos_begin;
      TRUE: 0;
   esac;
   lane_0_availability_from_segment_1 := case
      segment_1_min_lane <= 0 & segment_1_max_lane >= 0 : lane_0_availability_from_segment_2 + segment_2_pos_begin - segment_1_pos_begin;
      TRUE: 0;
   esac;
   

   ego.lane_0_availability := case
      ego.abs_pos >= segment_1_pos_begin : lane_0_availability_from_segment_1 + segment_1_pos_begin - ego.abs_pos;
      ego.abs_pos >= segment_0_pos_begin : lane_0_availability_from_segment_0 + segment_0_pos_begin - ego.abs_pos;
      TRUE: 0;
   esac;
   lane_1_availability_from_segment_2 := 0;          -- Helper variable to make below loop simpler.
   
   lane_1_availability_from_segment_0 := case
      segment_0_min_lane <= 1 & segment_0_max_lane >= 1 : lane_1_availability_from_segment_1 + segment_1_pos_begin - segment_0_pos_begin;
      TRUE: 0;
   esac;
   lane_1_availability_from_segment_1 := case
      segment_1_min_lane <= 1 & segment_1_max_lane >= 1 : lane_1_availability_from_segment_2 + segment_2_pos_begin - segment_1_pos_begin;
      TRUE: 0;
   esac;
   

   ego.lane_1_availability := case
      ego.abs_pos >= segment_1_pos_begin : lane_1_availability_from_segment_1 + segment_1_pos_begin - ego.abs_pos;
      ego.abs_pos >= segment_0_pos_begin : lane_1_availability_from_segment_0 + segment_0_pos_begin - ego.abs_pos;
      TRUE: 0;
   esac;
   lane_2_availability_from_segment_2 := 0;          -- Helper variable to make below loop simpler.
   
   lane_2_availability_from_segment_0 := case
      segment_0_min_lane <= 2 & segment_0_max_lane >= 2 : lane_2_availability_from_segment_1 + segment_1_pos_begin - segment_0_pos_begin;
      TRUE: 0;
   esac;
   lane_2_availability_from_segment_1 := case
      segment_1_min_lane <= 2 & segment_1_max_lane >= 2 : lane_2_availability_from_segment_2 + segment_2_pos_begin - segment_1_pos_begin;
      TRUE: 0;
   esac;
   

   ego.lane_2_availability := case
      ego.abs_pos >= segment_1_pos_begin : lane_2_availability_from_segment_1 + segment_1_pos_begin - ego.abs_pos;
      ego.abs_pos >= segment_0_pos_begin : lane_2_availability_from_segment_0 + segment_0_pos_begin - ego.abs_pos;
      TRUE: 0;
   esac;
   lane_3_availability_from_segment_2 := 0;          -- Helper variable to make below loop simpler.
   
   lane_3_availability_from_segment_0 := case
      segment_0_min_lane <= 3 & segment_0_max_lane >= 3 : lane_3_availability_from_segment_1 + segment_1_pos_begin - segment_0_pos_begin;
      TRUE: 0;
   esac;
   lane_3_availability_from_segment_1 := case
      segment_1_min_lane <= 3 & segment_1_max_lane >= 3 : lane_3_availability_from_segment_2 + segment_2_pos_begin - segment_1_pos_begin;
      TRUE: 0;
   esac;
   

   ego.lane_3_availability := case
      ego.abs_pos >= segment_1_pos_begin : lane_3_availability_from_segment_1 + segment_1_pos_begin - ego.abs_pos;
      ego.abs_pos >= segment_0_pos_begin : lane_3_availability_from_segment_0 + segment_0_pos_begin - ego.abs_pos;
      TRUE: 0;
   esac;
   
 
veh___609___.abs_pos := veh___609___.rel_pos + ego.abs_pos;
veh___619___.abs_pos := veh___619___.rel_pos + ego.abs_pos;
veh___629___.abs_pos := veh___629___.rel_pos + ego.abs_pos;
veh___639___.abs_pos := veh___639___.rel_pos + ego.abs_pos;
veh___649___.abs_pos := veh___649___.rel_pos + ego.abs_pos;


DEFINE

-- Make sure non-egos do not drive on the GREEN.
veh___609___.on_lane_min := case
   veh___609___.lane_b0 : 0;
   veh___609___.lane_b1 : 1;
   veh___609___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___619___.on_lane_min := case
   veh___619___.lane_b0 : 0;
   veh___619___.lane_b1 : 1;
   veh___619___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___629___.on_lane_min := case
   veh___629___.lane_b0 : 0;
   veh___629___.lane_b1 : 1;
   veh___629___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___639___.on_lane_min := case
   veh___639___.lane_b0 : 0;
   veh___639___.lane_b1 : 1;
   veh___639___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___649___.on_lane_min := case
   veh___649___.lane_b0 : 0;
   veh___649___.lane_b1 : 1;
   veh___649___.lane_b2 : 2;
   TRUE : 3;
esac;


veh___609___.on_lane_max := case
   veh___609___.lane_b3 : 3;
   veh___609___.lane_b2 : 2;
   veh___609___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___619___.on_lane_max := case
   veh___619___.lane_b3 : 3;
   veh___619___.lane_b2 : 2;
   veh___619___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___629___.on_lane_max := case
   veh___629___.lane_b3 : 3;
   veh___629___.lane_b2 : 2;
   veh___629___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___639___.on_lane_max := case
   veh___639___.lane_b3 : 3;
   veh___639___.lane_b2 : 2;
   veh___639___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___649___.on_lane_max := case
   veh___649___.lane_b3 : 3;
   veh___649___.lane_b2 : 2;
   veh___649___.lane_b1 : 1;
   TRUE : 0;
esac;







INVAR (veh___609___.abs_pos < segment_0_pos_begin) -> 
(veh___609___.on_lane_min >= segment_0_min_lane & veh___609___.on_lane_max <= segment_0_max_lane);

INVAR (veh___609___.abs_pos >= segment_0_pos_begin & veh___609___.abs_pos < segment_1_pos_begin) -> 
(veh___609___.on_lane_min >= segment_0_min_lane & veh___609___.on_lane_max <= segment_0_max_lane);

INVAR (veh___609___.abs_pos >= segment_1_pos_begin) -> 
(veh___609___.on_lane_min >= segment_1_min_lane & veh___609___.on_lane_max <= segment_1_max_lane);

INVAR (veh___619___.abs_pos < segment_0_pos_begin) -> 
(veh___619___.on_lane_min >= segment_0_min_lane & veh___619___.on_lane_max <= segment_0_max_lane);

INVAR (veh___619___.abs_pos >= segment_0_pos_begin & veh___619___.abs_pos < segment_1_pos_begin) -> 
(veh___619___.on_lane_min >= segment_0_min_lane & veh___619___.on_lane_max <= segment_0_max_lane);

INVAR (veh___619___.abs_pos >= segment_1_pos_begin) -> 
(veh___619___.on_lane_min >= segment_1_min_lane & veh___619___.on_lane_max <= segment_1_max_lane);

INVAR (veh___629___.abs_pos < segment_0_pos_begin) -> 
(veh___629___.on_lane_min >= segment_0_min_lane & veh___629___.on_lane_max <= segment_0_max_lane);

INVAR (veh___629___.abs_pos >= segment_0_pos_begin & veh___629___.abs_pos < segment_1_pos_begin) -> 
(veh___629___.on_lane_min >= segment_0_min_lane & veh___629___.on_lane_max <= segment_0_max_lane);

INVAR (veh___629___.abs_pos >= segment_1_pos_begin) -> 
(veh___629___.on_lane_min >= segment_1_min_lane & veh___629___.on_lane_max <= segment_1_max_lane);

INVAR (veh___639___.abs_pos < segment_0_pos_begin) -> 
(veh___639___.on_lane_min >= segment_0_min_lane & veh___639___.on_lane_max <= segment_0_max_lane);

INVAR (veh___639___.abs_pos >= segment_0_pos_begin & veh___639___.abs_pos < segment_1_pos_begin) -> 
(veh___639___.on_lane_min >= segment_0_min_lane & veh___639___.on_lane_max <= segment_0_max_lane);

INVAR (veh___639___.abs_pos >= segment_1_pos_begin) -> 
(veh___639___.on_lane_min >= segment_1_min_lane & veh___639___.on_lane_max <= segment_1_max_lane);

INVAR (veh___649___.abs_pos < segment_0_pos_begin) -> 
(veh___649___.on_lane_min >= segment_0_min_lane & veh___649___.on_lane_max <= segment_0_max_lane);

INVAR (veh___649___.abs_pos >= segment_0_pos_begin & veh___649___.abs_pos < segment_1_pos_begin) -> 
(veh___649___.on_lane_min >= segment_0_min_lane & veh___649___.on_lane_max <= segment_0_max_lane);

INVAR (veh___649___.abs_pos >= segment_1_pos_begin) -> 
(veh___649___.on_lane_min >= segment_1_min_lane & veh___649___.on_lane_max <= segment_1_max_lane);



DEFINE
-- Schematic for ego.right_of_veh_*_lane
--..   ????  ####                     ..--
--..   ????  ####                     ..--
--..   ????  ####         ..          ..--
--..   ????  ####         ..          ..--
--..   ????  ####         ..          ..--
--..   ????  ####         ..          ..--
--..   ????  ####         ..          ..--
--..   ????  ####         ..          ..--
--..          ..          ..          ..--
--..          ..          ..          ..--
--..          ..                      ..--
--..          ..                      ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..   ****  ****  ####   ..          ..--
--..                                  ..--
--..                                  ..--
--..          ..          ..          ..--
--..          ..          ..          ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..         ****  ****  ####         ..--
--..          ..          ..          ..--
--..          ..          ..          ..--
--..          ..          ..          ..--
--..          ..          ..          ..--
--..               ****  ****  ####   ..--
--..               ****  ****  ####   ..--
--..          ..   ****  ****  ####   ..--
--..          ..   ****  ****  ####   ..--
--..          ..   ****  ****  ####   ..--
--..          ..   ****  ****  ####   ..--
--..          ..   ****  ****  ####   ..--
--..          ..   ****  ****  ####   ..--


	-- >>> Car 0 <<<
    veh___609___.lane_0 := veh___609___.lane_b0 & !veh___609___.lane_b1& !veh___609___.lane_b2& !veh___609___.lane_b3;
    veh___609___.lane_01 := veh___609___.lane_b0 &veh___609___.lane_b1 &!veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_1 := !veh___609___.lane_b0 &veh___609___.lane_b1 &!veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_12 := !veh___609___.lane_b0 &veh___609___.lane_b1 &veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_2 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_23 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &veh___609___.lane_b2 &veh___609___.lane_b3 ;
    veh___609___.lane_3 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &!veh___609___.lane_b2 &veh___609___.lane_b3 ;
    

    veh___609___.lane_min := veh___609___.lane_0;
    veh___609___.lane_max := veh___609___.lane_3;
    veh___609___.lane_single := veh___609___.lane_0 |veh___609___.lane_1 |veh___609___.lane_2 |veh___609___.lane_3 ;
    veh___609___.lane_crossing := veh___609___.lane_01|veh___609___.lane_12|veh___609___.lane_23;
    veh___609___.lane_unchanged := veh___609___.lane_b0 = next(veh___609___.lane_b0)&veh___609___.lane_b1 = next(veh___609___.lane_b1)&veh___609___.lane_b2 = next(veh___609___.lane_b2)&veh___609___.lane_b3 = next(veh___609___.lane_b3);
    veh___609___.lane_move_down := 
                      (veh___609___.lane_0 -> next(veh___609___.lane_0))
                      & (veh___609___.lane_01 -> next(veh___609___.lane_0))
                      & (veh___609___.lane_1 -> next(veh___609___.lane_01))
                      & (veh___609___.lane_12 -> next(veh___609___.lane_1))
                      & (veh___609___.lane_2 -> next(veh___609___.lane_12))
                      & (veh___609___.lane_23 -> next(veh___609___.lane_2))
                      & (veh___609___.lane_3 -> next(veh___609___.lane_23))
                      ;
    veh___609___.lane_move_up :=
                      (veh___609___.lane_3 -> next(veh___609___.lane_3))
                      & (veh___609___.lane_01 -> next(veh___609___.lane_1))
                      & (veh___609___.lane_0 -> next(veh___609___.lane_01))
                      & (veh___609___.lane_12 -> next(veh___609___.lane_2))
                      & (veh___609___.lane_1 -> next(veh___609___.lane_12))
                      & (veh___609___.lane_23 -> next(veh___609___.lane_3))
                      & (veh___609___.lane_2 -> next(veh___609___.lane_23))
                      ;

    -- "Soft" counts half a lane as neighboring, too. (Obsolete "regular" mode which counted only exactly one lane distance has been removed.)
    -- TODO: Case missing where ego is between far left/right lane and the one next to it, and the other car is on the resp. extreme lane.

	
   
   
	
	
	-- >>> Car 1 <<<
    veh___619___.lane_0 := veh___619___.lane_b0 & !veh___619___.lane_b1& !veh___619___.lane_b2& !veh___619___.lane_b3;
    veh___619___.lane_01 := veh___619___.lane_b0 &veh___619___.lane_b1 &!veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_1 := !veh___619___.lane_b0 &veh___619___.lane_b1 &!veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_12 := !veh___619___.lane_b0 &veh___619___.lane_b1 &veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_2 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_23 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &veh___619___.lane_b2 &veh___619___.lane_b3 ;
    veh___619___.lane_3 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &!veh___619___.lane_b2 &veh___619___.lane_b3 ;
    

    veh___619___.lane_min := veh___619___.lane_0;
    veh___619___.lane_max := veh___619___.lane_3;
    veh___619___.lane_single := veh___619___.lane_0 |veh___619___.lane_1 |veh___619___.lane_2 |veh___619___.lane_3 ;
    veh___619___.lane_crossing := veh___619___.lane_01|veh___619___.lane_12|veh___619___.lane_23;
    veh___619___.lane_unchanged := veh___619___.lane_b0 = next(veh___619___.lane_b0)&veh___619___.lane_b1 = next(veh___619___.lane_b1)&veh___619___.lane_b2 = next(veh___619___.lane_b2)&veh___619___.lane_b3 = next(veh___619___.lane_b3);
    veh___619___.lane_move_down := 
                      (veh___619___.lane_0 -> next(veh___619___.lane_0))
                      & (veh___619___.lane_01 -> next(veh___619___.lane_0))
                      & (veh___619___.lane_1 -> next(veh___619___.lane_01))
                      & (veh___619___.lane_12 -> next(veh___619___.lane_1))
                      & (veh___619___.lane_2 -> next(veh___619___.lane_12))
                      & (veh___619___.lane_23 -> next(veh___619___.lane_2))
                      & (veh___619___.lane_3 -> next(veh___619___.lane_23))
                      ;
    veh___619___.lane_move_up :=
                      (veh___619___.lane_3 -> next(veh___619___.lane_3))
                      & (veh___619___.lane_01 -> next(veh___619___.lane_1))
                      & (veh___619___.lane_0 -> next(veh___619___.lane_01))
                      & (veh___619___.lane_12 -> next(veh___619___.lane_2))
                      & (veh___619___.lane_1 -> next(veh___619___.lane_12))
                      & (veh___619___.lane_23 -> next(veh___619___.lane_3))
                      & (veh___619___.lane_2 -> next(veh___619___.lane_23))
                      ;
	
   
   
	veh___619___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___619___.lane_b0)  )
      | ((veh___609___.lane_b1 & veh___619___.lane_b1) & !(veh___609___.lane_b0 & veh___619___.lane_b2) & !(veh___609___.lane_b2 & veh___619___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___619___.lane_b2) & !(veh___609___.lane_b1 & veh___619___.lane_b3) & !(veh___609___.lane_b3 & veh___619___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___619___.lane_b3)  )
      
   );
   
	
	-- >>> Car 2 <<<
    veh___629___.lane_0 := veh___629___.lane_b0 & !veh___629___.lane_b1& !veh___629___.lane_b2& !veh___629___.lane_b3;
    veh___629___.lane_01 := veh___629___.lane_b0 &veh___629___.lane_b1 &!veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_1 := !veh___629___.lane_b0 &veh___629___.lane_b1 &!veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_12 := !veh___629___.lane_b0 &veh___629___.lane_b1 &veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_2 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_23 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &veh___629___.lane_b2 &veh___629___.lane_b3 ;
    veh___629___.lane_3 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &!veh___629___.lane_b2 &veh___629___.lane_b3 ;
    

    veh___629___.lane_min := veh___629___.lane_0;
    veh___629___.lane_max := veh___629___.lane_3;
    veh___629___.lane_single := veh___629___.lane_0 |veh___629___.lane_1 |veh___629___.lane_2 |veh___629___.lane_3 ;
    veh___629___.lane_crossing := veh___629___.lane_01|veh___629___.lane_12|veh___629___.lane_23;
    veh___629___.lane_unchanged := veh___629___.lane_b0 = next(veh___629___.lane_b0)&veh___629___.lane_b1 = next(veh___629___.lane_b1)&veh___629___.lane_b2 = next(veh___629___.lane_b2)&veh___629___.lane_b3 = next(veh___629___.lane_b3);
    veh___629___.lane_move_down := 
                      (veh___629___.lane_0 -> next(veh___629___.lane_0))
                      & (veh___629___.lane_01 -> next(veh___629___.lane_0))
                      & (veh___629___.lane_1 -> next(veh___629___.lane_01))
                      & (veh___629___.lane_12 -> next(veh___629___.lane_1))
                      & (veh___629___.lane_2 -> next(veh___629___.lane_12))
                      & (veh___629___.lane_23 -> next(veh___629___.lane_2))
                      & (veh___629___.lane_3 -> next(veh___629___.lane_23))
                      ;
    veh___629___.lane_move_up :=
                      (veh___629___.lane_3 -> next(veh___629___.lane_3))
                      & (veh___629___.lane_01 -> next(veh___629___.lane_1))
                      & (veh___629___.lane_0 -> next(veh___629___.lane_01))
                      & (veh___629___.lane_12 -> next(veh___629___.lane_2))
                      & (veh___629___.lane_1 -> next(veh___629___.lane_12))
                      & (veh___629___.lane_23 -> next(veh___629___.lane_3))
                      & (veh___629___.lane_2 -> next(veh___629___.lane_23))
                      ;
   
	veh___629___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___629___.lane_b0)  )
      | ((veh___609___.lane_b1 & veh___629___.lane_b1) & !(veh___609___.lane_b0 & veh___629___.lane_b2) & !(veh___609___.lane_b2 & veh___629___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___629___.lane_b2) & !(veh___609___.lane_b1 & veh___629___.lane_b3) & !(veh___609___.lane_b3 & veh___629___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___629___.lane_b3)  )
      
   );
   veh___629___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___629___.lane_b0)  )
      | ((veh___619___.lane_b1 & veh___629___.lane_b1) & !(veh___619___.lane_b0 & veh___629___.lane_b2) & !(veh___619___.lane_b2 & veh___629___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___629___.lane_b2) & !(veh___619___.lane_b1 & veh___629___.lane_b3) & !(veh___619___.lane_b3 & veh___629___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___629___.lane_b3)  )
      
   );
   
	
	-- >>> Car 3 <<<
    veh___639___.lane_0 := veh___639___.lane_b0 & !veh___639___.lane_b1& !veh___639___.lane_b2& !veh___639___.lane_b3;
    veh___639___.lane_01 := veh___639___.lane_b0 &veh___639___.lane_b1 &!veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_1 := !veh___639___.lane_b0 &veh___639___.lane_b1 &!veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_12 := !veh___639___.lane_b0 &veh___639___.lane_b1 &veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_2 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_23 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &veh___639___.lane_b2 &veh___639___.lane_b3 ;
    veh___639___.lane_3 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &!veh___639___.lane_b2 &veh___639___.lane_b3 ;
    

    veh___639___.lane_min := veh___639___.lane_0;
    veh___639___.lane_max := veh___639___.lane_3;
    veh___639___.lane_single := veh___639___.lane_0 |veh___639___.lane_1 |veh___639___.lane_2 |veh___639___.lane_3 ;
    veh___639___.lane_crossing := veh___639___.lane_01|veh___639___.lane_12|veh___639___.lane_23;
    veh___639___.lane_unchanged := veh___639___.lane_b0 = next(veh___639___.lane_b0)&veh___639___.lane_b1 = next(veh___639___.lane_b1)&veh___639___.lane_b2 = next(veh___639___.lane_b2)&veh___639___.lane_b3 = next(veh___639___.lane_b3);
    veh___639___.lane_move_down := 
                      (veh___639___.lane_0 -> next(veh___639___.lane_0))
                      & (veh___639___.lane_01 -> next(veh___639___.lane_0))
                      & (veh___639___.lane_1 -> next(veh___639___.lane_01))
                      & (veh___639___.lane_12 -> next(veh___639___.lane_1))
                      & (veh___639___.lane_2 -> next(veh___639___.lane_12))
                      & (veh___639___.lane_23 -> next(veh___639___.lane_2))
                      & (veh___639___.lane_3 -> next(veh___639___.lane_23))
                      ;
    veh___639___.lane_move_up :=
                      (veh___639___.lane_3 -> next(veh___639___.lane_3))
                      & (veh___639___.lane_01 -> next(veh___639___.lane_1))
                      & (veh___639___.lane_0 -> next(veh___639___.lane_01))
                      & (veh___639___.lane_12 -> next(veh___639___.lane_2))
                      & (veh___639___.lane_1 -> next(veh___639___.lane_12))
                      & (veh___639___.lane_23 -> next(veh___639___.lane_3))
                      & (veh___639___.lane_2 -> next(veh___639___.lane_23))
                      ;
   
	veh___639___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___639___.lane_b0)  )
      | ((veh___609___.lane_b1 & veh___639___.lane_b1) & !(veh___609___.lane_b0 & veh___639___.lane_b2) & !(veh___609___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___639___.lane_b2) & !(veh___609___.lane_b1 & veh___639___.lane_b3) & !(veh___609___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___639___.lane_b3)  )
      
   );
   veh___639___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___639___.lane_b0)  )
      | ((veh___619___.lane_b1 & veh___639___.lane_b1) & !(veh___619___.lane_b0 & veh___639___.lane_b2) & !(veh___619___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___639___.lane_b2) & !(veh___619___.lane_b1 & veh___639___.lane_b3) & !(veh___619___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___639___.lane_b3)  )
      
   );
   veh___639___.same_lane_as_veh_2 := (FALSE
      | ((veh___629___.lane_b0 & veh___639___.lane_b0)  )
      | ((veh___629___.lane_b1 & veh___639___.lane_b1) & !(veh___629___.lane_b0 & veh___639___.lane_b2) & !(veh___629___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___629___.lane_b2 & veh___639___.lane_b2) & !(veh___629___.lane_b1 & veh___639___.lane_b3) & !(veh___629___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___629___.lane_b3 & veh___639___.lane_b3)  )
      
   );
   
	
	-- >>> Car 4 <<<
    veh___649___.lane_0 := veh___649___.lane_b0 & !veh___649___.lane_b1& !veh___649___.lane_b2& !veh___649___.lane_b3;
    veh___649___.lane_01 := veh___649___.lane_b0 &veh___649___.lane_b1 &!veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_1 := !veh___649___.lane_b0 &veh___649___.lane_b1 &!veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_12 := !veh___649___.lane_b0 &veh___649___.lane_b1 &veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_2 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_23 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &veh___649___.lane_b2 &veh___649___.lane_b3 ;
    veh___649___.lane_3 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &!veh___649___.lane_b2 &veh___649___.lane_b3 ;
    

    veh___649___.lane_min := veh___649___.lane_0;
    veh___649___.lane_max := veh___649___.lane_3;
    veh___649___.lane_single := veh___649___.lane_0 |veh___649___.lane_1 |veh___649___.lane_2 |veh___649___.lane_3 ;
    veh___649___.lane_crossing := veh___649___.lane_01|veh___649___.lane_12|veh___649___.lane_23;
    veh___649___.lane_unchanged := veh___649___.lane_b0 = next(veh___649___.lane_b0)&veh___649___.lane_b1 = next(veh___649___.lane_b1)&veh___649___.lane_b2 = next(veh___649___.lane_b2)&veh___649___.lane_b3 = next(veh___649___.lane_b3);
    veh___649___.lane_move_down := 
                      (veh___649___.lane_0 -> next(veh___649___.lane_0))
                      & (veh___649___.lane_01 -> next(veh___649___.lane_0))
                      & (veh___649___.lane_1 -> next(veh___649___.lane_01))
                      & (veh___649___.lane_12 -> next(veh___649___.lane_1))
                      & (veh___649___.lane_2 -> next(veh___649___.lane_12))
                      & (veh___649___.lane_23 -> next(veh___649___.lane_2))
                      & (veh___649___.lane_3 -> next(veh___649___.lane_23))
                      ;
    veh___649___.lane_move_up :=
                      (veh___649___.lane_3 -> next(veh___649___.lane_3))
                      & (veh___649___.lane_01 -> next(veh___649___.lane_1))
                      & (veh___649___.lane_0 -> next(veh___649___.lane_01))
                      & (veh___649___.lane_12 -> next(veh___649___.lane_2))
                      & (veh___649___.lane_1 -> next(veh___649___.lane_12))
                      & (veh___649___.lane_23 -> next(veh___649___.lane_3))
                      & (veh___649___.lane_2 -> next(veh___649___.lane_23))
                      ;
   
   
	veh___649___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___649___.lane_b0)  )
      | ((veh___609___.lane_b1 & veh___649___.lane_b1) & !(veh___609___.lane_b0 & veh___649___.lane_b2) & !(veh___609___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___649___.lane_b2) & !(veh___609___.lane_b1 & veh___649___.lane_b3) & !(veh___609___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___649___.lane_b3)  )
      
   );
   veh___649___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___649___.lane_b0)  )
      | ((veh___619___.lane_b1 & veh___649___.lane_b1) & !(veh___619___.lane_b0 & veh___649___.lane_b2) & !(veh___619___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___649___.lane_b2) & !(veh___619___.lane_b1 & veh___649___.lane_b3) & !(veh___619___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___649___.lane_b3)  )
      
   );
   veh___649___.same_lane_as_veh_2 := (FALSE
      | ((veh___629___.lane_b0 & veh___649___.lane_b0)  )
      | ((veh___629___.lane_b1 & veh___649___.lane_b1) & !(veh___629___.lane_b0 & veh___649___.lane_b2) & !(veh___629___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___629___.lane_b2 & veh___649___.lane_b2) & !(veh___629___.lane_b1 & veh___649___.lane_b3) & !(veh___629___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___629___.lane_b3 & veh___649___.lane_b3)  )
      
   );
   veh___649___.same_lane_as_veh_3 := (FALSE
      | ((veh___639___.lane_b0 & veh___649___.lane_b0)  )
      | ((veh___639___.lane_b1 & veh___649___.lane_b1) & !(veh___639___.lane_b0 & veh___649___.lane_b2) & !(veh___639___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___639___.lane_b2 & veh___649___.lane_b2) & !(veh___639___.lane_b1 & veh___649___.lane_b3) & !(veh___639___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___639___.lane_b3 & veh___649___.lane_b3)  )
      
   );
   
	

INVAR
   num_lanes = 4;


-- >>> Car 0 <<<
--INIT 
--   veh___609___.lane_single;

INIT 
   veh___609___.rel_pos >= -200 & veh___609___.rel_pos <= 200;

INVAR
    veh___609___.lane_single | veh___609___.lane_crossing;

INVAR
    (-300 <= veh___609___.rel_pos & veh___609___.rel_pos <= 300) &
    (-300 <= veh___609___.prev_rel_pos & veh___609___.prev_rel_pos <= 300) &
    (max(-veh___609___.v, a_min) <= veh___609___.a & veh___609___.a <= a_max) &
    (0 <= veh___609___.v & veh___609___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_0 := case
   veh___609___.v = 0 : 0;
   veh___609___.v = 1 : 1;
   veh___609___.v = 2 : 4;
   veh___609___.v = 3 : 9;
   veh___609___.v = 4 : 16;
   veh___609___.v = 5 : 25;
   veh___609___.v = 6 : 36;
   veh___609___.v = 7 : 49;
   veh___609___.v = 8 : 64;
   veh___609___.v = 9 : 81;
   veh___609___.v = 10 : 100;
   veh___609___.v = 11 : 121;
   veh___609___.v = 12 : 144;
   veh___609___.v = 13 : 169;
   veh___609___.v = 14 : 196;
   veh___609___.v = 15 : 225;
   veh___609___.v = 16 : 256;
   veh___609___.v = 17 : 289;
   veh___609___.v = 18 : 324;
   veh___609___.v = 19 : 361;
   veh___609___.v = 20 : 400;
   veh___609___.v = 21 : 441;
   veh___609___.v = 22 : 484;
   veh___609___.v = 23 : 529;
   veh___609___.v = 24 : 576;
   veh___609___.v = 25 : 625;
   veh___609___.v = 26 : 676;
   veh___609___.v = 27 : 729;
   veh___609___.v = 28 : 784;
   veh___609___.v = 29 : 841;
   veh___609___.v = 30 : 900;
   veh___609___.v = 31 : 961;
   veh___609___.v = 32 : 1024;
   veh___609___.v = 33 : 1089;
   veh___609___.v = 34 : 1156;
   veh___609___.v = 35 : 1225;
   veh___609___.v = 36 : 1296;
   veh___609___.v = 37 : 1369;
   veh___609___.v = 38 : 1444;
   veh___609___.v = 39 : 1521;
   veh___609___.v = 40 : 1600;
   veh___609___.v = 41 : 1681;
   veh___609___.v = 42 : 1764;
   veh___609___.v = 43 : 1849;
   veh___609___.v = 44 : 1936;
   veh___609___.v = 45 : 2025;
   veh___609___.v = 46 : 2116;
   veh___609___.v = 47 : 2209;
   veh___609___.v = 48 : 2304;
   veh___609___.v = 49 : 2401;
   veh___609___.v = 50 : 2500;
   veh___609___.v = 51 : 2601;
   veh___609___.v = 52 : 2704;
   veh___609___.v = 53 : 2809;
   veh___609___.v = 54 : 2916;
   veh___609___.v = 55 : 3025;
   veh___609___.v = 56 : 3136;
   veh___609___.v = 57 : 3249;
   veh___609___.v = 58 : 3364;
   veh___609___.v = 59 : 3481;
   veh___609___.v = 60 : 3600;
   veh___609___.v = 61 : 3721;
   veh___609___.v = 62 : 3844;
   veh___609___.v = 63 : 3969;
   veh___609___.v = 64 : 4096;
   veh___609___.v = 65 : 4225;
   veh___609___.v = 66 : 4356;
   veh___609___.v = 67 : 4489;
   veh___609___.v = 68 : 4624;
   veh___609___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

-- these are invariants that apply to any state
-- check that chosen long acceleration of other vehicle is indeed safe

-- >>> Car 1 <<<
--INIT 
--   veh___619___.lane_single;

INIT 
   veh___619___.rel_pos >= -200 & veh___619___.rel_pos <= 200;

INVAR
    veh___619___.lane_single | veh___619___.lane_crossing;

INVAR
    (-300 <= veh___619___.rel_pos & veh___619___.rel_pos <= 300) &
    (-300 <= veh___619___.prev_rel_pos & veh___619___.prev_rel_pos <= 300) &
    (max(-veh___619___.v, a_min) <= veh___619___.a & veh___619___.a <= a_max) &
    (0 <= veh___619___.v & veh___619___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_1 := case
   veh___619___.v = 0 : 0;
   veh___619___.v = 1 : 1;
   veh___619___.v = 2 : 4;
   veh___619___.v = 3 : 9;
   veh___619___.v = 4 : 16;
   veh___619___.v = 5 : 25;
   veh___619___.v = 6 : 36;
   veh___619___.v = 7 : 49;
   veh___619___.v = 8 : 64;
   veh___619___.v = 9 : 81;
   veh___619___.v = 10 : 100;
   veh___619___.v = 11 : 121;
   veh___619___.v = 12 : 144;
   veh___619___.v = 13 : 169;
   veh___619___.v = 14 : 196;
   veh___619___.v = 15 : 225;
   veh___619___.v = 16 : 256;
   veh___619___.v = 17 : 289;
   veh___619___.v = 18 : 324;
   veh___619___.v = 19 : 361;
   veh___619___.v = 20 : 400;
   veh___619___.v = 21 : 441;
   veh___619___.v = 22 : 484;
   veh___619___.v = 23 : 529;
   veh___619___.v = 24 : 576;
   veh___619___.v = 25 : 625;
   veh___619___.v = 26 : 676;
   veh___619___.v = 27 : 729;
   veh___619___.v = 28 : 784;
   veh___619___.v = 29 : 841;
   veh___619___.v = 30 : 900;
   veh___619___.v = 31 : 961;
   veh___619___.v = 32 : 1024;
   veh___619___.v = 33 : 1089;
   veh___619___.v = 34 : 1156;
   veh___619___.v = 35 : 1225;
   veh___619___.v = 36 : 1296;
   veh___619___.v = 37 : 1369;
   veh___619___.v = 38 : 1444;
   veh___619___.v = 39 : 1521;
   veh___619___.v = 40 : 1600;
   veh___619___.v = 41 : 1681;
   veh___619___.v = 42 : 1764;
   veh___619___.v = 43 : 1849;
   veh___619___.v = 44 : 1936;
   veh___619___.v = 45 : 2025;
   veh___619___.v = 46 : 2116;
   veh___619___.v = 47 : 2209;
   veh___619___.v = 48 : 2304;
   veh___619___.v = 49 : 2401;
   veh___619___.v = 50 : 2500;
   veh___619___.v = 51 : 2601;
   veh___619___.v = 52 : 2704;
   veh___619___.v = 53 : 2809;
   veh___619___.v = 54 : 2916;
   veh___619___.v = 55 : 3025;
   veh___619___.v = 56 : 3136;
   veh___619___.v = 57 : 3249;
   veh___619___.v = 58 : 3364;
   veh___619___.v = 59 : 3481;
   veh___619___.v = 60 : 3600;
   veh___619___.v = 61 : 3721;
   veh___619___.v = 62 : 3844;
   veh___619___.v = 63 : 3969;
   veh___619___.v = 64 : 4096;
   veh___619___.v = 65 : 4225;
   veh___619___.v = 66 : 4356;
   veh___619___.v = 67 : 4489;
   veh___619___.v = 68 : 4624;
   veh___619___.v = 69 : 4761;
   
   TRUE: 4900;
esac;


-- these are invariants that apply to any state
-- check that chosen long acceleration of other vehicle is indeed safe

--INVAR -- Non-Ego cars may not collide.
--    veh___619___.same_lane_as_veh_0 -> (abs(veh___609___.rel_pos - veh___619___.rel_pos) > veh_length);

--INVAR -- Non-Ego cars may not "jump" over each other.
--    !(veh___619___.same_lane_as_veh_0 & (veh___609___.prev_rel_pos < veh___619___.prev_rel_pos) & (veh___609___.rel_pos >= veh___619___.rel_pos)) &
--    !(veh___619___.same_lane_as_veh_0 & (veh___619___.prev_rel_pos < veh___609___.prev_rel_pos) & (veh___619___.rel_pos >= veh___609___.rel_pos));
	
-- >>> Car 2 <<<
--INIT 
--   veh___629___.lane_single;

INIT 
   veh___629___.rel_pos >= -200 & veh___629___.rel_pos <= 200;

INVAR
    veh___629___.lane_single | veh___629___.lane_crossing;

INVAR
    (-300 <= veh___629___.rel_pos & veh___629___.rel_pos <= 300) &
    (-300 <= veh___629___.prev_rel_pos & veh___629___.prev_rel_pos <= 300) &
    (max(-veh___629___.v, a_min) <= veh___629___.a & veh___629___.a <= a_max) &
    (0 <= veh___629___.v & veh___629___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_2 := case
   veh___629___.v = 0 : 0;
   veh___629___.v = 1 : 1;
   veh___629___.v = 2 : 4;
   veh___629___.v = 3 : 9;
   veh___629___.v = 4 : 16;
   veh___629___.v = 5 : 25;
   veh___629___.v = 6 : 36;
   veh___629___.v = 7 : 49;
   veh___629___.v = 8 : 64;
   veh___629___.v = 9 : 81;
   veh___629___.v = 10 : 100;
   veh___629___.v = 11 : 121;
   veh___629___.v = 12 : 144;
   veh___629___.v = 13 : 169;
   veh___629___.v = 14 : 196;
   veh___629___.v = 15 : 225;
   veh___629___.v = 16 : 256;
   veh___629___.v = 17 : 289;
   veh___629___.v = 18 : 324;
   veh___629___.v = 19 : 361;
   veh___629___.v = 20 : 400;
   veh___629___.v = 21 : 441;
   veh___629___.v = 22 : 484;
   veh___629___.v = 23 : 529;
   veh___629___.v = 24 : 576;
   veh___629___.v = 25 : 625;
   veh___629___.v = 26 : 676;
   veh___629___.v = 27 : 729;
   veh___629___.v = 28 : 784;
   veh___629___.v = 29 : 841;
   veh___629___.v = 30 : 900;
   veh___629___.v = 31 : 961;
   veh___629___.v = 32 : 1024;
   veh___629___.v = 33 : 1089;
   veh___629___.v = 34 : 1156;
   veh___629___.v = 35 : 1225;
   veh___629___.v = 36 : 1296;
   veh___629___.v = 37 : 1369;
   veh___629___.v = 38 : 1444;
   veh___629___.v = 39 : 1521;
   veh___629___.v = 40 : 1600;
   veh___629___.v = 41 : 1681;
   veh___629___.v = 42 : 1764;
   veh___629___.v = 43 : 1849;
   veh___629___.v = 44 : 1936;
   veh___629___.v = 45 : 2025;
   veh___629___.v = 46 : 2116;
   veh___629___.v = 47 : 2209;
   veh___629___.v = 48 : 2304;
   veh___629___.v = 49 : 2401;
   veh___629___.v = 50 : 2500;
   veh___629___.v = 51 : 2601;
   veh___629___.v = 52 : 2704;
   veh___629___.v = 53 : 2809;
   veh___629___.v = 54 : 2916;
   veh___629___.v = 55 : 3025;
   veh___629___.v = 56 : 3136;
   veh___629___.v = 57 : 3249;
   veh___629___.v = 58 : 3364;
   veh___629___.v = 59 : 3481;
   veh___629___.v = 60 : 3600;
   veh___629___.v = 61 : 3721;
   veh___629___.v = 62 : 3844;
   veh___629___.v = 63 : 3969;
   veh___629___.v = 64 : 4096;
   veh___629___.v = 65 : 4225;
   veh___629___.v = 66 : 4356;
   veh___629___.v = 67 : 4489;
   veh___629___.v = 68 : 4624;
   veh___629___.v = 69 : 4761;
   
   TRUE: 4900;
esac;


-- these are invariants that apply to any state
-- check that chosen long acceleration of other vehicle is indeed safe

--INVAR -- Non-Ego cars may not collide.
--    veh___629___.same_lane_as_veh_0 -> (abs(veh___609___.rel_pos - veh___629___.rel_pos) > veh_length);

--INVAR -- Non-Ego cars may not "jump" over each other.
--    !(veh___629___.same_lane_as_veh_0 & (veh___609___.prev_rel_pos < veh___629___.prev_rel_pos) & (veh___609___.rel_pos >= veh___629___.rel_pos)) &
--    !(veh___629___.same_lane_as_veh_0 & (veh___629___.prev_rel_pos < veh___609___.prev_rel_pos) & (veh___629___.rel_pos >= veh___609___.rel_pos));
	
INVAR -- Non-Ego cars may not collide.
    veh___629___.same_lane_as_veh_1 -> (abs(veh___619___.rel_pos - veh___629___.rel_pos) > veh_length);

INVAR -- Non-Ego cars may not "jump" over each other.
    !(veh___629___.same_lane_as_veh_1 & (veh___619___.prev_rel_pos < veh___629___.prev_rel_pos) & (veh___619___.rel_pos >= veh___629___.rel_pos)) &
    !(veh___629___.same_lane_as_veh_1 & (veh___629___.prev_rel_pos < veh___619___.prev_rel_pos) & (veh___629___.rel_pos >= veh___619___.rel_pos));
	
-- >>> Car 3 <<<
--INIT 
--   veh___639___.lane_single;

INIT 
   veh___639___.rel_pos >= -200 & veh___639___.rel_pos <= 200;

INVAR
    veh___639___.lane_single | veh___639___.lane_crossing;

INVAR
    (-300 <= veh___639___.rel_pos & veh___639___.rel_pos <= 300) &
    (-300 <= veh___639___.prev_rel_pos & veh___639___.prev_rel_pos <= 300) &
    (max(-veh___639___.v, a_min) <= veh___639___.a & veh___639___.a <= a_max) &
    (0 <= veh___639___.v & veh___639___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_3 := case
   veh___639___.v = 0 : 0;
   veh___639___.v = 1 : 1;
   veh___639___.v = 2 : 4;
   veh___639___.v = 3 : 9;
   veh___639___.v = 4 : 16;
   veh___639___.v = 5 : 25;
   veh___639___.v = 6 : 36;
   veh___639___.v = 7 : 49;
   veh___639___.v = 8 : 64;
   veh___639___.v = 9 : 81;
   veh___639___.v = 10 : 100;
   veh___639___.v = 11 : 121;
   veh___639___.v = 12 : 144;
   veh___639___.v = 13 : 169;
   veh___639___.v = 14 : 196;
   veh___639___.v = 15 : 225;
   veh___639___.v = 16 : 256;
   veh___639___.v = 17 : 289;
   veh___639___.v = 18 : 324;
   veh___639___.v = 19 : 361;
   veh___639___.v = 20 : 400;
   veh___639___.v = 21 : 441;
   veh___639___.v = 22 : 484;
   veh___639___.v = 23 : 529;
   veh___639___.v = 24 : 576;
   veh___639___.v = 25 : 625;
   veh___639___.v = 26 : 676;
   veh___639___.v = 27 : 729;
   veh___639___.v = 28 : 784;
   veh___639___.v = 29 : 841;
   veh___639___.v = 30 : 900;
   veh___639___.v = 31 : 961;
   veh___639___.v = 32 : 1024;
   veh___639___.v = 33 : 1089;
   veh___639___.v = 34 : 1156;
   veh___639___.v = 35 : 1225;
   veh___639___.v = 36 : 1296;
   veh___639___.v = 37 : 1369;
   veh___639___.v = 38 : 1444;
   veh___639___.v = 39 : 1521;
   veh___639___.v = 40 : 1600;
   veh___639___.v = 41 : 1681;
   veh___639___.v = 42 : 1764;
   veh___639___.v = 43 : 1849;
   veh___639___.v = 44 : 1936;
   veh___639___.v = 45 : 2025;
   veh___639___.v = 46 : 2116;
   veh___639___.v = 47 : 2209;
   veh___639___.v = 48 : 2304;
   veh___639___.v = 49 : 2401;
   veh___639___.v = 50 : 2500;
   veh___639___.v = 51 : 2601;
   veh___639___.v = 52 : 2704;
   veh___639___.v = 53 : 2809;
   veh___639___.v = 54 : 2916;
   veh___639___.v = 55 : 3025;
   veh___639___.v = 56 : 3136;
   veh___639___.v = 57 : 3249;
   veh___639___.v = 58 : 3364;
   veh___639___.v = 59 : 3481;
   veh___639___.v = 60 : 3600;
   veh___639___.v = 61 : 3721;
   veh___639___.v = 62 : 3844;
   veh___639___.v = 63 : 3969;
   veh___639___.v = 64 : 4096;
   veh___639___.v = 65 : 4225;
   veh___639___.v = 66 : 4356;
   veh___639___.v = 67 : 4489;
   veh___639___.v = 68 : 4624;
   veh___639___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

-- these are invariants that apply to any state
-- check that chosen long acceleration of other vehicle is indeed safe

--INVAR -- Non-Ego cars may not collide.
--    veh___639___.same_lane_as_veh_0 -> (abs(veh___609___.rel_pos - veh___639___.rel_pos) > veh_length);

--INVAR -- Non-Ego cars may not "jump" over each other.
--    !(veh___639___.same_lane_as_veh_0 & (veh___609___.prev_rel_pos < veh___639___.prev_rel_pos) & (veh___609___.rel_pos >= veh___639___.rel_pos)) &
--    !(veh___639___.same_lane_as_veh_0 & (veh___639___.prev_rel_pos < veh___609___.prev_rel_pos) & (veh___639___.rel_pos >= veh___609___.rel_pos));
	
INVAR -- Non-Ego cars may not collide.
    veh___639___.same_lane_as_veh_1 -> (abs(veh___619___.rel_pos - veh___639___.rel_pos) > veh_length);

INVAR -- Non-Ego cars may not "jump" over each other.
    !(veh___639___.same_lane_as_veh_1 & (veh___619___.prev_rel_pos < veh___639___.prev_rel_pos) & (veh___619___.rel_pos >= veh___639___.rel_pos)) &
    !(veh___639___.same_lane_as_veh_1 & (veh___639___.prev_rel_pos < veh___619___.prev_rel_pos) & (veh___639___.rel_pos >= veh___619___.rel_pos));
	
INVAR -- Non-Ego cars may not collide.
    veh___639___.same_lane_as_veh_2 -> (abs(veh___629___.rel_pos - veh___639___.rel_pos) > veh_length);

INVAR -- Non-Ego cars may not "jump" over each other.
    !(veh___639___.same_lane_as_veh_2 & (veh___629___.prev_rel_pos < veh___639___.prev_rel_pos) & (veh___629___.rel_pos >= veh___639___.rel_pos)) &
    !(veh___639___.same_lane_as_veh_2 & (veh___639___.prev_rel_pos < veh___629___.prev_rel_pos) & (veh___639___.rel_pos >= veh___629___.rel_pos));
	
-- >>> Car 4 <<<
--INIT 
--   veh___649___.lane_single;

INIT 
   veh___649___.rel_pos >= -200 & veh___649___.rel_pos <= 200;

INVAR
    veh___649___.lane_single | veh___649___.lane_crossing;

INVAR
    (-300 <= veh___649___.rel_pos & veh___649___.rel_pos <= 300) &
    (-300 <= veh___649___.prev_rel_pos & veh___649___.prev_rel_pos <= 300) &
    (max(-veh___649___.v, a_min) <= veh___649___.a & veh___649___.a <= a_max) &
    (0 <= veh___649___.v & veh___649___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_4 := case
   veh___649___.v = 0 : 0;
   veh___649___.v = 1 : 1;
   veh___649___.v = 2 : 4;
   veh___649___.v = 3 : 9;
   veh___649___.v = 4 : 16;
   veh___649___.v = 5 : 25;
   veh___649___.v = 6 : 36;
   veh___649___.v = 7 : 49;
   veh___649___.v = 8 : 64;
   veh___649___.v = 9 : 81;
   veh___649___.v = 10 : 100;
   veh___649___.v = 11 : 121;
   veh___649___.v = 12 : 144;
   veh___649___.v = 13 : 169;
   veh___649___.v = 14 : 196;
   veh___649___.v = 15 : 225;
   veh___649___.v = 16 : 256;
   veh___649___.v = 17 : 289;
   veh___649___.v = 18 : 324;
   veh___649___.v = 19 : 361;
   veh___649___.v = 20 : 400;
   veh___649___.v = 21 : 441;
   veh___649___.v = 22 : 484;
   veh___649___.v = 23 : 529;
   veh___649___.v = 24 : 576;
   veh___649___.v = 25 : 625;
   veh___649___.v = 26 : 676;
   veh___649___.v = 27 : 729;
   veh___649___.v = 28 : 784;
   veh___649___.v = 29 : 841;
   veh___649___.v = 30 : 900;
   veh___649___.v = 31 : 961;
   veh___649___.v = 32 : 1024;
   veh___649___.v = 33 : 1089;
   veh___649___.v = 34 : 1156;
   veh___649___.v = 35 : 1225;
   veh___649___.v = 36 : 1296;
   veh___649___.v = 37 : 1369;
   veh___649___.v = 38 : 1444;
   veh___649___.v = 39 : 1521;
   veh___649___.v = 40 : 1600;
   veh___649___.v = 41 : 1681;
   veh___649___.v = 42 : 1764;
   veh___649___.v = 43 : 1849;
   veh___649___.v = 44 : 1936;
   veh___649___.v = 45 : 2025;
   veh___649___.v = 46 : 2116;
   veh___649___.v = 47 : 2209;
   veh___649___.v = 48 : 2304;
   veh___649___.v = 49 : 2401;
   veh___649___.v = 50 : 2500;
   veh___649___.v = 51 : 2601;
   veh___649___.v = 52 : 2704;
   veh___649___.v = 53 : 2809;
   veh___649___.v = 54 : 2916;
   veh___649___.v = 55 : 3025;
   veh___649___.v = 56 : 3136;
   veh___649___.v = 57 : 3249;
   veh___649___.v = 58 : 3364;
   veh___649___.v = 59 : 3481;
   veh___649___.v = 60 : 3600;
   veh___649___.v = 61 : 3721;
   veh___649___.v = 62 : 3844;
   veh___649___.v = 63 : 3969;
   veh___649___.v = 64 : 4096;
   veh___649___.v = 65 : 4225;
   veh___649___.v = 66 : 4356;
   veh___649___.v = 67 : 4489;
   veh___649___.v = 68 : 4624;
   veh___649___.v = 69 : 4761;
   
   TRUE: 4900;
esac;


-- these are invariants that apply to any state
-- check that chosen long acceleration of other vehicle is indeed safe

--INVAR -- Non-Ego cars may not collide.
--    veh___649___.same_lane_as_veh_0 -> (abs(veh___609___.rel_pos - veh___649___.rel_pos) > veh_length);

--INVAR -- Non-Ego cars may not "jump" over each other.
--    !(veh___649___.same_lane_as_veh_0 & (veh___609___.prev_rel_pos < veh___649___.prev_rel_pos) & (veh___609___.rel_pos >= veh___649___.rel_pos)) &
--    !(veh___649___.same_lane_as_veh_0 & (veh___649___.prev_rel_pos < veh___609___.prev_rel_pos) & (veh___649___.rel_pos >= veh___609___.rel_pos));
	
INVAR -- Non-Ego cars may not collide.
    veh___649___.same_lane_as_veh_1 -> (abs(veh___619___.rel_pos - veh___649___.rel_pos) > veh_length);

INVAR -- Non-Ego cars may not "jump" over each other.
    !(veh___649___.same_lane_as_veh_1 & (veh___619___.prev_rel_pos < veh___649___.prev_rel_pos) & (veh___619___.rel_pos >= veh___649___.rel_pos)) &
    !(veh___649___.same_lane_as_veh_1 & (veh___649___.prev_rel_pos < veh___619___.prev_rel_pos) & (veh___649___.rel_pos >= veh___619___.rel_pos));
	
INVAR -- Non-Ego cars may not collide.
    veh___649___.same_lane_as_veh_2 -> (abs(veh___629___.rel_pos - veh___649___.rel_pos) > veh_length);

INVAR -- Non-Ego cars may not "jump" over each other.
    !(veh___649___.same_lane_as_veh_2 & (veh___629___.prev_rel_pos < veh___649___.prev_rel_pos) & (veh___629___.rel_pos >= veh___649___.rel_pos)) &
    !(veh___649___.same_lane_as_veh_2 & (veh___649___.prev_rel_pos < veh___629___.prev_rel_pos) & (veh___649___.rel_pos >= veh___629___.rel_pos));
	
INVAR -- Non-Ego cars may not collide.
    veh___649___.same_lane_as_veh_3 -> (abs(veh___639___.rel_pos - veh___649___.rel_pos) > veh_length);

INVAR -- Non-Ego cars may not "jump" over each other.
    !(veh___649___.same_lane_as_veh_3 & (veh___639___.prev_rel_pos < veh___649___.prev_rel_pos) & (veh___639___.rel_pos >= veh___649___.rel_pos)) &
    !(veh___649___.same_lane_as_veh_3 & (veh___649___.prev_rel_pos < veh___639___.prev_rel_pos) & (veh___649___.rel_pos >= veh___639___.rel_pos));
	




ASSIGN
-- >>> Car 0 <<<
    init(veh___609___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___609___.do_lane_change) := FALSE;
    init(veh___609___.abort_lc) := FALSE;
    init(veh___609___.lc_direction) := ActionDir____CENTER;
    init(veh___609___.lc_timer) := -1;
    init(veh___609___.change_lane_now) := 0;
    init(veh___609___.prev_rel_pos) := 0;
    -- init(veh___609___.v) := 35;
    init(veh___609___.a) := 0;
    init(veh___609___.turn_signals) := ActionDir____CENTER;
    init(veh___609___.lc_leave_src_lane) := FALSE;

    next(veh___609___.do_lane_change) := 
	    case 
        veh___609___.do_lane_change = FALSE & veh___609___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___609___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___609___.lc_timer >= complete_lane_change_earliest_after  & veh___609___.lc_timer < complete_lane_change_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___609___.lc_timer = complete_lane_change_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___609___.lc_timer >= abort_lane_change_complete_earliest_after & veh___609___.lc_timer < abort_lane_change_complete_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = TRUE: {TRUE, FALSE};
            veh___609___.lc_timer = abort_lane_change_complete_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___609___.lc_timer >= 0 & veh___609___.abort_lc = TRUE & veh___609___.lane_single: FALSE; 
            TRUE : veh___609___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___609___.abort_lc) := case
        veh___609___.lc_timer > leave_src_lane_latest_after & veh___609___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___609___.do_lane_change) = TRUE & veh___609___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___609___.abort_lc = TRUE & next(veh___609___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___609___.abort_lc;
    esac;

    next(veh___609___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE & veh___609___.lane_min : ActionDir____LEFT;
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE & veh___609___.lane_max : ActionDir____RIGHT;
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___609___.do_lane_change = TRUE & next(veh___609___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___609___.lc_direction;
    esac;

    next(veh___609___.lc_leave_src_lane) := case
        veh___609___.lane_single & next(veh___609___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___609___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE: next(veh___609___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___609___.do_lane_change = TRUE & veh___609___.lane_single & next(veh___609___.lane_crossing) : ActionDir____CENTER;
        veh___609___.lane_single & next(veh___609___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___609___.turn_signals;
    esac;

    next(veh___609___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___609___.lc_timer = -1 & veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE & veh___609___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___609___.lc_timer >= 0 & veh___609___.lane_single & next(veh___609___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___609___.lc_timer >= 0 & next(veh___609___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___609___.lc_timer >= 0 & veh___609___.abort_lc = FALSE & next(veh___609___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___609___.lc_timer >= 0 & veh___609___.lc_timer < complete_lane_change_latest_after : veh___609___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___609___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___609___.time_since_last_lc) := case
        veh___609___.do_lane_change = TRUE & next(veh___609___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___609___.time_since_last_lc >= 0 & veh___609___.time_since_last_lc < min_time_between_lcs: veh___609___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___609___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___609___.change_lane_now) := case
        veh___609___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___609___.prev_rel_pos) := veh___609___.rel_pos;
    next(veh___609___.rel_pos) := min(max(veh___609___.rel_pos + (next(veh___609___.v) - next(ego.v)), -300), 300);

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___609___.v) := min(max(veh___609___.v + veh___609___.a, 0), max_vel);

-- >>> Car 1 <<<
    init(veh___619___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___619___.do_lane_change) := FALSE;
    init(veh___619___.abort_lc) := FALSE;
    init(veh___619___.lc_direction) := ActionDir____CENTER;
    init(veh___619___.lc_timer) := -1;
    init(veh___619___.change_lane_now) := 0;
    init(veh___619___.prev_rel_pos) := 0;
    -- init(veh___619___.v) := 35;
    init(veh___619___.a) := 0;
    init(veh___619___.turn_signals) := ActionDir____CENTER;
    init(veh___619___.lc_leave_src_lane) := FALSE;

    next(veh___619___.do_lane_change) := 
	    case 
        veh___619___.do_lane_change = FALSE & veh___619___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___619___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___619___.lc_timer >= complete_lane_change_earliest_after  & veh___619___.lc_timer < complete_lane_change_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___619___.lc_timer = complete_lane_change_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___619___.lc_timer >= abort_lane_change_complete_earliest_after & veh___619___.lc_timer < abort_lane_change_complete_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = TRUE: {TRUE, FALSE};
            veh___619___.lc_timer = abort_lane_change_complete_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___619___.lc_timer >= 0 & veh___619___.abort_lc = TRUE & veh___619___.lane_single: FALSE; 
            TRUE : veh___619___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___619___.abort_lc) := case
        veh___619___.lc_timer > leave_src_lane_latest_after & veh___619___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___619___.do_lane_change) = TRUE & veh___619___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___619___.abort_lc = TRUE & next(veh___619___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___619___.abort_lc;
    esac;

    next(veh___619___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE & veh___619___.lane_min : ActionDir____LEFT;
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE & veh___619___.lane_max : ActionDir____RIGHT;
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___619___.do_lane_change = TRUE & next(veh___619___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___619___.lc_direction;
    esac;

    next(veh___619___.lc_leave_src_lane) := case
        veh___619___.lane_single & next(veh___619___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___619___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE: next(veh___619___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___619___.do_lane_change = TRUE & veh___619___.lane_single & next(veh___619___.lane_crossing) : ActionDir____CENTER;
        veh___619___.lane_single & next(veh___619___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___619___.turn_signals;
    esac;

    next(veh___619___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___619___.lc_timer = -1 & veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE & veh___619___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___619___.lc_timer >= 0 & veh___619___.lane_single & next(veh___619___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___619___.lc_timer >= 0 & next(veh___619___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___619___.lc_timer >= 0 & veh___619___.abort_lc = FALSE & next(veh___619___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___619___.lc_timer >= 0 & veh___619___.lc_timer < complete_lane_change_latest_after : veh___619___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___619___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___619___.time_since_last_lc) := case
        veh___619___.do_lane_change = TRUE & next(veh___619___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___619___.time_since_last_lc >= 0 & veh___619___.time_since_last_lc < min_time_between_lcs: veh___619___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___619___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___619___.change_lane_now) := case
        veh___619___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___619___.prev_rel_pos) := veh___619___.rel_pos;
    next(veh___619___.rel_pos) := min(max(veh___619___.rel_pos + (next(veh___619___.v) - next(ego.v)), -300), 300);

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___619___.v) := min(max(veh___619___.v + veh___619___.a, 0), max_vel);

-- >>> Car 2 <<<
    init(veh___629___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___629___.do_lane_change) := FALSE;
    init(veh___629___.abort_lc) := FALSE;
    init(veh___629___.lc_direction) := ActionDir____CENTER;
    init(veh___629___.lc_timer) := -1;
    init(veh___629___.change_lane_now) := 0;
    init(veh___629___.prev_rel_pos) := 0;
    -- init(veh___629___.v) := 35;
    init(veh___629___.a) := 0;
    init(veh___629___.turn_signals) := ActionDir____CENTER;
    init(veh___629___.lc_leave_src_lane) := FALSE;

    next(veh___629___.do_lane_change) := 
	    case 
        veh___629___.do_lane_change = FALSE & veh___629___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___629___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___629___.lc_timer >= complete_lane_change_earliest_after  & veh___629___.lc_timer < complete_lane_change_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___629___.lc_timer = complete_lane_change_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___629___.lc_timer >= abort_lane_change_complete_earliest_after & veh___629___.lc_timer < abort_lane_change_complete_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = TRUE: {TRUE, FALSE};
            veh___629___.lc_timer = abort_lane_change_complete_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___629___.lc_timer >= 0 & veh___629___.abort_lc = TRUE & veh___629___.lane_single: FALSE; 
            TRUE : veh___629___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___629___.abort_lc) := case
        veh___629___.lc_timer > leave_src_lane_latest_after & veh___629___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___629___.do_lane_change) = TRUE & veh___629___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___629___.abort_lc = TRUE & next(veh___629___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___629___.abort_lc;
    esac;

    next(veh___629___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE & veh___629___.lane_min : ActionDir____LEFT;
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE & veh___629___.lane_max : ActionDir____RIGHT;
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___629___.do_lane_change = TRUE & next(veh___629___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___629___.lc_direction;
    esac;

    next(veh___629___.lc_leave_src_lane) := case
        veh___629___.lane_single & next(veh___629___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___629___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE: next(veh___629___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___629___.do_lane_change = TRUE & veh___629___.lane_single & next(veh___629___.lane_crossing) : ActionDir____CENTER;
        veh___629___.lane_single & next(veh___629___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___629___.turn_signals;
    esac;

    next(veh___629___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___629___.lc_timer = -1 & veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE & veh___629___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___629___.lc_timer >= 0 & veh___629___.lane_single & next(veh___629___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___629___.lc_timer >= 0 & next(veh___629___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___629___.lc_timer >= 0 & veh___629___.abort_lc = FALSE & next(veh___629___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___629___.lc_timer >= 0 & veh___629___.lc_timer < complete_lane_change_latest_after : veh___629___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___629___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___629___.time_since_last_lc) := case
        veh___629___.do_lane_change = TRUE & next(veh___629___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___629___.time_since_last_lc >= 0 & veh___629___.time_since_last_lc < min_time_between_lcs: veh___629___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___629___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___629___.change_lane_now) := case
        veh___629___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___629___.prev_rel_pos) := veh___629___.rel_pos;
    next(veh___629___.rel_pos) := min(max(veh___629___.rel_pos + (next(veh___629___.v) - next(ego.v)), -300), 300);

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___629___.v) := min(max(veh___629___.v + veh___629___.a, 0), max_vel);

-- >>> Car 3 <<<
    init(veh___639___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___639___.do_lane_change) := FALSE;
    init(veh___639___.abort_lc) := FALSE;
    init(veh___639___.lc_direction) := ActionDir____CENTER;
    init(veh___639___.lc_timer) := -1;
    init(veh___639___.change_lane_now) := 0;
    init(veh___639___.prev_rel_pos) := 0;
    -- init(veh___639___.v) := 35;
    init(veh___639___.a) := 0;
    init(veh___639___.turn_signals) := ActionDir____CENTER;
    init(veh___639___.lc_leave_src_lane) := FALSE;

    next(veh___639___.do_lane_change) := 
	    case 
        veh___639___.do_lane_change = FALSE & veh___639___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___639___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___639___.lc_timer >= complete_lane_change_earliest_after  & veh___639___.lc_timer < complete_lane_change_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___639___.lc_timer = complete_lane_change_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___639___.lc_timer >= abort_lane_change_complete_earliest_after & veh___639___.lc_timer < abort_lane_change_complete_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = TRUE: {TRUE, FALSE};
            veh___639___.lc_timer = abort_lane_change_complete_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___639___.lc_timer >= 0 & veh___639___.abort_lc = TRUE & veh___639___.lane_single: FALSE; 
            TRUE : veh___639___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___639___.abort_lc) := case
        veh___639___.lc_timer > leave_src_lane_latest_after & veh___639___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___639___.do_lane_change) = TRUE & veh___639___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___639___.abort_lc = TRUE & next(veh___639___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___639___.abort_lc;
    esac;

    next(veh___639___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE & veh___639___.lane_min : ActionDir____LEFT;
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE & veh___639___.lane_max : ActionDir____RIGHT;
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___639___.do_lane_change = TRUE & next(veh___639___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___639___.lc_direction;
    esac;

    next(veh___639___.lc_leave_src_lane) := case
        veh___639___.lane_single & next(veh___639___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___639___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE: next(veh___639___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___639___.do_lane_change = TRUE & veh___639___.lane_single & next(veh___639___.lane_crossing) : ActionDir____CENTER;
        veh___639___.lane_single & next(veh___639___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___639___.turn_signals;
    esac;

    next(veh___639___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___639___.lc_timer = -1 & veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE & veh___639___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___639___.lc_timer >= 0 & veh___639___.lane_single & next(veh___639___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___639___.lc_timer >= 0 & next(veh___639___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___639___.lc_timer >= 0 & veh___639___.abort_lc = FALSE & next(veh___639___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___639___.lc_timer >= 0 & veh___639___.lc_timer < complete_lane_change_latest_after : veh___639___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___639___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___639___.time_since_last_lc) := case
        veh___639___.do_lane_change = TRUE & next(veh___639___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___639___.time_since_last_lc >= 0 & veh___639___.time_since_last_lc < min_time_between_lcs: veh___639___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___639___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___639___.change_lane_now) := case
        veh___639___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___639___.prev_rel_pos) := veh___639___.rel_pos;
    next(veh___639___.rel_pos) := min(max(veh___639___.rel_pos + (next(veh___639___.v) - next(ego.v)), -300), 300);

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___639___.v) := min(max(veh___639___.v + veh___639___.a, 0), max_vel);

-- >>> Car 4 <<<
    init(veh___649___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___649___.do_lane_change) := FALSE;
    init(veh___649___.abort_lc) := FALSE;
    init(veh___649___.lc_direction) := ActionDir____CENTER;
    init(veh___649___.lc_timer) := -1;
    init(veh___649___.change_lane_now) := 0;
    init(veh___649___.prev_rel_pos) := 0;
    -- init(veh___649___.v) := 35;
    init(veh___649___.a) := 0;
    init(veh___649___.turn_signals) := ActionDir____CENTER;
    init(veh___649___.lc_leave_src_lane) := FALSE;

    next(veh___649___.do_lane_change) := 
	    case 
        veh___649___.do_lane_change = FALSE & veh___649___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___649___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___649___.lc_timer >= complete_lane_change_earliest_after  & veh___649___.lc_timer < complete_lane_change_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___649___.lc_timer = complete_lane_change_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___649___.lc_timer >= abort_lane_change_complete_earliest_after & veh___649___.lc_timer < abort_lane_change_complete_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = TRUE: {TRUE, FALSE};
            veh___649___.lc_timer = abort_lane_change_complete_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___649___.lc_timer >= 0 & veh___649___.abort_lc = TRUE & veh___649___.lane_single: FALSE; 
            TRUE : veh___649___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___649___.abort_lc) := case
        veh___649___.lc_timer > leave_src_lane_latest_after & veh___649___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___649___.do_lane_change) = TRUE & veh___649___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___649___.abort_lc = TRUE & next(veh___649___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___649___.abort_lc;
    esac;

    next(veh___649___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE & veh___649___.lane_min : ActionDir____LEFT;
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE & veh___649___.lane_max : ActionDir____RIGHT;
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___649___.do_lane_change = TRUE & next(veh___649___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___649___.lc_direction;
    esac;

    next(veh___649___.lc_leave_src_lane) := case
        veh___649___.lane_single & next(veh___649___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___649___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE: next(veh___649___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___649___.do_lane_change = TRUE & veh___649___.lane_single & next(veh___649___.lane_crossing) : ActionDir____CENTER;
        veh___649___.lane_single & next(veh___649___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___649___.turn_signals;
    esac;

    next(veh___649___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___649___.lc_timer = -1 & veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE & veh___649___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___649___.lc_timer >= 0 & veh___649___.lane_single & next(veh___649___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___649___.lc_timer >= 0 & next(veh___649___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___649___.lc_timer >= 0 & veh___649___.abort_lc = FALSE & next(veh___649___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___649___.lc_timer >= 0 & veh___649___.lc_timer < complete_lane_change_latest_after : veh___649___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___649___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___649___.time_since_last_lc) := case
        veh___649___.do_lane_change = TRUE & next(veh___649___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___649___.time_since_last_lc >= 0 & veh___649___.time_since_last_lc < min_time_between_lcs: veh___649___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___649___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___649___.change_lane_now) := case
        veh___649___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___649___.prev_rel_pos) := veh___649___.rel_pos;
    next(veh___649___.rel_pos) := min(max(veh___649___.rel_pos + (next(veh___649___.v) - next(ego.v)), -300), 300);

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___649___.v) := min(max(veh___649___.v + veh___649___.a, 0), max_vel);



-- >>> Car 0 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___609___.lc_timer >= leave_src_lane_earliest_after & veh___609___.lc_timer < leave_src_lane_latest_after & veh___609___.lane_single & !veh___609___.abort_lc & !next(veh___609___.abort_lc): 
        case 
            veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_max  : next(veh___609___.change_lane_now) = 0 ? veh___609___.lane_unchanged : veh___609___.lane_move_up;
            veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_min  : next(veh___609___.change_lane_now) = 0 ? veh___609___.lane_unchanged : veh___609___.lane_move_down;
            TRUE : veh___609___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___609___.lc_timer = leave_src_lane_latest_after & veh___609___.lane_single: 
        case
                veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_max : veh___609___.lane_move_up; 
                veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_min : veh___609___.lane_move_down;
                TRUE : veh___609___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___609___.lc_timer > 0 & next(veh___609___.do_lane_change) = FALSE & veh___609___.lane_crossing & !veh___609___.abort_lc & !next(veh___609___.abort_lc) : 
        case  
            veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_max : veh___609___.lane_move_up; 
            veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_min : veh___609___.lane_move_down;
            TRUE : veh___609___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___609___.lc_timer > 0 & !next(veh___609___.do_lane_change) & veh___609___.lane_crossing & veh___609___.abort_lc: 
        case
            veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_min: veh___609___.lane_move_down ;   
            veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_max: veh___609___.lane_move_up;
            TRUE : veh___609___.lane_unchanged;
        esac;
        TRUE: veh___609___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 1 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___619___.lc_timer >= leave_src_lane_earliest_after & veh___619___.lc_timer < leave_src_lane_latest_after & veh___619___.lane_single & !veh___619___.abort_lc & !next(veh___619___.abort_lc): 
        case 
            veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_max  : next(veh___619___.change_lane_now) = 0 ? veh___619___.lane_unchanged : veh___619___.lane_move_up;
            veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_min  : next(veh___619___.change_lane_now) = 0 ? veh___619___.lane_unchanged : veh___619___.lane_move_down;
            TRUE : veh___619___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___619___.lc_timer = leave_src_lane_latest_after & veh___619___.lane_single: 
        case
                veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_max : veh___619___.lane_move_up; 
                veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_min : veh___619___.lane_move_down;
                TRUE : veh___619___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___619___.lc_timer > 0 & next(veh___619___.do_lane_change) = FALSE & veh___619___.lane_crossing & !veh___619___.abort_lc & !next(veh___619___.abort_lc) : 
        case  
            veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_max : veh___619___.lane_move_up; 
            veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_min : veh___619___.lane_move_down;
            TRUE : veh___619___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___619___.lc_timer > 0 & !next(veh___619___.do_lane_change) & veh___619___.lane_crossing & veh___619___.abort_lc: 
        case
            veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_min: veh___619___.lane_move_down ;   
            veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_max: veh___619___.lane_move_up;
            TRUE : veh___619___.lane_unchanged;
        esac;
        TRUE: veh___619___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 2 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___629___.lc_timer >= leave_src_lane_earliest_after & veh___629___.lc_timer < leave_src_lane_latest_after & veh___629___.lane_single & !veh___629___.abort_lc & !next(veh___629___.abort_lc): 
        case 
            veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_max  : next(veh___629___.change_lane_now) = 0 ? veh___629___.lane_unchanged : veh___629___.lane_move_up;
            veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_min  : next(veh___629___.change_lane_now) = 0 ? veh___629___.lane_unchanged : veh___629___.lane_move_down;
            TRUE : veh___629___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___629___.lc_timer = leave_src_lane_latest_after & veh___629___.lane_single: 
        case
                veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_max : veh___629___.lane_move_up; 
                veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_min : veh___629___.lane_move_down;
                TRUE : veh___629___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___629___.lc_timer > 0 & next(veh___629___.do_lane_change) = FALSE & veh___629___.lane_crossing & !veh___629___.abort_lc & !next(veh___629___.abort_lc) : 
        case  
            veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_max : veh___629___.lane_move_up; 
            veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_min : veh___629___.lane_move_down;
            TRUE : veh___629___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___629___.lc_timer > 0 & !next(veh___629___.do_lane_change) & veh___629___.lane_crossing & veh___629___.abort_lc: 
        case
            veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_min: veh___629___.lane_move_down ;   
            veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_max: veh___629___.lane_move_up;
            TRUE : veh___629___.lane_unchanged;
        esac;
        TRUE: veh___629___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 3 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___639___.lc_timer >= leave_src_lane_earliest_after & veh___639___.lc_timer < leave_src_lane_latest_after & veh___639___.lane_single & !veh___639___.abort_lc & !next(veh___639___.abort_lc): 
        case 
            veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_max  : next(veh___639___.change_lane_now) = 0 ? veh___639___.lane_unchanged : veh___639___.lane_move_up;
            veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_min  : next(veh___639___.change_lane_now) = 0 ? veh___639___.lane_unchanged : veh___639___.lane_move_down;
            TRUE : veh___639___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___639___.lc_timer = leave_src_lane_latest_after & veh___639___.lane_single: 
        case
                veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_max : veh___639___.lane_move_up; 
                veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_min : veh___639___.lane_move_down;
                TRUE : veh___639___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___639___.lc_timer > 0 & next(veh___639___.do_lane_change) = FALSE & veh___639___.lane_crossing & !veh___639___.abort_lc & !next(veh___639___.abort_lc) : 
        case  
            veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_max : veh___639___.lane_move_up; 
            veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_min : veh___639___.lane_move_down;
            TRUE : veh___639___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___639___.lc_timer > 0 & !next(veh___639___.do_lane_change) & veh___639___.lane_crossing & veh___639___.abort_lc: 
        case
            veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_min: veh___639___.lane_move_down ;   
            veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_max: veh___639___.lane_move_up;
            TRUE : veh___639___.lane_unchanged;
        esac;
        TRUE: veh___639___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 4 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___649___.lc_timer >= leave_src_lane_earliest_after & veh___649___.lc_timer < leave_src_lane_latest_after & veh___649___.lane_single & !veh___649___.abort_lc & !next(veh___649___.abort_lc): 
        case 
            veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_max  : next(veh___649___.change_lane_now) = 0 ? veh___649___.lane_unchanged : veh___649___.lane_move_up;
            veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_min  : next(veh___649___.change_lane_now) = 0 ? veh___649___.lane_unchanged : veh___649___.lane_move_down;
            TRUE : veh___649___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___649___.lc_timer = leave_src_lane_latest_after & veh___649___.lane_single: 
        case
                veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_max : veh___649___.lane_move_up; 
                veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_min : veh___649___.lane_move_down;
                TRUE : veh___649___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___649___.lc_timer > 0 & next(veh___649___.do_lane_change) = FALSE & veh___649___.lane_crossing & !veh___649___.abort_lc & !next(veh___649___.abort_lc) : 
        case  
            veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_max : veh___649___.lane_move_up; 
            veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_min : veh___649___.lane_move_down;
            TRUE : veh___649___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___649___.lc_timer > 0 & !next(veh___649___.do_lane_change) & veh___649___.lane_crossing & veh___649___.abort_lc: 
        case
            veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_min: veh___649___.lane_move_down ;   
            veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_max: veh___649___.lane_move_up;
            TRUE : veh___649___.lane_unchanged;
        esac;
        TRUE: veh___649___.lane_unchanged;                                      -- hold current value in all other cases
    esac;
