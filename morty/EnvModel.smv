-- ============================================================================================================
-- C O P Y R I G H T
-- ------------------------------------------------------------------------------------------------------------
-- copyright (C) 2022 Robert Bosch GmbH. All rights reserved.
-- ============================================================================================================

-- This environment model has been auto-generated by vfm at: Wed Jun  4 14:18:34 2025
-- The template files have been retrieved from /home/shi7rng/workspace/ucd/very-fast-math/src/templates















-- TIMESCALING((((1.000000))))GNILACSEMIT
-- DISTANCESCALING((((1.000000))))GNILACSECNATSID
-- SCALING DESCRIPTIONS
--leave_src_lane_earliest_after,time
--leave_src_lane_latest_after,time
--complete_lane_change_earliest_after,time
--complete_lane_change_latest_after,time
--abort_lane_change_complete_earliest_after,time
--abort_lane_change_complete_latest_after,time
--min_time_between_lcs,time
--a_min,acceleration
--a_max,acceleration
--min_dist_long,distance
--veh_length,distance
--max_vel,velocity
--ego.max_vel,velocity
--params.turn_signal_duration,time
--ego.leave_src_lane_earliest_after,time
--ego.leave_src_lane_latest_after,time
--ego.complete_lane_change_earliest_after,time
--ego.complete_lane_change_latest_after,time
--ego.min_time_between_lcs,time
--max_ego_visibility_range,distance
--section_0_lane_0_availability_from_segment_1,distance
--section_0_lane_0_availability_from_segment_0,distance
--ego.lane_0_availability,distance
--section_0_lane_1_availability_from_segment_1,distance
--section_0_lane_1_availability_from_segment_0,distance
--ego.lane_1_availability,distance
--section_0_lane_2_availability_from_segment_1,distance
--section_0_lane_2_availability_from_segment_0,distance
--ego.lane_2_availability,distance
--section_0_lane_3_availability_from_segment_1,distance
--section_0_lane_3_availability_from_segment_0,distance
--ego.lane_3_availability,distance
--section_0_segment_0_pos_begin,distance
--section_0_end,distance
--veh___609___.lc_timer,time
--veh___609___.time_since_last_lc,time
--veh___609___.abs_pos,distance
--veh___609___.prev_abs_pos,distance
--veh___609___.prev_rel_pos,distance
--veh___609___.a,acceleration
--veh___609___.v,velocity
--veh___619___.lc_timer,time
--veh___619___.time_since_last_lc,time
--veh___619___.abs_pos,distance
--veh___619___.prev_abs_pos,distance
--veh___619___.prev_rel_pos,distance
--veh___619___.a,acceleration
--veh___619___.v,velocity
--veh___629___.lc_timer,time
--veh___629___.time_since_last_lc,time
--veh___629___.abs_pos,distance
--veh___629___.prev_abs_pos,distance
--veh___629___.prev_rel_pos,distance
--veh___629___.a,acceleration
--veh___629___.v,velocity
--veh___639___.lc_timer,time
--veh___639___.time_since_last_lc,time
--veh___639___.abs_pos,distance
--veh___639___.prev_abs_pos,distance
--veh___639___.prev_rel_pos,distance
--veh___639___.a,acceleration
--veh___639___.v,velocity
--veh___649___.lc_timer,time
--veh___649___.time_since_last_lc,time
--veh___649___.abs_pos,distance
--veh___649___.prev_abs_pos,distance
--veh___649___.prev_rel_pos,distance
--veh___649___.a,acceleration
--veh___649___.v,velocity
--ego.abs_pos,distance
--ego.v,velocity
-- EO SCALING DESCRIPTIONS

-- Translating TIMESCALING unit from milliseconds (old value: 1000.000000) to seconds (new value: 1.000000)
-- Translating DISTANCESCALING unit from millimeters (old value: 1000.000000) to meters (new value: 1.000000)



-- Note that the below exact formulation is used in regex for caching. 
-- Don't change...

-- Global options
-- Undeclared variable EM_LESS found during generation of EnvModel. Setting to default value false. 

-- Parametrization of road topology features
-- Found variable NUMLANES with value 4.000000 during generation of EnvModel (default would be 3).               -- Maximum number of lanes a road SEGMENT can have
-- Found variable SEGMENTS with value 1.000000 during generation of EnvModel (default would be 4).               -- Number of segments per straight road SECTION with flexible length and NUMLANES
-- Found variable SEGMENTSMINLENGTH with value 0.000000 during generation of EnvModel (default would be 30). 
-- Found variable SECTIONS with value 1.000000 during generation of EnvModel (default would be 3).               -- Number of straight road SECTIONS which form a road network
-- Found variable SECTIONSMAXLENGTH with value 10000.000000 during generation of EnvModel (default would be 150).
-- Found variable SECTIONSMINLENGTH with value 10000.000000 during generation of EnvModel (default would be 50).
-- Found variable ANGLEGRANULARITY with value 90.000000 during generation of EnvModel (default would be 45).      -- Only every n-th angle (DEG) can be used between two sections at connection points (zero degrees is straight ahead)
-- Found variable MAXOUTGOINGCONNECTIONS with value 3.000000 during generation of EnvModel (default would be 3). -- Maximum number of successors a straight road may have
-- Found variable MINDISTCONNECTIONS with value 10.000000 during generation of EnvModel (default would be 20).    -- The minimal "X" variable when going from the drain of one road to the source of a connected one
-- Found variable MAXDISTCONNECTIONS with value 20.000000 during generation of EnvModel (default would be 50).    -- The maximal "X" variable when going from the drain of one road to the source of a connected one
-- Undeclared variable MAXDISTENDPOINTS found during generation of EnvModel. Setting to default value 5.     -- Two end points must be at least this apart (approximated by maxvar method)

-- Parameters for ego and non-ego vehicles
-- Found variable EGOLESS with value 1.000000 during generation of EnvModel (default would be false).
-- Found variable NONEGOS with value 5.000000 during generation of EnvModel (default would be 5).
-- Undeclared variable LEFTLC found during generation of EnvModel. Setting to default value true. 
-- Undeclared variable RIGHTLC found during generation of EnvModel. Setting to default value false. 
-- Undeclared variable KEEPEGOFIXEDTOLANE found during generation of EnvModel. Setting to default value false. 
-- Undeclared variable VIPER found during generation of EnvModel. Setting to default value false. 
-- Undeclared variable LONGCONTROL found during generation of EnvModel. Setting to default value true. 
-- Found variable DEBUG with value 0.000000 during generation of EnvModel (default would be true).
-- Undeclared variable MAXSPEEDEGO found during generation of EnvModel. Setting to default value 34. 
-- Undeclared variable MAXSPEEDNONEGO found during generation of EnvModel. Setting to default value 70. 
-- Undeclared variable MINACCELEGO found during generation of EnvModel. Setting to default value -8. 
-- Undeclared variable MAXACCELEGO found during generation of EnvModel. Setting to default value 2. 
-- Undeclared variable MINACCELNONEGO found during generation of EnvModel. Setting to default value -8. 
-- Undeclared variable MAXACCELNONEGO found during generation of EnvModel. Setting to default value 6. 
-- Undeclared variable MAXEGOVISRANGE found during generation of EnvModel. Setting to default value 250. 
-- Undeclared variable CLOSEFRONTDIST found during generation of EnvModel. Setting to default value 10. 
-- Undeclared variable LONGDISTMAX found during generation of EnvModel. Setting to default value 300.          -- This is the max distance to the front and back of ego.
-- Undeclared variable INITPOSRANGENONEGOS found during generation of EnvModel. Setting to default value 50.   -- Range to front where non-egos can be positioned initially. (TODO: Should be replaced by length of resp. section.)
-- Undeclared variable CLOSETOEGOPAR found during generation of EnvModel. Setting to default value 80. 
-- Found variable TIMESCALING with value 1000.000000 during generation of EnvModel (default would be 1000).        -- nondimensionalization constant for time, in milliseconds
-- Found variable DISTANCESCALING with value 1000.000000 during generation of EnvModel (default would be 1000).    -- nondimensionalization constant for distance, in millimeters

-- Parameters for "skipping" of CEXs.
-- Found variable DOUBLEMERGEPROTECTION with value 0.000000 during generation of EnvModel (default would be true). -- Prohibits non-ego LCs when in danger of a double-merge
-- Found variable BRAKEINHIBITION with value 0.000000 during generation of EnvModel (default would be true).       -- Prohibits non-egos in the front gaps to brake so hard that ego could not react on it in one step.
-- Found variable HARDBRAKEPREVENTION with value -8.000000 during generation of EnvModel (default would be -8).     -- Cuts out traces with very hard decelerations. Set to MINACCELEGO to deactivate.
-- Undeclared variable STANDINGCARSUPTOID found during generation of EnvModel. Setting to default value -1. 
-- Found variable FARMERGINGCARS with value 0.000000 during generation of EnvModel (default would be false).
-- Found variable ABORTREVOKE with value 0.000000 during generation of EnvModel (default would be false).
-- Found variable KEEP_EGO_FROM_GREEN with value 1.000000 during generation of EnvModel (default would be true).   -- Makes sure, ego never leaves the lanes.
-- Found variable CALCULATE_RIGHT_GAP_REAR with value 0.000000 during generation of EnvModel (default would be true). -- Flag to leave out the rear/right gap when not needed.

-- Special purpose parameters.
-- Found variable FEASIBILITY with value 0.000000 during generation of EnvModel (default would be true). -- Includes defines needed for the ACA4.1 Fesibility study.


-- EO Don't change.

------------------------------------------------------------------------------------------------------------------
-- MATH functions on vfm level which are directly converted to SMV code without further modularizing on their side
------------------------------------------------------------------------------------------------------------------

-- The vfmacro function 'syntacticSegmentAndLineIntersect' is an implementation of this C++ code:
-- bool onSegment(Vec2D p, Vec2D q, Vec2D r) {
--    return (q.x <= std::max(p.x, r.x) && q.x >= std::min(p.x, r.x) &&
--            q.y <= std::max(p.y, r.y) && q.y >= std::min(p.y, r.y));
-- }
-- bool doesLineIntersectSegment(Vec2D L1, Vec2D L2, Vec2D M1, Vec2D M2, Image&& img) {
--    float A1 = L2.y - L1.y;
--    float B1 = L1.x - L2.x;
--    float C1 = (L2.x * L1.y) - (L1.x * L2.y);
--    float A2 = M2.y - M1.y;
--    float B2 = M1.x - M2.x;
--    float C2 = (M2.x * M1.y) - (M1.x * M2.y);
-- 
--    float denominator = A1 * B2 - A2 * B1;
-- 
--    if (denominator == 0) throw std::runtime_error("The lines are parallel and do not intersect.");
-- 
--    float x = -(B1 * (-C2) - B2 * (-C1)) / denominator;
--    float y = -(A2 * (-C1) - A1 * (-C2)) / denominator;
-- 
--    // Check if the intersection Vec2D lies on the line segment
--    return onSegment(M1, {x, y}, M2);
-- }




















--------------------
-- EO MATH functions 
--------------------


MODULE EnvModel




 -- EM-full build

VAR
   cnt : integer;
   num_lanes : integer;

INIT cnt = 0;
TRANS next(cnt) = cnt + 1;

INVAR num_lanes = 4;


------------------------------------------
--
-- Begin: Constants and common definitions
--
------------------------------------------

DEFINE
    ---------------- Begin of lc parameterization -----------------

    -- IMPORTANT: The following constraints must be satisfied such that the model works as intended:
    --      1. leave_src_lane_latest >= 1
    --      2. complete_lane_change_latest_after >= 1
    --      3. leave_src_lane_earliest_after <= leave_src_lane_latest_after
    --      4. complete_lane_change_earliest_after  <= complete_lane_change_latest_after
    --      5. leave_src_lane_latest_after <= complete_lane_change_latest_after
    --      5. abort_lane_change_complete_latest_after <= complete_lane_change_latest_after

    leave_src_lane_earliest_after := 0;             -- earliest point in time where the vehicle may cross the lane border, i.e., after this transition the vehicle occupies two lanes 
    leave_src_lane_latest_after := 0;
    complete_lane_change_earliest_after := 1;       -- earliest point in time where the vehicle is entirely on its target lane, i.e., after this transition the vehicle only occupies one lane
    complete_lane_change_latest_after := 1;
    abort_lane_change_complete_earliest_after := 1; -- earliest point in time where the vehicle is entirely back on its source lane after a lane change abort
    abort_lane_change_complete_latest_after := 3;
    min_time_between_lcs := 1;                      -- after finisihing one lc, how much time needs to pass before the next one may be started

---------------- End of lc parameterization -----------------

    a_min := -5;
    a_max := 5;
    min_dist_long := -1;                            -- the minimum distance kept by other vehicle to preceding ego, we use -1 meaning one meter behind
    veh_length := 5;                                -- we assume a vehicle length of 5m for distance calculation to the front
    max_vel := 70;

    ego.max_vel := 34; -- Leave this even in ego-less mode.



    max_ego_visibility_range := 250;                      --how far can the ego sensors see? Vehicles being further away than this cannot be detected and will not be considered

    empty_gap_indicator := -1; --Counterpart to i_FREE_LANE in Viper, could be AKA-d but for now should be fine to have twice.
--------------------------------------------------------
-- End: Constants and common definitions
--------------------------------------------------------

--------------------------------------------------------
-- Sections
--  ==> Segments
--------------------------------------------------------

   DEFINE
      large_number := 10000;

   section_0_segment_1_pos_begin := section_0_segment_0_pos_begin + large_number; -- Helper variable to make below loop simpler.
   


   section_0_lane_0_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_0_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 0 & section_0_segment_0_max_lane >= 0 : section_0_lane_0_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_0_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_0_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   section_0_lane_1_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_1_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 1 & section_0_segment_0_max_lane >= 1 : section_0_lane_1_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_1_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_1_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   section_0_lane_2_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_2_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 2 & section_0_segment_0_max_lane >= 2 : section_0_lane_2_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_2_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_2_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   section_0_lane_3_availability_from_segment_1 := 0;          -- Helper variable to make below loop simpler.
   
   section_0_lane_3_availability_from_segment_0 := case
      section_0_segment_0_min_lane <= 3 & section_0_segment_0_max_lane >= 3 : section_0_lane_3_availability_from_segment_1 + section_0_segment_1_pos_begin - section_0_segment_0_pos_begin;
      TRUE: 0;
   esac;
   
   

   ego.lane_3_availability :=
   case
   ego.on_section = 0:  
         case
            ego.abs_pos >= section_0_segment_0_pos_begin : section_0_lane_3_availability_from_segment_0 + section_0_segment_0_pos_begin - ego.abs_pos;
            TRUE: 0;
         esac;
   
   esac;
   

   INIT 0 = section_0_segment_0_pos_begin;
INIT section_0_segment_0_pos_begin < section_0_end;


INIT section_0_segment_0_max_lane >= section_0_segment_0_min_lane;
INIT section_0_segment_0_min_lane >= 0;
INIT section_0_segment_0_max_lane <= 3;


INIT section_0_segment_0_min_lane = 0 & section_0_segment_0_max_lane = 3; -- Make sure we always have a drivable lane at the start. TODO: Make flexible.


--------------------------------------------------------
--  <== EO Segments
--------------------------------------------------------

   
   FROZENVAR
         section_0_segment_0_pos_begin : integer;
            section_0_segment_0_min_lane : integer;
            section_0_segment_0_max_lane : integer;
         
   
         section_0_end : 10000 .. 10000;

         section_0.source.x : integer;
         section_0.source.y : integer;
         section_0.angle_raw : 0 .. 3;

      DEFINE 
         section_0.angle := section_0.angle_raw * 90;

      -- Lookup table to speed-up non-linear calculations (sin times 100)
      sin_of_section_0_angle := case
         section_0.angle = 0 : 0;
         section_0.angle = 90 : 100;
         section_0.angle = 180 : 0;
         section_0.angle = 270 : -100;
         
      esac;

      -- Lookup table to speed-up non-linear calculations (cos times 100)
      cos_of_section_0_angle := case
         section_0.angle = 0 : 100;
         section_0.angle = 90 : 0;
         section_0.angle = 180 : -100;
         section_0.angle = 270 : -0;
         
      esac;

      section_0.drain.x := section_0.source.x + (section_0_end * cos_of_section_0_angle) / 100;
      section_0.drain.y := section_0.source.y + (section_0_end * sin_of_section_0_angle) / 100;
 
      -- INIT outgoing_connection_0_of_section_0 != outgoing_connection_1_of_section_0; -- If we want to have at least one outgoing connection for all roads.

         FROZENVAR outgoing_connection_0_of_section_0 : -1..0;
            INIT outgoing_connection_0_of_section_0 != 0; -- Don't connect to self.

            
            
         FROZENVAR outgoing_connection_1_of_section_0 : -1..0;
            INIT outgoing_connection_1_of_section_0 != 0; -- Don't connect to self.

            
            
         FROZENVAR outgoing_connection_2_of_section_0 : -1..0;
            INIT outgoing_connection_2_of_section_0 != 0; -- Don't connect to self.

            
            
          -- Several elements can be equal, so we have at least 1 and at most 3 outgoing connections.

         

      

      
      
   

   -- Section 0 always starts at (0/0) and goes horizontally to the right.
   INIT section_0.source.x = 0;
   INIT section_0.source.y = 0;
   -- INIT section_0.drain.x ==> Not specified, so the length of the section is figured out from the length of the segments.
   INIT section_0.angle = 0;

VAR    
   ego.on_section : 0 .. 0;

INIT ego.on_section = 0;

--------------------------------------------------------
-- EO Sections
--------------------------------------------------------

--------------------------------------------------------
--
-- Begin: Non-ego Spec (generate once per non-ego Vehicle)
--
--------------------------------------------------------


   VAR
      ego.a : 0..0;  -- Mock EGO interface...

	-- >>> Car 0 <<<
VAR
    veh___609___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___609___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___609___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___609___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___609___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___609___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___609___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___609___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___609___.prev_abs_pos : integer;
    veh___609___.prev_rel_pos : integer;
    veh___609___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___609___.v : integer;

    veh___609___.lane_b0 : boolean;
    veh___609___.lane_b1 : boolean;
    veh___609___.lane_b2 : boolean;
    veh___609___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___609___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___609___.on_straight_section : -1 .. 0;
      veh___609___.traversion_from : -1 .. 0;
      veh___609___.traversion_to : -1 .. 0;

      INVAR veh___609___.on_straight_section = -1 -> (veh___609___.traversion_from != -1 & veh___609___.traversion_from != -1);
      INVAR (veh___609___.traversion_from != -1 | veh___609___.traversion_from != -1) -> veh___609___.on_straight_section = -1;
      INVAR veh___609___.traversion_from = -1 <-> veh___609___.traversion_to = -1;

      VAR veh___609___.is_on_sec_0 : 0..1;
         INVAR (veh___609___.is_on_sec_0 = 1) <-> (veh___609___.on_straight_section = 0);
         
         
      

	-- >>> Car 1 <<<
VAR
    veh___619___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___619___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___619___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___619___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___619___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___619___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___619___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___619___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___619___.prev_abs_pos : integer;
    veh___619___.prev_rel_pos : integer;
    veh___619___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___619___.v : integer;

    veh___619___.lane_b0 : boolean;
    veh___619___.lane_b1 : boolean;
    veh___619___.lane_b2 : boolean;
    veh___619___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___619___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___619___.on_straight_section : -1 .. 0;
      veh___619___.traversion_from : -1 .. 0;
      veh___619___.traversion_to : -1 .. 0;

      INVAR veh___619___.on_straight_section = -1 -> (veh___619___.traversion_from != -1 & veh___619___.traversion_from != -1);
      INVAR (veh___619___.traversion_from != -1 | veh___619___.traversion_from != -1) -> veh___619___.on_straight_section = -1;
      INVAR veh___619___.traversion_from = -1 <-> veh___619___.traversion_to = -1;

      VAR veh___619___.is_on_sec_0 : 0..1;
         INVAR (veh___619___.is_on_sec_0 = 1) <-> (veh___619___.on_straight_section = 0);
         
         
      

	-- >>> Car 2 <<<
VAR
    veh___629___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___629___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___629___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___629___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___629___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___629___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___629___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___629___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___629___.prev_abs_pos : integer;
    veh___629___.prev_rel_pos : integer;
    veh___629___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___629___.v : integer;

    veh___629___.lane_b0 : boolean;
    veh___629___.lane_b1 : boolean;
    veh___629___.lane_b2 : boolean;
    veh___629___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___629___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___629___.on_straight_section : -1 .. 0;
      veh___629___.traversion_from : -1 .. 0;
      veh___629___.traversion_to : -1 .. 0;

      INVAR veh___629___.on_straight_section = -1 -> (veh___629___.traversion_from != -1 & veh___629___.traversion_from != -1);
      INVAR (veh___629___.traversion_from != -1 | veh___629___.traversion_from != -1) -> veh___629___.on_straight_section = -1;
      INVAR veh___629___.traversion_from = -1 <-> veh___629___.traversion_to = -1;

      VAR veh___629___.is_on_sec_0 : 0..1;
         INVAR (veh___629___.is_on_sec_0 = 1) <-> (veh___629___.on_straight_section = 0);
         
         
      

	-- >>> Car 3 <<<
VAR
    veh___639___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___639___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___639___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___639___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___639___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___639___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___639___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___639___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___639___.prev_abs_pos : integer;
    veh___639___.prev_rel_pos : integer;
    veh___639___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___639___.v : integer;

    veh___639___.lane_b0 : boolean;
    veh___639___.lane_b1 : boolean;
    veh___639___.lane_b2 : boolean;
    veh___639___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___639___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___639___.on_straight_section : -1 .. 0;
      veh___639___.traversion_from : -1 .. 0;
      veh___639___.traversion_to : -1 .. 0;

      INVAR veh___639___.on_straight_section = -1 -> (veh___639___.traversion_from != -1 & veh___639___.traversion_from != -1);
      INVAR (veh___639___.traversion_from != -1 | veh___639___.traversion_from != -1) -> veh___639___.on_straight_section = -1;
      INVAR veh___639___.traversion_from = -1 <-> veh___639___.traversion_to = -1;

      VAR veh___639___.is_on_sec_0 : 0..1;
         INVAR (veh___639___.is_on_sec_0 = 1) <-> (veh___639___.on_straight_section = 0);
         
         
      

	-- >>> Car 4 <<<
VAR
    veh___649___.do_lane_change : boolean;                   -- signal that a lane change is ongoing
    veh___649___.abort_lc : boolean;                         -- signal that an ongoing lane change is aborted
    veh___649___.lc_direction : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the lane change takes place
    veh___649___.turn_signals : {ActionDir____LEFT, ActionDir____CENTER, ActionDir____RIGHT};         -- the direction in which the turn signals are set
    veh___649___.lc_timer : -1..complete_lane_change_latest_after;     -- timer such that the lc does eventually finish
    veh___649___.time_since_last_lc : -1..min_time_between_lcs;        -- enough time has expired since the last lc happened
    veh___649___.change_lane_now : 0..1;                     -- variable for the non-deterministic choice whether we now change the lane

    veh___649___.abs_pos : integer; -- absolute position on current section (invalid if in between sections)
    veh___649___.prev_abs_pos : integer;
    veh___649___.prev_rel_pos : integer;
    veh___649___.a : integer;    -- accel in m/s^2, (assume positive accel up to 6m/s^2, which is already a highly tuned sports car)
    veh___649___.v : integer;

    veh___649___.lane_b0 : boolean;
    veh___649___.lane_b1 : boolean;
    veh___649___.lane_b2 : boolean;
    veh___649___.lane_b3 : boolean;
    

    -- auxialiary variables required for property evaluation
    veh___649___.lc_leave_src_lane : boolean; -- probably superfluous meanwhile

    -- TODO: Assigning sections to cars MIGHT be more efficient the other way around,
    -- i.e., having logic for the three integer variables and calculating the bools from that.
     
      veh___649___.on_straight_section : -1 .. 0;
      veh___649___.traversion_from : -1 .. 0;
      veh___649___.traversion_to : -1 .. 0;

      INVAR veh___649___.on_straight_section = -1 -> (veh___649___.traversion_from != -1 & veh___649___.traversion_from != -1);
      INVAR (veh___649___.traversion_from != -1 | veh___649___.traversion_from != -1) -> veh___649___.on_straight_section = -1;
      INVAR veh___649___.traversion_from = -1 <-> veh___649___.traversion_to = -1;

      VAR veh___649___.is_on_sec_0 : 0..1;
         INVAR (veh___649___.is_on_sec_0 = 1) <-> (veh___649___.on_straight_section = 0);
         
         
      

	

   
   INVAR veh___609___.is_on_sec_0
       = 1;

	INVAR veh___619___.is_on_sec_0
       = 1;

	INVAR veh___629___.is_on_sec_0
       = 1;

	INVAR veh___639___.is_on_sec_0
       = 1;

	INVAR veh___649___.is_on_sec_0
       = 1;

	


DEFINE

-- Make sure non-egos do not drive on the GREEN.
veh___609___.on_lane_min := case
   veh___609___.lane_b0 : 0;
   veh___609___.lane_b1 : 1;
   veh___609___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___619___.on_lane_min := case
   veh___619___.lane_b0 : 0;
   veh___619___.lane_b1 : 1;
   veh___619___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___629___.on_lane_min := case
   veh___629___.lane_b0 : 0;
   veh___629___.lane_b1 : 1;
   veh___629___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___639___.on_lane_min := case
   veh___639___.lane_b0 : 0;
   veh___639___.lane_b1 : 1;
   veh___639___.lane_b2 : 2;
   TRUE : 3;
esac;

veh___649___.on_lane_min := case
   veh___649___.lane_b0 : 0;
   veh___649___.lane_b1 : 1;
   veh___649___.lane_b2 : 2;
   TRUE : 3;
esac;


veh___609___.on_lane_max := case
   veh___609___.lane_b3 : 3;
   veh___609___.lane_b2 : 2;
   veh___609___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___619___.on_lane_max := case
   veh___619___.lane_b3 : 3;
   veh___619___.lane_b2 : 2;
   veh___619___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___629___.on_lane_max := case
   veh___629___.lane_b3 : 3;
   veh___629___.lane_b2 : 2;
   veh___629___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___639___.on_lane_max := case
   veh___639___.lane_b3 : 3;
   veh___639___.lane_b2 : 2;
   veh___639___.lane_b1 : 1;
   TRUE : 0;
esac;

veh___649___.on_lane_max := case
   veh___649___.lane_b3 : 3;
   veh___649___.lane_b2 : 2;
   veh___649___.lane_b1 : 1;
   TRUE : 0;
esac;







INVAR (veh___609___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___609___.on_lane_min >= section_0_segment_0_min_lane & veh___609___.on_lane_max <= section_0_segment_0_max_lane);

   

   INVAR (veh___609___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___609___.on_lane_min >= section_0_segment_0_min_lane & veh___609___.on_lane_max <= section_0_segment_0_max_lane);

INVAR (veh___619___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___619___.on_lane_min >= section_0_segment_0_min_lane & veh___619___.on_lane_max <= section_0_segment_0_max_lane);

   

   INVAR (veh___619___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___619___.on_lane_min >= section_0_segment_0_min_lane & veh___619___.on_lane_max <= section_0_segment_0_max_lane);

INVAR (veh___629___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___629___.on_lane_min >= section_0_segment_0_min_lane & veh___629___.on_lane_max <= section_0_segment_0_max_lane);

   

   INVAR (veh___629___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___629___.on_lane_min >= section_0_segment_0_min_lane & veh___629___.on_lane_max <= section_0_segment_0_max_lane);

INVAR (veh___639___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___639___.on_lane_min >= section_0_segment_0_min_lane & veh___639___.on_lane_max <= section_0_segment_0_max_lane);

   

   INVAR (veh___639___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___639___.on_lane_min >= section_0_segment_0_min_lane & veh___639___.on_lane_max <= section_0_segment_0_max_lane);

INVAR (veh___649___.abs_pos < section_0_segment_0_pos_begin) -> 
   (veh___649___.on_lane_min >= section_0_segment_0_min_lane & veh___649___.on_lane_max <= section_0_segment_0_max_lane);

   

   INVAR (veh___649___.abs_pos >= section_0_segment_0_pos_begin) -> 
   (veh___649___.on_lane_min >= section_0_segment_0_min_lane & veh___649___.on_lane_max <= section_0_segment_0_max_lane);



DEFINE

	-- >>> Car 0 <<<
    veh___609___.lane_0 := veh___609___.lane_b0 & !veh___609___.lane_b1& !veh___609___.lane_b2& !veh___609___.lane_b3;
    veh___609___.lane_01 := veh___609___.lane_b0 &veh___609___.lane_b1 &!veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_1 := !veh___609___.lane_b0 &veh___609___.lane_b1 &!veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_12 := !veh___609___.lane_b0 &veh___609___.lane_b1 &veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_2 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &veh___609___.lane_b2 &!veh___609___.lane_b3 ;
    veh___609___.lane_23 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &veh___609___.lane_b2 &veh___609___.lane_b3 ;
    veh___609___.lane_3 := !veh___609___.lane_b0 &!veh___609___.lane_b1 &!veh___609___.lane_b2 &veh___609___.lane_b3 ;
    

    veh___609___.lane_min := veh___609___.lane_0;
    veh___609___.lane_max := veh___609___.lane_3;
    veh___609___.lane_single := veh___609___.lane_0 |veh___609___.lane_1 |veh___609___.lane_2 |veh___609___.lane_3 ;
    veh___609___.lane_crossing := FALSE | veh___609___.lane_01| veh___609___.lane_12| veh___609___.lane_23;
    veh___609___.lane_unchanged := veh___609___.lane_b0 = next(veh___609___.lane_b0)&veh___609___.lane_b1 = next(veh___609___.lane_b1)&veh___609___.lane_b2 = next(veh___609___.lane_b2)&veh___609___.lane_b3 = next(veh___609___.lane_b3);
    veh___609___.lane_move_down := 
                      (veh___609___.lane_0 -> next(veh___609___.lane_0))
                      & (veh___609___.lane_01 -> next(veh___609___.lane_0))
                      & (veh___609___.lane_1 -> next(veh___609___.lane_01))
                      & (veh___609___.lane_12 -> next(veh___609___.lane_1))
                      & (veh___609___.lane_2 -> next(veh___609___.lane_12))
                      & (veh___609___.lane_23 -> next(veh___609___.lane_2))
                      & (veh___609___.lane_3 -> next(veh___609___.lane_23))
                      ;
    veh___609___.lane_move_up :=
                      (veh___609___.lane_3 -> next(veh___609___.lane_3))
                      & (veh___609___.lane_01 -> next(veh___609___.lane_1))
                      & (veh___609___.lane_0 -> next(veh___609___.lane_01))
                      & (veh___609___.lane_12 -> next(veh___609___.lane_2))
                      & (veh___609___.lane_1 -> next(veh___609___.lane_12))
                      & (veh___609___.lane_23 -> next(veh___609___.lane_3))
                      & (veh___609___.lane_2 -> next(veh___609___.lane_23))
                      ;


   
   
	
	
	-- >>> Car 1 <<<
    veh___619___.lane_0 := veh___619___.lane_b0 & !veh___619___.lane_b1& !veh___619___.lane_b2& !veh___619___.lane_b3;
    veh___619___.lane_01 := veh___619___.lane_b0 &veh___619___.lane_b1 &!veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_1 := !veh___619___.lane_b0 &veh___619___.lane_b1 &!veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_12 := !veh___619___.lane_b0 &veh___619___.lane_b1 &veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_2 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &veh___619___.lane_b2 &!veh___619___.lane_b3 ;
    veh___619___.lane_23 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &veh___619___.lane_b2 &veh___619___.lane_b3 ;
    veh___619___.lane_3 := !veh___619___.lane_b0 &!veh___619___.lane_b1 &!veh___619___.lane_b2 &veh___619___.lane_b3 ;
    

    veh___619___.lane_min := veh___619___.lane_0;
    veh___619___.lane_max := veh___619___.lane_3;
    veh___619___.lane_single := veh___619___.lane_0 |veh___619___.lane_1 |veh___619___.lane_2 |veh___619___.lane_3 ;
    veh___619___.lane_crossing := FALSE | veh___619___.lane_01| veh___619___.lane_12| veh___619___.lane_23;
    veh___619___.lane_unchanged := veh___619___.lane_b0 = next(veh___619___.lane_b0)&veh___619___.lane_b1 = next(veh___619___.lane_b1)&veh___619___.lane_b2 = next(veh___619___.lane_b2)&veh___619___.lane_b3 = next(veh___619___.lane_b3);
    veh___619___.lane_move_down := 
                      (veh___619___.lane_0 -> next(veh___619___.lane_0))
                      & (veh___619___.lane_01 -> next(veh___619___.lane_0))
                      & (veh___619___.lane_1 -> next(veh___619___.lane_01))
                      & (veh___619___.lane_12 -> next(veh___619___.lane_1))
                      & (veh___619___.lane_2 -> next(veh___619___.lane_12))
                      & (veh___619___.lane_23 -> next(veh___619___.lane_2))
                      & (veh___619___.lane_3 -> next(veh___619___.lane_23))
                      ;
    veh___619___.lane_move_up :=
                      (veh___619___.lane_3 -> next(veh___619___.lane_3))
                      & (veh___619___.lane_01 -> next(veh___619___.lane_1))
                      & (veh___619___.lane_0 -> next(veh___619___.lane_01))
                      & (veh___619___.lane_12 -> next(veh___619___.lane_2))
                      & (veh___619___.lane_1 -> next(veh___619___.lane_12))
                      & (veh___619___.lane_23 -> next(veh___619___.lane_3))
                      & (veh___619___.lane_2 -> next(veh___619___.lane_23))
                      ;


   
   
	veh___619___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___619___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___619___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___619___.lane_b2) & !(veh___609___.lane_b2 & veh___619___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___619___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___619___.lane_b3) & !(veh___609___.lane_b3 & veh___619___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___619___.lane_b3) ) --   )
      
   );
   
	
	-- >>> Car 2 <<<
    veh___629___.lane_0 := veh___629___.lane_b0 & !veh___629___.lane_b1& !veh___629___.lane_b2& !veh___629___.lane_b3;
    veh___629___.lane_01 := veh___629___.lane_b0 &veh___629___.lane_b1 &!veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_1 := !veh___629___.lane_b0 &veh___629___.lane_b1 &!veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_12 := !veh___629___.lane_b0 &veh___629___.lane_b1 &veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_2 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &veh___629___.lane_b2 &!veh___629___.lane_b3 ;
    veh___629___.lane_23 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &veh___629___.lane_b2 &veh___629___.lane_b3 ;
    veh___629___.lane_3 := !veh___629___.lane_b0 &!veh___629___.lane_b1 &!veh___629___.lane_b2 &veh___629___.lane_b3 ;
    

    veh___629___.lane_min := veh___629___.lane_0;
    veh___629___.lane_max := veh___629___.lane_3;
    veh___629___.lane_single := veh___629___.lane_0 |veh___629___.lane_1 |veh___629___.lane_2 |veh___629___.lane_3 ;
    veh___629___.lane_crossing := FALSE | veh___629___.lane_01| veh___629___.lane_12| veh___629___.lane_23;
    veh___629___.lane_unchanged := veh___629___.lane_b0 = next(veh___629___.lane_b0)&veh___629___.lane_b1 = next(veh___629___.lane_b1)&veh___629___.lane_b2 = next(veh___629___.lane_b2)&veh___629___.lane_b3 = next(veh___629___.lane_b3);
    veh___629___.lane_move_down := 
                      (veh___629___.lane_0 -> next(veh___629___.lane_0))
                      & (veh___629___.lane_01 -> next(veh___629___.lane_0))
                      & (veh___629___.lane_1 -> next(veh___629___.lane_01))
                      & (veh___629___.lane_12 -> next(veh___629___.lane_1))
                      & (veh___629___.lane_2 -> next(veh___629___.lane_12))
                      & (veh___629___.lane_23 -> next(veh___629___.lane_2))
                      & (veh___629___.lane_3 -> next(veh___629___.lane_23))
                      ;
    veh___629___.lane_move_up :=
                      (veh___629___.lane_3 -> next(veh___629___.lane_3))
                      & (veh___629___.lane_01 -> next(veh___629___.lane_1))
                      & (veh___629___.lane_0 -> next(veh___629___.lane_01))
                      & (veh___629___.lane_12 -> next(veh___629___.lane_2))
                      & (veh___629___.lane_1 -> next(veh___629___.lane_12))
                      & (veh___629___.lane_23 -> next(veh___629___.lane_3))
                      & (veh___629___.lane_2 -> next(veh___629___.lane_23))
                      ;


   
   
	veh___629___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___629___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___629___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___629___.lane_b2) & !(veh___609___.lane_b2 & veh___629___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___629___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___629___.lane_b3) & !(veh___609___.lane_b3 & veh___629___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___629___.lane_b3) ) --   )
      
   );
   veh___629___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___629___.lane_b0) ) --   )
      | ((veh___619___.lane_b1 & veh___629___.lane_b1) ) --  & !(veh___619___.lane_b0 & veh___629___.lane_b2) & !(veh___619___.lane_b2 & veh___629___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___629___.lane_b2) ) --  & !(veh___619___.lane_b1 & veh___629___.lane_b3) & !(veh___619___.lane_b3 & veh___629___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___629___.lane_b3) ) --   )
      
   );
   
	
	-- >>> Car 3 <<<
    veh___639___.lane_0 := veh___639___.lane_b0 & !veh___639___.lane_b1& !veh___639___.lane_b2& !veh___639___.lane_b3;
    veh___639___.lane_01 := veh___639___.lane_b0 &veh___639___.lane_b1 &!veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_1 := !veh___639___.lane_b0 &veh___639___.lane_b1 &!veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_12 := !veh___639___.lane_b0 &veh___639___.lane_b1 &veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_2 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &veh___639___.lane_b2 &!veh___639___.lane_b3 ;
    veh___639___.lane_23 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &veh___639___.lane_b2 &veh___639___.lane_b3 ;
    veh___639___.lane_3 := !veh___639___.lane_b0 &!veh___639___.lane_b1 &!veh___639___.lane_b2 &veh___639___.lane_b3 ;
    

    veh___639___.lane_min := veh___639___.lane_0;
    veh___639___.lane_max := veh___639___.lane_3;
    veh___639___.lane_single := veh___639___.lane_0 |veh___639___.lane_1 |veh___639___.lane_2 |veh___639___.lane_3 ;
    veh___639___.lane_crossing := FALSE | veh___639___.lane_01| veh___639___.lane_12| veh___639___.lane_23;
    veh___639___.lane_unchanged := veh___639___.lane_b0 = next(veh___639___.lane_b0)&veh___639___.lane_b1 = next(veh___639___.lane_b1)&veh___639___.lane_b2 = next(veh___639___.lane_b2)&veh___639___.lane_b3 = next(veh___639___.lane_b3);
    veh___639___.lane_move_down := 
                      (veh___639___.lane_0 -> next(veh___639___.lane_0))
                      & (veh___639___.lane_01 -> next(veh___639___.lane_0))
                      & (veh___639___.lane_1 -> next(veh___639___.lane_01))
                      & (veh___639___.lane_12 -> next(veh___639___.lane_1))
                      & (veh___639___.lane_2 -> next(veh___639___.lane_12))
                      & (veh___639___.lane_23 -> next(veh___639___.lane_2))
                      & (veh___639___.lane_3 -> next(veh___639___.lane_23))
                      ;
    veh___639___.lane_move_up :=
                      (veh___639___.lane_3 -> next(veh___639___.lane_3))
                      & (veh___639___.lane_01 -> next(veh___639___.lane_1))
                      & (veh___639___.lane_0 -> next(veh___639___.lane_01))
                      & (veh___639___.lane_12 -> next(veh___639___.lane_2))
                      & (veh___639___.lane_1 -> next(veh___639___.lane_12))
                      & (veh___639___.lane_23 -> next(veh___639___.lane_3))
                      & (veh___639___.lane_2 -> next(veh___639___.lane_23))
                      ;


   
   
	veh___639___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___639___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___639___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___639___.lane_b2) & !(veh___609___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___639___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___639___.lane_b3) & !(veh___609___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___639___.lane_b3) ) --   )
      
   );
   veh___639___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___639___.lane_b0) ) --   )
      | ((veh___619___.lane_b1 & veh___639___.lane_b1) ) --  & !(veh___619___.lane_b0 & veh___639___.lane_b2) & !(veh___619___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___639___.lane_b2) ) --  & !(veh___619___.lane_b1 & veh___639___.lane_b3) & !(veh___619___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___639___.lane_b3) ) --   )
      
   );
   veh___639___.same_lane_as_veh_2 := (FALSE
      | ((veh___629___.lane_b0 & veh___639___.lane_b0) ) --   )
      | ((veh___629___.lane_b1 & veh___639___.lane_b1) ) --  & !(veh___629___.lane_b0 & veh___639___.lane_b2) & !(veh___629___.lane_b2 & veh___639___.lane_b0) )
      | ((veh___629___.lane_b2 & veh___639___.lane_b2) ) --  & !(veh___629___.lane_b1 & veh___639___.lane_b3) & !(veh___629___.lane_b3 & veh___639___.lane_b1) )
      | ((veh___629___.lane_b3 & veh___639___.lane_b3) ) --   )
      
   );
   
	
	-- >>> Car 4 <<<
    veh___649___.lane_0 := veh___649___.lane_b0 & !veh___649___.lane_b1& !veh___649___.lane_b2& !veh___649___.lane_b3;
    veh___649___.lane_01 := veh___649___.lane_b0 &veh___649___.lane_b1 &!veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_1 := !veh___649___.lane_b0 &veh___649___.lane_b1 &!veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_12 := !veh___649___.lane_b0 &veh___649___.lane_b1 &veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_2 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &veh___649___.lane_b2 &!veh___649___.lane_b3 ;
    veh___649___.lane_23 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &veh___649___.lane_b2 &veh___649___.lane_b3 ;
    veh___649___.lane_3 := !veh___649___.lane_b0 &!veh___649___.lane_b1 &!veh___649___.lane_b2 &veh___649___.lane_b3 ;
    

    veh___649___.lane_min := veh___649___.lane_0;
    veh___649___.lane_max := veh___649___.lane_3;
    veh___649___.lane_single := veh___649___.lane_0 |veh___649___.lane_1 |veh___649___.lane_2 |veh___649___.lane_3 ;
    veh___649___.lane_crossing := FALSE | veh___649___.lane_01| veh___649___.lane_12| veh___649___.lane_23;
    veh___649___.lane_unchanged := veh___649___.lane_b0 = next(veh___649___.lane_b0)&veh___649___.lane_b1 = next(veh___649___.lane_b1)&veh___649___.lane_b2 = next(veh___649___.lane_b2)&veh___649___.lane_b3 = next(veh___649___.lane_b3);
    veh___649___.lane_move_down := 
                      (veh___649___.lane_0 -> next(veh___649___.lane_0))
                      & (veh___649___.lane_01 -> next(veh___649___.lane_0))
                      & (veh___649___.lane_1 -> next(veh___649___.lane_01))
                      & (veh___649___.lane_12 -> next(veh___649___.lane_1))
                      & (veh___649___.lane_2 -> next(veh___649___.lane_12))
                      & (veh___649___.lane_23 -> next(veh___649___.lane_2))
                      & (veh___649___.lane_3 -> next(veh___649___.lane_23))
                      ;
    veh___649___.lane_move_up :=
                      (veh___649___.lane_3 -> next(veh___649___.lane_3))
                      & (veh___649___.lane_01 -> next(veh___649___.lane_1))
                      & (veh___649___.lane_0 -> next(veh___649___.lane_01))
                      & (veh___649___.lane_12 -> next(veh___649___.lane_2))
                      & (veh___649___.lane_1 -> next(veh___649___.lane_12))
                      & (veh___649___.lane_23 -> next(veh___649___.lane_3))
                      & (veh___649___.lane_2 -> next(veh___649___.lane_23))
                      ;


   
   
	veh___649___.same_lane_as_veh_0 := (FALSE
      | ((veh___609___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___609___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___609___.lane_b0 & veh___649___.lane_b2) & !(veh___609___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___609___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___609___.lane_b1 & veh___649___.lane_b3) & !(veh___609___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___609___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   veh___649___.same_lane_as_veh_1 := (FALSE
      | ((veh___619___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___619___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___619___.lane_b0 & veh___649___.lane_b2) & !(veh___619___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___619___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___619___.lane_b1 & veh___649___.lane_b3) & !(veh___619___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___619___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   veh___649___.same_lane_as_veh_2 := (FALSE
      | ((veh___629___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___629___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___629___.lane_b0 & veh___649___.lane_b2) & !(veh___629___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___629___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___629___.lane_b1 & veh___649___.lane_b3) & !(veh___629___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___629___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   veh___649___.same_lane_as_veh_3 := (FALSE
      | ((veh___639___.lane_b0 & veh___649___.lane_b0) ) --   )
      | ((veh___639___.lane_b1 & veh___649___.lane_b1) ) --  & !(veh___639___.lane_b0 & veh___649___.lane_b2) & !(veh___639___.lane_b2 & veh___649___.lane_b0) )
      | ((veh___639___.lane_b2 & veh___649___.lane_b2) ) --  & !(veh___639___.lane_b1 & veh___649___.lane_b3) & !(veh___639___.lane_b3 & veh___649___.lane_b1) )
      | ((veh___639___.lane_b3 & veh___649___.lane_b3) ) --   )
      
   );
   
	
	


-- >>> Car 0 <<<


DEFINE
   veh___609___.rel_pos := veh___609___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___609___.next_abs_pos := veh___609___.abs_pos + next(veh___609___.v);

INVAR
    veh___609___.lane_single | veh___609___.lane_crossing;

INVAR
    (max(-veh___609___.v, a_min) <= veh___609___.a & veh___609___.a <= a_max) &
    (0 <= veh___609___.v & veh___609___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_0 := case
   veh___609___.v = 0 : 0;
   veh___609___.v = 1 : 1;
   veh___609___.v = 2 : 4;
   veh___609___.v = 3 : 9;
   veh___609___.v = 4 : 16;
   veh___609___.v = 5 : 25;
   veh___609___.v = 6 : 36;
   veh___609___.v = 7 : 49;
   veh___609___.v = 8 : 64;
   veh___609___.v = 9 : 81;
   veh___609___.v = 10 : 100;
   veh___609___.v = 11 : 121;
   veh___609___.v = 12 : 144;
   veh___609___.v = 13 : 169;
   veh___609___.v = 14 : 196;
   veh___609___.v = 15 : 225;
   veh___609___.v = 16 : 256;
   veh___609___.v = 17 : 289;
   veh___609___.v = 18 : 324;
   veh___609___.v = 19 : 361;
   veh___609___.v = 20 : 400;
   veh___609___.v = 21 : 441;
   veh___609___.v = 22 : 484;
   veh___609___.v = 23 : 529;
   veh___609___.v = 24 : 576;
   veh___609___.v = 25 : 625;
   veh___609___.v = 26 : 676;
   veh___609___.v = 27 : 729;
   veh___609___.v = 28 : 784;
   veh___609___.v = 29 : 841;
   veh___609___.v = 30 : 900;
   veh___609___.v = 31 : 961;
   veh___609___.v = 32 : 1024;
   veh___609___.v = 33 : 1089;
   veh___609___.v = 34 : 1156;
   veh___609___.v = 35 : 1225;
   veh___609___.v = 36 : 1296;
   veh___609___.v = 37 : 1369;
   veh___609___.v = 38 : 1444;
   veh___609___.v = 39 : 1521;
   veh___609___.v = 40 : 1600;
   veh___609___.v = 41 : 1681;
   veh___609___.v = 42 : 1764;
   veh___609___.v = 43 : 1849;
   veh___609___.v = 44 : 1936;
   veh___609___.v = 45 : 2025;
   veh___609___.v = 46 : 2116;
   veh___609___.v = 47 : 2209;
   veh___609___.v = 48 : 2304;
   veh___609___.v = 49 : 2401;
   veh___609___.v = 50 : 2500;
   veh___609___.v = 51 : 2601;
   veh___609___.v = 52 : 2704;
   veh___609___.v = 53 : 2809;
   veh___609___.v = 54 : 2916;
   veh___609___.v = 55 : 3025;
   veh___609___.v = 56 : 3136;
   veh___609___.v = 57 : 3249;
   veh___609___.v = 58 : 3364;
   veh___609___.v = 59 : 3481;
   veh___609___.v = 60 : 3600;
   veh___609___.v = 61 : 3721;
   veh___609___.v = 62 : 3844;
   veh___609___.v = 63 : 3969;
   veh___609___.v = 64 : 4096;
   veh___609___.v = 65 : 4225;
   veh___609___.v = 66 : 4356;
   veh___609___.v = 67 : 4489;
   veh___609___.v = 68 : 4624;
   veh___609___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

-- >>> Car 1 <<<


DEFINE
   veh___619___.rel_pos := veh___619___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___619___.next_abs_pos := veh___619___.abs_pos + next(veh___619___.v);

INVAR
    veh___619___.lane_single | veh___619___.lane_crossing;

INVAR
    (max(-veh___619___.v, a_min) <= veh___619___.a & veh___619___.a <= a_max) &
    (0 <= veh___619___.v & veh___619___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_1 := case
   veh___619___.v = 0 : 0;
   veh___619___.v = 1 : 1;
   veh___619___.v = 2 : 4;
   veh___619___.v = 3 : 9;
   veh___619___.v = 4 : 16;
   veh___619___.v = 5 : 25;
   veh___619___.v = 6 : 36;
   veh___619___.v = 7 : 49;
   veh___619___.v = 8 : 64;
   veh___619___.v = 9 : 81;
   veh___619___.v = 10 : 100;
   veh___619___.v = 11 : 121;
   veh___619___.v = 12 : 144;
   veh___619___.v = 13 : 169;
   veh___619___.v = 14 : 196;
   veh___619___.v = 15 : 225;
   veh___619___.v = 16 : 256;
   veh___619___.v = 17 : 289;
   veh___619___.v = 18 : 324;
   veh___619___.v = 19 : 361;
   veh___619___.v = 20 : 400;
   veh___619___.v = 21 : 441;
   veh___619___.v = 22 : 484;
   veh___619___.v = 23 : 529;
   veh___619___.v = 24 : 576;
   veh___619___.v = 25 : 625;
   veh___619___.v = 26 : 676;
   veh___619___.v = 27 : 729;
   veh___619___.v = 28 : 784;
   veh___619___.v = 29 : 841;
   veh___619___.v = 30 : 900;
   veh___619___.v = 31 : 961;
   veh___619___.v = 32 : 1024;
   veh___619___.v = 33 : 1089;
   veh___619___.v = 34 : 1156;
   veh___619___.v = 35 : 1225;
   veh___619___.v = 36 : 1296;
   veh___619___.v = 37 : 1369;
   veh___619___.v = 38 : 1444;
   veh___619___.v = 39 : 1521;
   veh___619___.v = 40 : 1600;
   veh___619___.v = 41 : 1681;
   veh___619___.v = 42 : 1764;
   veh___619___.v = 43 : 1849;
   veh___619___.v = 44 : 1936;
   veh___619___.v = 45 : 2025;
   veh___619___.v = 46 : 2116;
   veh___619___.v = 47 : 2209;
   veh___619___.v = 48 : 2304;
   veh___619___.v = 49 : 2401;
   veh___619___.v = 50 : 2500;
   veh___619___.v = 51 : 2601;
   veh___619___.v = 52 : 2704;
   veh___619___.v = 53 : 2809;
   veh___619___.v = 54 : 2916;
   veh___619___.v = 55 : 3025;
   veh___619___.v = 56 : 3136;
   veh___619___.v = 57 : 3249;
   veh___619___.v = 58 : 3364;
   veh___619___.v = 59 : 3481;
   veh___619___.v = 60 : 3600;
   veh___619___.v = 61 : 3721;
   veh___619___.v = 62 : 3844;
   veh___619___.v = 63 : 3969;
   veh___619___.v = 64 : 4096;
   veh___619___.v = 65 : 4225;
   veh___619___.v = 66 : 4356;
   veh___619___.v = 67 : 4489;
   veh___619___.v = 68 : 4624;
   veh___619___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_1_and_veh_0_on_same_seclet := 
veh___619___.on_straight_section = veh___609___.on_straight_section & veh___619___.traversion_from = veh___609___.traversion_from & veh___619___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_1_and_veh_0_on_same_seclet -> (veh___619___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___619___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_1_and_veh_0_on_same_seclet -> (
       !(veh___619___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___609___.abs_pos >= veh___619___.abs_pos)) &
       !(veh___619___.same_lane_as_veh_0 & (veh___619___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___619___.abs_pos >= veh___609___.abs_pos)));
	
-- >>> Car 2 <<<


DEFINE
   veh___629___.rel_pos := veh___629___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___629___.next_abs_pos := veh___629___.abs_pos + next(veh___629___.v);

INVAR
    veh___629___.lane_single | veh___629___.lane_crossing;

INVAR
    (max(-veh___629___.v, a_min) <= veh___629___.a & veh___629___.a <= a_max) &
    (0 <= veh___629___.v & veh___629___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_2 := case
   veh___629___.v = 0 : 0;
   veh___629___.v = 1 : 1;
   veh___629___.v = 2 : 4;
   veh___629___.v = 3 : 9;
   veh___629___.v = 4 : 16;
   veh___629___.v = 5 : 25;
   veh___629___.v = 6 : 36;
   veh___629___.v = 7 : 49;
   veh___629___.v = 8 : 64;
   veh___629___.v = 9 : 81;
   veh___629___.v = 10 : 100;
   veh___629___.v = 11 : 121;
   veh___629___.v = 12 : 144;
   veh___629___.v = 13 : 169;
   veh___629___.v = 14 : 196;
   veh___629___.v = 15 : 225;
   veh___629___.v = 16 : 256;
   veh___629___.v = 17 : 289;
   veh___629___.v = 18 : 324;
   veh___629___.v = 19 : 361;
   veh___629___.v = 20 : 400;
   veh___629___.v = 21 : 441;
   veh___629___.v = 22 : 484;
   veh___629___.v = 23 : 529;
   veh___629___.v = 24 : 576;
   veh___629___.v = 25 : 625;
   veh___629___.v = 26 : 676;
   veh___629___.v = 27 : 729;
   veh___629___.v = 28 : 784;
   veh___629___.v = 29 : 841;
   veh___629___.v = 30 : 900;
   veh___629___.v = 31 : 961;
   veh___629___.v = 32 : 1024;
   veh___629___.v = 33 : 1089;
   veh___629___.v = 34 : 1156;
   veh___629___.v = 35 : 1225;
   veh___629___.v = 36 : 1296;
   veh___629___.v = 37 : 1369;
   veh___629___.v = 38 : 1444;
   veh___629___.v = 39 : 1521;
   veh___629___.v = 40 : 1600;
   veh___629___.v = 41 : 1681;
   veh___629___.v = 42 : 1764;
   veh___629___.v = 43 : 1849;
   veh___629___.v = 44 : 1936;
   veh___629___.v = 45 : 2025;
   veh___629___.v = 46 : 2116;
   veh___629___.v = 47 : 2209;
   veh___629___.v = 48 : 2304;
   veh___629___.v = 49 : 2401;
   veh___629___.v = 50 : 2500;
   veh___629___.v = 51 : 2601;
   veh___629___.v = 52 : 2704;
   veh___629___.v = 53 : 2809;
   veh___629___.v = 54 : 2916;
   veh___629___.v = 55 : 3025;
   veh___629___.v = 56 : 3136;
   veh___629___.v = 57 : 3249;
   veh___629___.v = 58 : 3364;
   veh___629___.v = 59 : 3481;
   veh___629___.v = 60 : 3600;
   veh___629___.v = 61 : 3721;
   veh___629___.v = 62 : 3844;
   veh___629___.v = 63 : 3969;
   veh___629___.v = 64 : 4096;
   veh___629___.v = 65 : 4225;
   veh___629___.v = 66 : 4356;
   veh___629___.v = 67 : 4489;
   veh___629___.v = 68 : 4624;
   veh___629___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_2_and_veh_0_on_same_seclet := 
veh___629___.on_straight_section = veh___609___.on_straight_section & veh___629___.traversion_from = veh___609___.traversion_from & veh___629___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_2_and_veh_0_on_same_seclet -> (veh___629___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___629___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_2_and_veh_0_on_same_seclet -> (
       !(veh___629___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___609___.abs_pos >= veh___629___.abs_pos)) &
       !(veh___629___.same_lane_as_veh_0 & (veh___629___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___629___.abs_pos >= veh___609___.abs_pos)));
	
DEFINE veh_2_and_veh_1_on_same_seclet := 
veh___629___.on_straight_section = veh___619___.on_straight_section & veh___629___.traversion_from = veh___619___.traversion_from & veh___629___.traversion_to = veh___619___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_2_and_veh_1_on_same_seclet -> (veh___629___.same_lane_as_veh_1 -> (abs(veh___619___.abs_pos - veh___629___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_2_and_veh_1_on_same_seclet -> (
       !(veh___629___.same_lane_as_veh_1 & (veh___619___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___619___.abs_pos >= veh___629___.abs_pos)) &
       !(veh___629___.same_lane_as_veh_1 & (veh___629___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___629___.abs_pos >= veh___619___.abs_pos)));
	
-- >>> Car 3 <<<


DEFINE
   veh___639___.rel_pos := veh___639___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___639___.next_abs_pos := veh___639___.abs_pos + next(veh___639___.v);

INVAR
    veh___639___.lane_single | veh___639___.lane_crossing;

INVAR
    (max(-veh___639___.v, a_min) <= veh___639___.a & veh___639___.a <= a_max) &
    (0 <= veh___639___.v & veh___639___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_3 := case
   veh___639___.v = 0 : 0;
   veh___639___.v = 1 : 1;
   veh___639___.v = 2 : 4;
   veh___639___.v = 3 : 9;
   veh___639___.v = 4 : 16;
   veh___639___.v = 5 : 25;
   veh___639___.v = 6 : 36;
   veh___639___.v = 7 : 49;
   veh___639___.v = 8 : 64;
   veh___639___.v = 9 : 81;
   veh___639___.v = 10 : 100;
   veh___639___.v = 11 : 121;
   veh___639___.v = 12 : 144;
   veh___639___.v = 13 : 169;
   veh___639___.v = 14 : 196;
   veh___639___.v = 15 : 225;
   veh___639___.v = 16 : 256;
   veh___639___.v = 17 : 289;
   veh___639___.v = 18 : 324;
   veh___639___.v = 19 : 361;
   veh___639___.v = 20 : 400;
   veh___639___.v = 21 : 441;
   veh___639___.v = 22 : 484;
   veh___639___.v = 23 : 529;
   veh___639___.v = 24 : 576;
   veh___639___.v = 25 : 625;
   veh___639___.v = 26 : 676;
   veh___639___.v = 27 : 729;
   veh___639___.v = 28 : 784;
   veh___639___.v = 29 : 841;
   veh___639___.v = 30 : 900;
   veh___639___.v = 31 : 961;
   veh___639___.v = 32 : 1024;
   veh___639___.v = 33 : 1089;
   veh___639___.v = 34 : 1156;
   veh___639___.v = 35 : 1225;
   veh___639___.v = 36 : 1296;
   veh___639___.v = 37 : 1369;
   veh___639___.v = 38 : 1444;
   veh___639___.v = 39 : 1521;
   veh___639___.v = 40 : 1600;
   veh___639___.v = 41 : 1681;
   veh___639___.v = 42 : 1764;
   veh___639___.v = 43 : 1849;
   veh___639___.v = 44 : 1936;
   veh___639___.v = 45 : 2025;
   veh___639___.v = 46 : 2116;
   veh___639___.v = 47 : 2209;
   veh___639___.v = 48 : 2304;
   veh___639___.v = 49 : 2401;
   veh___639___.v = 50 : 2500;
   veh___639___.v = 51 : 2601;
   veh___639___.v = 52 : 2704;
   veh___639___.v = 53 : 2809;
   veh___639___.v = 54 : 2916;
   veh___639___.v = 55 : 3025;
   veh___639___.v = 56 : 3136;
   veh___639___.v = 57 : 3249;
   veh___639___.v = 58 : 3364;
   veh___639___.v = 59 : 3481;
   veh___639___.v = 60 : 3600;
   veh___639___.v = 61 : 3721;
   veh___639___.v = 62 : 3844;
   veh___639___.v = 63 : 3969;
   veh___639___.v = 64 : 4096;
   veh___639___.v = 65 : 4225;
   veh___639___.v = 66 : 4356;
   veh___639___.v = 67 : 4489;
   veh___639___.v = 68 : 4624;
   veh___639___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_3_and_veh_0_on_same_seclet := 
veh___639___.on_straight_section = veh___609___.on_straight_section & veh___639___.traversion_from = veh___609___.traversion_from & veh___639___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_3_and_veh_0_on_same_seclet -> (veh___639___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___639___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_3_and_veh_0_on_same_seclet -> (
       !(veh___639___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___609___.abs_pos >= veh___639___.abs_pos)) &
       !(veh___639___.same_lane_as_veh_0 & (veh___639___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___639___.abs_pos >= veh___609___.abs_pos)));
	
DEFINE veh_3_and_veh_1_on_same_seclet := 
veh___639___.on_straight_section = veh___619___.on_straight_section & veh___639___.traversion_from = veh___619___.traversion_from & veh___639___.traversion_to = veh___619___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_3_and_veh_1_on_same_seclet -> (veh___639___.same_lane_as_veh_1 -> (abs(veh___619___.abs_pos - veh___639___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_3_and_veh_1_on_same_seclet -> (
       !(veh___639___.same_lane_as_veh_1 & (veh___619___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___619___.abs_pos >= veh___639___.abs_pos)) &
       !(veh___639___.same_lane_as_veh_1 & (veh___639___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___639___.abs_pos >= veh___619___.abs_pos)));
	
DEFINE veh_3_and_veh_2_on_same_seclet := 
veh___639___.on_straight_section = veh___629___.on_straight_section & veh___639___.traversion_from = veh___629___.traversion_from & veh___639___.traversion_to = veh___629___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_3_and_veh_2_on_same_seclet -> (veh___639___.same_lane_as_veh_2 -> (abs(veh___629___.abs_pos - veh___639___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_3_and_veh_2_on_same_seclet -> (
       !(veh___639___.same_lane_as_veh_2 & (veh___629___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___629___.abs_pos >= veh___639___.abs_pos)) &
       !(veh___639___.same_lane_as_veh_2 & (veh___639___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___639___.abs_pos >= veh___629___.abs_pos)));
	
-- >>> Car 4 <<<


DEFINE
   veh___649___.rel_pos := veh___649___.abs_pos - ego.abs_pos; -- relative position to ego in m (valid only if ego is on same section), rel_pos < 0 means the rear bumber of the other vehicle is behind the rear bumper of the ego
   veh___649___.next_abs_pos := veh___649___.abs_pos + next(veh___649___.v);

INVAR
    veh___649___.lane_single | veh___649___.lane_crossing;

INVAR
    (max(-veh___649___.v, a_min) <= veh___649___.a & veh___649___.a <= a_max) &
    (0 <= veh___649___.v & veh___649___.v <= max_vel);

-- Lookup table to speed-up non-linear calculations
DEFINE
square_of_veh_v_4 := case
   veh___649___.v = 0 : 0;
   veh___649___.v = 1 : 1;
   veh___649___.v = 2 : 4;
   veh___649___.v = 3 : 9;
   veh___649___.v = 4 : 16;
   veh___649___.v = 5 : 25;
   veh___649___.v = 6 : 36;
   veh___649___.v = 7 : 49;
   veh___649___.v = 8 : 64;
   veh___649___.v = 9 : 81;
   veh___649___.v = 10 : 100;
   veh___649___.v = 11 : 121;
   veh___649___.v = 12 : 144;
   veh___649___.v = 13 : 169;
   veh___649___.v = 14 : 196;
   veh___649___.v = 15 : 225;
   veh___649___.v = 16 : 256;
   veh___649___.v = 17 : 289;
   veh___649___.v = 18 : 324;
   veh___649___.v = 19 : 361;
   veh___649___.v = 20 : 400;
   veh___649___.v = 21 : 441;
   veh___649___.v = 22 : 484;
   veh___649___.v = 23 : 529;
   veh___649___.v = 24 : 576;
   veh___649___.v = 25 : 625;
   veh___649___.v = 26 : 676;
   veh___649___.v = 27 : 729;
   veh___649___.v = 28 : 784;
   veh___649___.v = 29 : 841;
   veh___649___.v = 30 : 900;
   veh___649___.v = 31 : 961;
   veh___649___.v = 32 : 1024;
   veh___649___.v = 33 : 1089;
   veh___649___.v = 34 : 1156;
   veh___649___.v = 35 : 1225;
   veh___649___.v = 36 : 1296;
   veh___649___.v = 37 : 1369;
   veh___649___.v = 38 : 1444;
   veh___649___.v = 39 : 1521;
   veh___649___.v = 40 : 1600;
   veh___649___.v = 41 : 1681;
   veh___649___.v = 42 : 1764;
   veh___649___.v = 43 : 1849;
   veh___649___.v = 44 : 1936;
   veh___649___.v = 45 : 2025;
   veh___649___.v = 46 : 2116;
   veh___649___.v = 47 : 2209;
   veh___649___.v = 48 : 2304;
   veh___649___.v = 49 : 2401;
   veh___649___.v = 50 : 2500;
   veh___649___.v = 51 : 2601;
   veh___649___.v = 52 : 2704;
   veh___649___.v = 53 : 2809;
   veh___649___.v = 54 : 2916;
   veh___649___.v = 55 : 3025;
   veh___649___.v = 56 : 3136;
   veh___649___.v = 57 : 3249;
   veh___649___.v = 58 : 3364;
   veh___649___.v = 59 : 3481;
   veh___649___.v = 60 : 3600;
   veh___649___.v = 61 : 3721;
   veh___649___.v = 62 : 3844;
   veh___649___.v = 63 : 3969;
   veh___649___.v = 64 : 4096;
   veh___649___.v = 65 : 4225;
   veh___649___.v = 66 : 4356;
   veh___649___.v = 67 : 4489;
   veh___649___.v = 68 : 4624;
   veh___649___.v = 69 : 4761;
   
   TRUE: 4900;
esac;

DEFINE veh_4_and_veh_0_on_same_seclet := 
veh___649___.on_straight_section = veh___609___.on_straight_section & veh___649___.traversion_from = veh___609___.traversion_from & veh___649___.traversion_to = veh___609___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_0_on_same_seclet -> (veh___649___.same_lane_as_veh_0 -> (abs(veh___609___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_0_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_0 & (veh___609___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___609___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_0 & (veh___649___.prev_abs_pos < veh___609___.prev_abs_pos) & (veh___649___.abs_pos >= veh___609___.abs_pos)));
	
DEFINE veh_4_and_veh_1_on_same_seclet := 
veh___649___.on_straight_section = veh___619___.on_straight_section & veh___649___.traversion_from = veh___619___.traversion_from & veh___649___.traversion_to = veh___619___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_1_on_same_seclet -> (veh___649___.same_lane_as_veh_1 -> (abs(veh___619___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_1_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_1 & (veh___619___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___619___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_1 & (veh___649___.prev_abs_pos < veh___619___.prev_abs_pos) & (veh___649___.abs_pos >= veh___619___.abs_pos)));
	
DEFINE veh_4_and_veh_2_on_same_seclet := 
veh___649___.on_straight_section = veh___629___.on_straight_section & veh___649___.traversion_from = veh___629___.traversion_from & veh___649___.traversion_to = veh___629___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_2_on_same_seclet -> (veh___649___.same_lane_as_veh_2 -> (abs(veh___629___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_2_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_2 & (veh___629___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___629___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_2 & (veh___649___.prev_abs_pos < veh___629___.prev_abs_pos) & (veh___649___.abs_pos >= veh___629___.abs_pos)));
	
DEFINE veh_4_and_veh_3_on_same_seclet := 
veh___649___.on_straight_section = veh___639___.on_straight_section & veh___649___.traversion_from = veh___639___.traversion_from & veh___649___.traversion_to = veh___639___.traversion_to;

INVAR -- Non-Ego cars may not collide.
    veh_4_and_veh_3_on_same_seclet -> (veh___649___.same_lane_as_veh_3 -> (abs(veh___639___.abs_pos - veh___649___.abs_pos) > veh_length));

INVAR -- Non-Ego cars may not "jump" over each other.
    veh_4_and_veh_3_on_same_seclet -> (
       !(veh___649___.same_lane_as_veh_3 & (veh___639___.prev_abs_pos < veh___649___.prev_abs_pos) & (veh___639___.abs_pos >= veh___649___.abs_pos)) &
       !(veh___649___.same_lane_as_veh_3 & (veh___649___.prev_abs_pos < veh___639___.prev_abs_pos) & (veh___649___.abs_pos >= veh___639___.abs_pos)));
	




-- >>> Car [i] <<<
ASSIGN
    init(veh___609___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___609___.do_lane_change) := FALSE;
    init(veh___609___.abort_lc) := FALSE;
    init(veh___609___.lc_direction) := ActionDir____CENTER;
    init(veh___609___.lc_timer) := -1;
    init(veh___609___.change_lane_now) := 0;
    init(veh___609___.prev_rel_pos) := 0;
    init(veh___609___.prev_abs_pos) := 0;
    -- init(veh___609___.v) := 35;
    
    init(veh___609___.turn_signals) := ActionDir____CENTER;
    init(veh___609___.lc_leave_src_lane) := FALSE;

    next(veh___609___.do_lane_change) := 
	    case 
        veh___609___.do_lane_change = FALSE & veh___609___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___609___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___609___.lc_timer >= complete_lane_change_earliest_after  & veh___609___.lc_timer < complete_lane_change_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___609___.lc_timer = complete_lane_change_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___609___.lc_timer >= abort_lane_change_complete_earliest_after & veh___609___.lc_timer < abort_lane_change_complete_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = TRUE: {TRUE, FALSE};
            veh___609___.lc_timer = abort_lane_change_complete_latest_after & veh___609___.lane_crossing & veh___609___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___609___.lc_timer >= 0 & veh___609___.abort_lc = TRUE & veh___609___.lane_single: FALSE; 
            TRUE : veh___609___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___609___.abort_lc) := case
        veh___609___.lc_timer > leave_src_lane_latest_after & veh___609___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___609___.do_lane_change) = TRUE & veh___609___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___609___.abort_lc = TRUE & next(veh___609___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___609___.abort_lc;
    esac;

    next(veh___609___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE & veh___609___.lane_min : ActionDir____LEFT;
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE & veh___609___.lane_max : ActionDir____RIGHT;
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___609___.do_lane_change = TRUE & next(veh___609___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___609___.lc_direction;
    esac;

    next(veh___609___.lc_leave_src_lane) := case
        veh___609___.lane_single & next(veh___609___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___609___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE: next(veh___609___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___609___.do_lane_change = TRUE & veh___609___.lane_single & next(veh___609___.lane_crossing) : ActionDir____CENTER;
        veh___609___.lane_single & next(veh___609___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___609___.turn_signals;
    esac;

    next(veh___609___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___609___.lc_timer = -1 & veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE & veh___609___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___609___.lc_timer >= 0 & veh___609___.lane_single & next(veh___609___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___609___.lc_timer >= 0 & next(veh___609___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___609___.lc_timer >= 0 & veh___609___.abort_lc = FALSE & next(veh___609___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___609___.lc_timer >= 0 & veh___609___.lc_timer < complete_lane_change_latest_after : veh___609___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___609___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___609___.time_since_last_lc) := case
        veh___609___.do_lane_change = TRUE & next(veh___609___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___609___.time_since_last_lc >= 0 & veh___609___.time_since_last_lc < min_time_between_lcs: veh___609___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___609___.do_lane_change = FALSE & next(veh___609___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___609___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___609___.change_lane_now) := case
        veh___609___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___609___.prev_rel_pos) := veh___609___.rel_pos;
    next(veh___609___.prev_abs_pos) := veh___609___.abs_pos;


    next(veh___609___.abs_pos) := case
       veh___609___.is_on_sec_0 = 1 & veh___609___.next_abs_pos > section_0_end : veh___609___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___609___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___609___.v) := min(max(veh___609___.v + veh___609___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___609___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___609___.is_on_sec_0 = 1 & veh___609___.next_abs_pos > section_0_end : 0;
             TRUE : veh___609___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
       
             
       

    
          
       
    
-- >>> Car [i] <<<
ASSIGN
    init(veh___619___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___619___.do_lane_change) := FALSE;
    init(veh___619___.abort_lc) := FALSE;
    init(veh___619___.lc_direction) := ActionDir____CENTER;
    init(veh___619___.lc_timer) := -1;
    init(veh___619___.change_lane_now) := 0;
    init(veh___619___.prev_rel_pos) := 0;
    init(veh___619___.prev_abs_pos) := 0;
    -- init(veh___619___.v) := 35;
    
    init(veh___619___.turn_signals) := ActionDir____CENTER;
    init(veh___619___.lc_leave_src_lane) := FALSE;

    next(veh___619___.do_lane_change) := 
	    case 
        veh___619___.do_lane_change = FALSE & veh___619___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___619___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___619___.lc_timer >= complete_lane_change_earliest_after  & veh___619___.lc_timer < complete_lane_change_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___619___.lc_timer = complete_lane_change_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___619___.lc_timer >= abort_lane_change_complete_earliest_after & veh___619___.lc_timer < abort_lane_change_complete_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = TRUE: {TRUE, FALSE};
            veh___619___.lc_timer = abort_lane_change_complete_latest_after & veh___619___.lane_crossing & veh___619___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___619___.lc_timer >= 0 & veh___619___.abort_lc = TRUE & veh___619___.lane_single: FALSE; 
            TRUE : veh___619___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___619___.abort_lc) := case
        veh___619___.lc_timer > leave_src_lane_latest_after & veh___619___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___619___.do_lane_change) = TRUE & veh___619___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___619___.abort_lc = TRUE & next(veh___619___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___619___.abort_lc;
    esac;

    next(veh___619___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE & veh___619___.lane_min : ActionDir____LEFT;
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE & veh___619___.lane_max : ActionDir____RIGHT;
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___619___.do_lane_change = TRUE & next(veh___619___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___619___.lc_direction;
    esac;

    next(veh___619___.lc_leave_src_lane) := case
        veh___619___.lane_single & next(veh___619___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___619___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE: next(veh___619___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___619___.do_lane_change = TRUE & veh___619___.lane_single & next(veh___619___.lane_crossing) : ActionDir____CENTER;
        veh___619___.lane_single & next(veh___619___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___619___.turn_signals;
    esac;

    next(veh___619___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___619___.lc_timer = -1 & veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE & veh___619___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___619___.lc_timer >= 0 & veh___619___.lane_single & next(veh___619___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___619___.lc_timer >= 0 & next(veh___619___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___619___.lc_timer >= 0 & veh___619___.abort_lc = FALSE & next(veh___619___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___619___.lc_timer >= 0 & veh___619___.lc_timer < complete_lane_change_latest_after : veh___619___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___619___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___619___.time_since_last_lc) := case
        veh___619___.do_lane_change = TRUE & next(veh___619___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___619___.time_since_last_lc >= 0 & veh___619___.time_since_last_lc < min_time_between_lcs: veh___619___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___619___.do_lane_change = FALSE & next(veh___619___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___619___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___619___.change_lane_now) := case
        veh___619___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___619___.prev_rel_pos) := veh___619___.rel_pos;
    next(veh___619___.prev_abs_pos) := veh___619___.abs_pos;


    next(veh___619___.abs_pos) := case
       veh___619___.is_on_sec_0 = 1 & veh___619___.next_abs_pos > section_0_end : veh___619___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___619___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___619___.v) := min(max(veh___619___.v + veh___619___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___619___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___619___.is_on_sec_0 = 1 & veh___619___.next_abs_pos > section_0_end : 0;
             TRUE : veh___619___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
       
             
       

    
          
       
    
-- >>> Car [i] <<<
ASSIGN
    init(veh___629___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___629___.do_lane_change) := FALSE;
    init(veh___629___.abort_lc) := FALSE;
    init(veh___629___.lc_direction) := ActionDir____CENTER;
    init(veh___629___.lc_timer) := -1;
    init(veh___629___.change_lane_now) := 0;
    init(veh___629___.prev_rel_pos) := 0;
    init(veh___629___.prev_abs_pos) := 0;
    -- init(veh___629___.v) := 35;
    
    init(veh___629___.turn_signals) := ActionDir____CENTER;
    init(veh___629___.lc_leave_src_lane) := FALSE;

    next(veh___629___.do_lane_change) := 
	    case 
        veh___629___.do_lane_change = FALSE & veh___629___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___629___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___629___.lc_timer >= complete_lane_change_earliest_after  & veh___629___.lc_timer < complete_lane_change_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___629___.lc_timer = complete_lane_change_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___629___.lc_timer >= abort_lane_change_complete_earliest_after & veh___629___.lc_timer < abort_lane_change_complete_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = TRUE: {TRUE, FALSE};
            veh___629___.lc_timer = abort_lane_change_complete_latest_after & veh___629___.lane_crossing & veh___629___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___629___.lc_timer >= 0 & veh___629___.abort_lc = TRUE & veh___629___.lane_single: FALSE; 
            TRUE : veh___629___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___629___.abort_lc) := case
        veh___629___.lc_timer > leave_src_lane_latest_after & veh___629___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___629___.do_lane_change) = TRUE & veh___629___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___629___.abort_lc = TRUE & next(veh___629___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___629___.abort_lc;
    esac;

    next(veh___629___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE & veh___629___.lane_min : ActionDir____LEFT;
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE & veh___629___.lane_max : ActionDir____RIGHT;
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___629___.do_lane_change = TRUE & next(veh___629___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___629___.lc_direction;
    esac;

    next(veh___629___.lc_leave_src_lane) := case
        veh___629___.lane_single & next(veh___629___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___629___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE: next(veh___629___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___629___.do_lane_change = TRUE & veh___629___.lane_single & next(veh___629___.lane_crossing) : ActionDir____CENTER;
        veh___629___.lane_single & next(veh___629___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___629___.turn_signals;
    esac;

    next(veh___629___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___629___.lc_timer = -1 & veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE & veh___629___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___629___.lc_timer >= 0 & veh___629___.lane_single & next(veh___629___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___629___.lc_timer >= 0 & next(veh___629___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___629___.lc_timer >= 0 & veh___629___.abort_lc = FALSE & next(veh___629___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___629___.lc_timer >= 0 & veh___629___.lc_timer < complete_lane_change_latest_after : veh___629___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___629___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___629___.time_since_last_lc) := case
        veh___629___.do_lane_change = TRUE & next(veh___629___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___629___.time_since_last_lc >= 0 & veh___629___.time_since_last_lc < min_time_between_lcs: veh___629___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___629___.do_lane_change = FALSE & next(veh___629___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___629___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___629___.change_lane_now) := case
        veh___629___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___629___.prev_rel_pos) := veh___629___.rel_pos;
    next(veh___629___.prev_abs_pos) := veh___629___.abs_pos;


    next(veh___629___.abs_pos) := case
       veh___629___.is_on_sec_0 = 1 & veh___629___.next_abs_pos > section_0_end : veh___629___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___629___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___629___.v) := min(max(veh___629___.v + veh___629___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___629___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___629___.is_on_sec_0 = 1 & veh___629___.next_abs_pos > section_0_end : 0;
             TRUE : veh___629___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
       
             
       

    
          
       
    
-- >>> Car [i] <<<
ASSIGN
    init(veh___639___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___639___.do_lane_change) := FALSE;
    init(veh___639___.abort_lc) := FALSE;
    init(veh___639___.lc_direction) := ActionDir____CENTER;
    init(veh___639___.lc_timer) := -1;
    init(veh___639___.change_lane_now) := 0;
    init(veh___639___.prev_rel_pos) := 0;
    init(veh___639___.prev_abs_pos) := 0;
    -- init(veh___639___.v) := 35;
    
    init(veh___639___.turn_signals) := ActionDir____CENTER;
    init(veh___639___.lc_leave_src_lane) := FALSE;

    next(veh___639___.do_lane_change) := 
	    case 
        veh___639___.do_lane_change = FALSE & veh___639___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___639___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___639___.lc_timer >= complete_lane_change_earliest_after  & veh___639___.lc_timer < complete_lane_change_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___639___.lc_timer = complete_lane_change_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___639___.lc_timer >= abort_lane_change_complete_earliest_after & veh___639___.lc_timer < abort_lane_change_complete_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = TRUE: {TRUE, FALSE};
            veh___639___.lc_timer = abort_lane_change_complete_latest_after & veh___639___.lane_crossing & veh___639___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___639___.lc_timer >= 0 & veh___639___.abort_lc = TRUE & veh___639___.lane_single: FALSE; 
            TRUE : veh___639___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___639___.abort_lc) := case
        veh___639___.lc_timer > leave_src_lane_latest_after & veh___639___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___639___.do_lane_change) = TRUE & veh___639___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___639___.abort_lc = TRUE & next(veh___639___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___639___.abort_lc;
    esac;

    next(veh___639___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE & veh___639___.lane_min : ActionDir____LEFT;
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE & veh___639___.lane_max : ActionDir____RIGHT;
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___639___.do_lane_change = TRUE & next(veh___639___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___639___.lc_direction;
    esac;

    next(veh___639___.lc_leave_src_lane) := case
        veh___639___.lane_single & next(veh___639___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___639___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE: next(veh___639___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___639___.do_lane_change = TRUE & veh___639___.lane_single & next(veh___639___.lane_crossing) : ActionDir____CENTER;
        veh___639___.lane_single & next(veh___639___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___639___.turn_signals;
    esac;

    next(veh___639___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___639___.lc_timer = -1 & veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE & veh___639___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___639___.lc_timer >= 0 & veh___639___.lane_single & next(veh___639___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___639___.lc_timer >= 0 & next(veh___639___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___639___.lc_timer >= 0 & veh___639___.abort_lc = FALSE & next(veh___639___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___639___.lc_timer >= 0 & veh___639___.lc_timer < complete_lane_change_latest_after : veh___639___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___639___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___639___.time_since_last_lc) := case
        veh___639___.do_lane_change = TRUE & next(veh___639___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___639___.time_since_last_lc >= 0 & veh___639___.time_since_last_lc < min_time_between_lcs: veh___639___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___639___.do_lane_change = FALSE & next(veh___639___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___639___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___639___.change_lane_now) := case
        veh___639___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___639___.prev_rel_pos) := veh___639___.rel_pos;
    next(veh___639___.prev_abs_pos) := veh___639___.abs_pos;


    next(veh___639___.abs_pos) := case
       veh___639___.is_on_sec_0 = 1 & veh___639___.next_abs_pos > section_0_end : veh___639___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___639___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___639___.v) := min(max(veh___639___.v + veh___639___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___639___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___639___.is_on_sec_0 = 1 & veh___639___.next_abs_pos > section_0_end : 0;
             TRUE : veh___639___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
       
             
       

    
          
       
    
-- >>> Car [i] <<<
ASSIGN
    init(veh___649___.time_since_last_lc) := min_time_between_lcs;       -- init with max value such that lane change is immediately allowed after start
    init(veh___649___.do_lane_change) := FALSE;
    init(veh___649___.abort_lc) := FALSE;
    init(veh___649___.lc_direction) := ActionDir____CENTER;
    init(veh___649___.lc_timer) := -1;
    init(veh___649___.change_lane_now) := 0;
    init(veh___649___.prev_rel_pos) := 0;
    init(veh___649___.prev_abs_pos) := 0;
    -- init(veh___649___.v) := 35;
    
    init(veh___649___.turn_signals) := ActionDir____CENTER;
    init(veh___649___.lc_leave_src_lane) := FALSE;

    next(veh___649___.do_lane_change) := 
	    case 
        veh___649___.do_lane_change = FALSE & veh___649___.time_since_last_lc >= min_time_between_lcs: {TRUE, FALSE};
        veh___649___.do_lane_change = TRUE : case 
            -- between earliest and latest point in time, we can finish at any time, but we do not have to - nevertheless, we must occupy both lanes to do so and there cannot be an abort for finishing
            veh___649___.lc_timer >= complete_lane_change_earliest_after  & veh___649___.lc_timer < complete_lane_change_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = FALSE: {TRUE, FALSE};  
            veh___649___.lc_timer = complete_lane_change_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = FALSE: FALSE ;                     -- at the latest point in time, we definitely need to finish
            -- between earliest and latest point in time, we can finish the abort at any time, but we do not have to; only consider timing when occupying both lanes
            veh___649___.lc_timer >= abort_lane_change_complete_earliest_after & veh___649___.lc_timer < abort_lane_change_complete_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = TRUE: {TRUE, FALSE};
            veh___649___.lc_timer = abort_lane_change_complete_latest_after & veh___649___.lane_crossing & veh___649___.abort_lc = TRUE: FALSE;    -- at the latest point in time, we definitely need to finish the abort
            -- we are still completely on the source lane and shall abort -> just do so regardless of time constraint
            veh___649___.lc_timer >= 0 & veh___649___.abort_lc = TRUE & veh___649___.lane_single: FALSE; 
            TRUE : veh___649___.do_lane_change;                                                    -- at all other times, just hold value
        esac;
        TRUE: FALSE;
    esac;

    next(veh___649___.abort_lc) := case
        veh___649___.lc_timer > leave_src_lane_latest_after & veh___649___.lane_single: TRUE; -- we were not able to leave the source lane within the interval (because we were next to ego) -> we must abort
        next(veh___649___.do_lane_change) = TRUE & veh___649___.abort_lc = FALSE : {TRUE, FALSE};         -- if a lane change is ongoing, we can non-deterministically abort it
        veh___649___.abort_lc = TRUE & next(veh___649___.do_lane_change) = FALSE : FALSE;
        TRUE : veh___649___.abort_lc;
    esac;

    next(veh___649___.lc_direction) := case
        -- when we decide to do a lane change, choose direction based on what is allowed and store this value throughout the lc procedure as a reference
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE & veh___649___.lane_min : ActionDir____LEFT;
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE & veh___649___.lane_max : ActionDir____RIGHT;
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE : {ActionDir____LEFT, ActionDir____RIGHT};
        -- when the lane change is finished, set back to none
        veh___649___.do_lane_change = TRUE & next(veh___649___.do_lane_change) = FALSE : ActionDir____CENTER;
        TRUE: veh___649___.lc_direction;
    esac;

    next(veh___649___.lc_leave_src_lane) := case
        veh___649___.lane_single & next(veh___649___.lane_crossing): TRUE;
        TRUE: FALSE;
    esac;

    next(veh___649___.turn_signals) := case
        -- when we decide to do a lane change, set indicators according to chosen lc_direction
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE: next(veh___649___.lc_direction);
        -- turn off once we have left the source lane (ok? or should we turn off only after reaching the target lane?)
        veh___649___.do_lane_change = TRUE & veh___649___.lane_single & next(veh___649___.lane_crossing) : ActionDir____CENTER;
        veh___649___.lane_single & next(veh___649___.abort_lc) = TRUE : ActionDir____CENTER;
        TRUE: veh___649___.turn_signals;
    esac;

    next(veh___649___.lc_timer) := case                                                                  -- IMPORTANT: Order of cases is exploitet here!!
        veh___649___.lc_timer = -1 & veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE & veh___649___.abort_lc = FALSE : 0;   -- on the rising edge, set time to 0 and activate
        veh___649___.lc_timer >= 0 & veh___649___.lane_single & next(veh___649___.lane_crossing): 0;                         -- reset counter to 0 when crossing the lane marker to leave source lane
        veh___649___.lc_timer >= 0 & next(veh___649___.do_lane_change) = FALSE : -1;                                  -- reset running counter to 0 once the lane change is complete
        veh___649___.lc_timer >= 0 & veh___649___.abort_lc = FALSE & next(veh___649___.abort_lc) = TRUE : 0;                                  -- reset counter to 0 when abort happens
        veh___649___.lc_timer >= 0 & veh___649___.lc_timer < complete_lane_change_latest_after : veh___649___.lc_timer + 1;               -- while we are still changing lanes, increment counter
        TRUE: veh___649___.lc_timer;                                                                     -- keep counter at its value in all other cases
    esac;

    next(veh___649___.time_since_last_lc) := case
        veh___649___.do_lane_change = TRUE & next(veh___649___.do_lane_change) = FALSE: 0;            -- activate timer when lane change finishes
        veh___649___.time_since_last_lc >= 0 & veh___649___.time_since_last_lc < min_time_between_lcs: veh___649___.time_since_last_lc + 1;    -- increment until threshold is reached, saturate at the threshold (-> else condition)
        veh___649___.do_lane_change = FALSE & next(veh___649___.do_lane_change) = TRUE: -1;           -- deactivate timer when new lane change starts
        TRUE: veh___649___.time_since_last_lc;                                           -- this clause also keeps the var at max value once the max value has been reached
    esac;

    next(veh___649___.change_lane_now) := case
        veh___649___.lc_timer >= 0: {0, 1};      -- choose non-deterministically that we either do change or do not change the lane now
        TRUE: 0;
    esac;
	
    -- update position (directly feed-through new velocity)
    next(veh___649___.prev_rel_pos) := veh___649___.rel_pos;
    next(veh___649___.prev_abs_pos) := veh___649___.abs_pos;


    next(veh___649___.abs_pos) := case
       veh___649___.is_on_sec_0 = 1 & veh___649___.next_abs_pos > section_0_end : veh___649___.next_abs_pos - section_0_end;
          
            
            
            
            
          
       
          TRUE : veh___649___.next_abs_pos;
    esac;

    -- update velocity (directly feed-through newly chosen accel)
    next(veh___649___.v) := min(max(veh___649___.v + veh___649___.a, 0), max_vel);

    -- ############ IDEA ###########
    -- Set future road either to 1/0 if it's clear we'll end or not end up there, or to {0, 1} whenever there IS a connection,
    -- but we're not sure if there might be another one. Together with the INVAR that makes it sum up to 1,
    -- we are sure that exactly one will be chosen.
    -- ########## EO IDEA #########

    -- ### Future pos is straight section ###
       next(veh___649___.is_on_sec_0) := case
             
             
             
             
             
          
             veh___649___.is_on_sec_0 = 1 & veh___649___.next_abs_pos > section_0_end : 0;
             TRUE : veh___649___.is_on_sec_0;
          esac;
       
    
    -- ## Future pos is curved junction ##
       
             
       

    
          
       
    


-- >>> Car 0 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___609___.lc_timer >= leave_src_lane_earliest_after & veh___609___.lc_timer < leave_src_lane_latest_after & veh___609___.lane_single & !veh___609___.abort_lc & !next(veh___609___.abort_lc): 
        case 
            veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_max  : next(veh___609___.change_lane_now) = 0 ? veh___609___.lane_unchanged : veh___609___.lane_move_up;
            veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_min  : next(veh___609___.change_lane_now) = 0 ? veh___609___.lane_unchanged : veh___609___.lane_move_down;
            TRUE : veh___609___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___609___.lc_timer = leave_src_lane_latest_after & veh___609___.lane_single: 
        case
                veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_max  : veh___609___.lane_move_up; 
                veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_min  : veh___609___.lane_move_down;
                TRUE : veh___609___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___609___.lc_timer > 0 & next(veh___609___.do_lane_change) = FALSE & veh___609___.lane_crossing & !veh___609___.abort_lc & !next(veh___609___.abort_lc) : 
        case  
            veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_max : veh___609___.lane_move_up; 
            veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_min : veh___609___.lane_move_down;
            TRUE : veh___609___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___609___.lc_timer > 0 & !next(veh___609___.do_lane_change) & veh___609___.lane_crossing & veh___609___.abort_lc: 
        case
            veh___609___.lc_direction = ActionDir____LEFT & !veh___609___.lane_min: veh___609___.lane_move_down ;   
            veh___609___.lc_direction = ActionDir____RIGHT & !veh___609___.lane_max: veh___609___.lane_move_up;
            TRUE : veh___609___.lane_unchanged;
        esac;
        TRUE: veh___609___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 1 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___619___.lc_timer >= leave_src_lane_earliest_after & veh___619___.lc_timer < leave_src_lane_latest_after & veh___619___.lane_single & !veh___619___.abort_lc & !next(veh___619___.abort_lc): 
        case 
            veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_max  : next(veh___619___.change_lane_now) = 0 ? veh___619___.lane_unchanged : veh___619___.lane_move_up;
            veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_min  : next(veh___619___.change_lane_now) = 0 ? veh___619___.lane_unchanged : veh___619___.lane_move_down;
            TRUE : veh___619___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___619___.lc_timer = leave_src_lane_latest_after & veh___619___.lane_single: 
        case
                veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_max  : veh___619___.lane_move_up; 
                veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_min  : veh___619___.lane_move_down;
                TRUE : veh___619___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___619___.lc_timer > 0 & next(veh___619___.do_lane_change) = FALSE & veh___619___.lane_crossing & !veh___619___.abort_lc & !next(veh___619___.abort_lc) : 
        case  
            veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_max : veh___619___.lane_move_up; 
            veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_min : veh___619___.lane_move_down;
            TRUE : veh___619___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___619___.lc_timer > 0 & !next(veh___619___.do_lane_change) & veh___619___.lane_crossing & veh___619___.abort_lc: 
        case
            veh___619___.lc_direction = ActionDir____LEFT & !veh___619___.lane_min: veh___619___.lane_move_down ;   
            veh___619___.lc_direction = ActionDir____RIGHT & !veh___619___.lane_max: veh___619___.lane_move_up;
            TRUE : veh___619___.lane_unchanged;
        esac;
        TRUE: veh___619___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 2 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___629___.lc_timer >= leave_src_lane_earliest_after & veh___629___.lc_timer < leave_src_lane_latest_after & veh___629___.lane_single & !veh___629___.abort_lc & !next(veh___629___.abort_lc): 
        case 
            veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_max  : next(veh___629___.change_lane_now) = 0 ? veh___629___.lane_unchanged : veh___629___.lane_move_up;
            veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_min  : next(veh___629___.change_lane_now) = 0 ? veh___629___.lane_unchanged : veh___629___.lane_move_down;
            TRUE : veh___629___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___629___.lc_timer = leave_src_lane_latest_after & veh___629___.lane_single: 
        case
                veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_max  : veh___629___.lane_move_up; 
                veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_min  : veh___629___.lane_move_down;
                TRUE : veh___629___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___629___.lc_timer > 0 & next(veh___629___.do_lane_change) = FALSE & veh___629___.lane_crossing & !veh___629___.abort_lc & !next(veh___629___.abort_lc) : 
        case  
            veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_max : veh___629___.lane_move_up; 
            veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_min : veh___629___.lane_move_down;
            TRUE : veh___629___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___629___.lc_timer > 0 & !next(veh___629___.do_lane_change) & veh___629___.lane_crossing & veh___629___.abort_lc: 
        case
            veh___629___.lc_direction = ActionDir____LEFT & !veh___629___.lane_min: veh___629___.lane_move_down ;   
            veh___629___.lc_direction = ActionDir____RIGHT & !veh___629___.lane_max: veh___629___.lane_move_up;
            TRUE : veh___629___.lane_unchanged;
        esac;
        TRUE: veh___629___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 3 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___639___.lc_timer >= leave_src_lane_earliest_after & veh___639___.lc_timer < leave_src_lane_latest_after & veh___639___.lane_single & !veh___639___.abort_lc & !next(veh___639___.abort_lc): 
        case 
            veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_max  : next(veh___639___.change_lane_now) = 0 ? veh___639___.lane_unchanged : veh___639___.lane_move_up;
            veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_min  : next(veh___639___.change_lane_now) = 0 ? veh___639___.lane_unchanged : veh___639___.lane_move_down;
            TRUE : veh___639___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___639___.lc_timer = leave_src_lane_latest_after & veh___639___.lane_single: 
        case
                veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_max  : veh___639___.lane_move_up; 
                veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_min  : veh___639___.lane_move_down;
                TRUE : veh___639___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___639___.lc_timer > 0 & next(veh___639___.do_lane_change) = FALSE & veh___639___.lane_crossing & !veh___639___.abort_lc & !next(veh___639___.abort_lc) : 
        case  
            veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_max : veh___639___.lane_move_up; 
            veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_min : veh___639___.lane_move_down;
            TRUE : veh___639___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___639___.lc_timer > 0 & !next(veh___639___.do_lane_change) & veh___639___.lane_crossing & veh___639___.abort_lc: 
        case
            veh___639___.lc_direction = ActionDir____LEFT & !veh___639___.lane_min: veh___639___.lane_move_down ;   
            veh___639___.lc_direction = ActionDir____RIGHT & !veh___639___.lane_max: veh___639___.lane_move_up;
            TRUE : veh___639___.lane_unchanged;
        esac;
        TRUE: veh___639___.lane_unchanged;                                      -- hold current value in all other cases
    esac;

-- >>> Car 4 <<<
TRANS
    case
        -- the timer is within the interval where we may leave our source lane, we may transition to any neighbor lane but we do not have to (current lane is also allowed for next state)
        veh___649___.lc_timer >= leave_src_lane_earliest_after & veh___649___.lc_timer < leave_src_lane_latest_after & veh___649___.lane_single & !veh___649___.abort_lc & !next(veh___649___.abort_lc): 
        case 
            veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_max  : next(veh___649___.change_lane_now) = 0 ? veh___649___.lane_unchanged : veh___649___.lane_move_up;
            veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_min  : next(veh___649___.change_lane_now) = 0 ? veh___649___.lane_unchanged : veh___649___.lane_move_down;
            TRUE : veh___649___.lane_unchanged;
        esac;
        -- at the latest point in time, we need to leave the source lane if we have not already
        veh___649___.lc_timer = leave_src_lane_latest_after & veh___649___.lane_single: 
        case
                veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_max  : veh___649___.lane_move_up; 
                veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_min  : veh___649___.lane_move_down;
                TRUE : veh___649___.lane_unchanged;
        esac;
        -- lane change is finished in the next step (time conditions are checked at do_lane_change), set state to target lane (we must be on two lanes right now)
        veh___649___.lc_timer > 0 & next(veh___649___.do_lane_change) = FALSE & veh___649___.lane_crossing & !veh___649___.abort_lc & !next(veh___649___.abort_lc) : 
        case  
            veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_max : veh___649___.lane_move_up; 
            veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_min : veh___649___.lane_move_down;
            TRUE : veh___649___.lane_unchanged;
        esac;
        -- there is an abort running and it is finished in the next step (time conditions are checked at do_lane_change), set state back to source lane (we must be on two lanes right now)
        veh___649___.lc_timer > 0 & !next(veh___649___.do_lane_change) & veh___649___.lane_crossing & veh___649___.abort_lc: 
        case
            veh___649___.lc_direction = ActionDir____LEFT & !veh___649___.lane_min: veh___649___.lane_move_down ;   
            veh___649___.lc_direction = ActionDir____RIGHT & !veh___649___.lane_max: veh___649___.lane_move_up;
            TRUE : veh___649___.lane_unchanged;
        esac;
        TRUE: veh___649___.lane_unchanged;                                      -- hold current value in all other cases
    esac;



--------------------------------------------------------
-- End: Non-ego Spec 
--------------------------------------------------------



---------------------------------------------------------------------
-- Here comes logic which is independent of EGO-less or EGO-full mode
---------------------------------------------------------------------
-- TODO: The ego not driving on the green stuff should be probably here, as well, once the section logic is there.
-- TODO: The ego lane logic (without lane change) should be probably here, as well.

VAR
   -- "cond" variables are in ego-less mode only there to mock the interface towards the BP
   ego.flCond_full : boolean; -- conditions for lane change to fast lane (lc allowed and desired)
   ego.slCond_full : boolean; -- conditions for lane change to slow lane (lc allowed and desired)
   ego.abCond_full : boolean; -- conditions for abort of lane change 
   -- EO "cond" variables are in ego-less mode only there to mock the interface towards the BP

   ego.abs_pos : integer;

FROZENVAR
   ego.v : 0 .. 0; -- ego.max_vel;

INIT ego.abs_pos = 0;

ASSIGN     
   next(ego.abs_pos) := ego.abs_pos + ego.v;


---------------------------------------------------------------------
-- EO logic which is independent of EGO-less or EGO-full mode
---------------------------------------------------------------------





