//============================================================================================================
// C O P Y R I G H T
//------------------------------------------------------------------------------------------------------------
/// \copyright (C) 2022 Robert Bosch GmbH. All rights reserved.
//============================================================================================================
/// @file

#include "cpp_parsing/cpp_parser.h"
#include "cpp_parsing/cpp_type_atomic.h"
#include "cpp_parsing/cpp_type_enum.h"
#include "earley/recognizer/earley_recognizer.h"
#include "earley/parser/earley_parser.h"
#include "static_helper.h"
#include "model_checking/simplification.h"
#include "model_checking/smv_parsing/smv_module.h"
#include "term_compound.h"
#include "model_checking/environment_model_generator.h"
#include "simulation/highway_image.h"
#include <map>
#include <algorithm>
#include <limits>
#include <sstream>
#include <fstream>
#include <vector>
#include <chrono>

#if __cplusplus >= 201703L // https://stackoverflow.com/a/51536462/7302562 and https://stackoverflow.com/a/60052191/7302562
#include <filesystem>
#endif

using namespace vfm;
using namespace fsm;

const std::string OPENING_BRACKET_STR{ StaticHelper::makeString(OPENING_BRACKET) };
const std::string CLOSING_BRACKET_STR{ StaticHelper::makeString(CLOSING_BRACKET) };
const std::string TEMP_VAR_BASE_NAME{ "TEMPORAREY" };
const std::string TEMP_VAR_ARRAYS_BASE_NAME{ "TEMPORARRAY" };

std::string CppParser::TARGET_PATH_FOR_MORTY_GUY_PROGRESS{};

constexpr bool CREATE_LIVE_PDF{ false };

const std::string INNER_SIMPLIFY_KEYWORD{ "simplify" };

static const std::set<std::string> IGNORE_THESE{
   MC_INTERACTIVE_MODE_CONSTANT_NAME,
   "mcint",
   "strin__",
   "ncInt__",
   "address_begin",
   "cnt_var",
   "wsp__" }; // TODO: is there a better way?

// Autogenerated function for meta rule:
// a * b ==> ((a * 10) * b) / 10 [[a: 'is_constant_non_integer']]
inline bool apply_rule_INCREASE_INT_PRECISION_BY_10_0(const TermPtr formula, const std::shared_ptr<FormulaParser> parser)
{
   if (formula->getOptorOnCompoundLevel() == "*") {
      TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
      TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
      if (MetaRule::is_constant_non_integer(formula_0) && MetaRule::no_check(formula)) {
         formula->replace(_div(_mult(_mult(formula_0, _val(10.000000)), formula_1), _val(10.000000)));
         return true;
      }
   }
   return false;
}

// Autogenerated function for meta rule:
// a * b ==> (a * (10 * b)) / 10 [[b: 'is_constant_non_integer']]
inline bool apply_rule_INCREASE_INT_PRECISION_BY_10_1(const TermPtr formula, const std::shared_ptr<FormulaParser> parser)
{
   if (formula->getOptorOnCompoundLevel() == "*") {
      TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
      TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
      if (MetaRule::is_constant_non_integer(formula_1) && MetaRule::no_check(formula)) {
         formula->replace(_div(_mult(formula_0, _mult(_val(10.000000), formula_1)), _val(10.000000)));
         return true;
      }
   }
   return false;
}

// Autogenerated function for meta rule:
// a / b ==> a * (1 / b) [[a: 'is_constant_non_integer']]
inline bool apply_rule_INCREASE_INT_PRECISION_BY_10_2(const TermPtr formula, const std::shared_ptr<FormulaParser> parser)
{
   if (formula->getOptorOnCompoundLevel() == "/") {
      TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
      TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
      if (MetaRule::is_constant_non_integer(formula_0) && MetaRule::no_check(formula)) {
         formula->replace(_mult(formula_0, _div(_val(1.000000), formula_1)));
         return true;
      }
   }
   return false;
}

// Autogenerated function for meta rule:
// a / b ==> a * (1 / b) [[b: 'is_constant_non_integer']]
inline bool apply_rule_INCREASE_INT_PRECISION_BY_10_3(const TermPtr formula, const std::shared_ptr<FormulaParser> parser)
{
   if (formula->getOptorOnCompoundLevel() == "/") {
      TermPtr formula_0 = formula->getTermsJumpIntoCompounds()[0];
      TermPtr formula_1 = formula->getTermsJumpIntoCompounds()[1];
      if (MetaRule::is_constant_non_integer(formula_1) && MetaRule::no_check(formula)) {
         formula->replace(_mult(formula_0, _div(_val(1.000000), formula_1)));
         return true;
      }
   }
   return false;
}

void createFSMOutput(
   const vfm::fsm::FSMs& fsm, 
   const std::string& base_file_name, 
   const std::vector<fsm::GraphvizOutputSelector> whichs, 
   const std::vector<std::string>& formats,
   const bool quiet = false)
{
   for (const auto which : whichs) {
      std::string which_str = which == GraphvizOutputSelector::all
         ? "all"
         : (which == GraphvizOutputSelector::data_only 
            ? "data_only"
            : (which == GraphvizOutputSelector::data_with_functions
               ? "data_with_functions"
               : (which == GraphvizOutputSelector::functions_only
                  ? "functions_only"
                  : "graph_only")));

      for (const auto& format : formats) {
         std::string full_file_name_dot = base_file_name + "_" + which_str + ".dot";
         if (!quiet) fsm.addNote("Exporting FSM in mode '" + which_str + "' to '" + full_file_name_dot + "." + format + ".");
         fsm.createGraficOfCurrentGraph(full_file_name_dot, true, format, false, which);
      }
   }
}

vfm::CppParser::CppParser(const std::string& command_line_argument) :
   Parsable("C++Parser"),
   type_abstraction_layer_{ std::make_shared<mc::TypeAbstractionLayer>() },
   command_line_argument_{ command_line_argument },
   data_{ std::make_shared<DataPack>() },
   parser_{ std::make_shared<FormulaParser>() }
{
   reset();
}

void vfm::CppParser::reset(const std::shared_ptr<DataPack> data_to_take_over, const bool has_env_model_data)
{
   addNote("Resetting.");
   setOutputLevels(ErrorLevelEnum::note, ErrorLevelEnum::error);

   if (ADDITIONAL_LOGGING_PIPE) {
      //addOrChangeErrorOrOutputStream(*ADDITIONAL_LOGGING_PIPE, true);
      addOrChangeErrorOrOutputStream(*ADDITIONAL_LOGGING_PIPE, false); // For now only redirect error stream of CppParser to GUI.
      addNote("Found additional logging pipe, adding it to the logger's error stream.");
   }

   if (smv_module_) smv_module_->clear();

   if (!has_env_model_data) {
      type_abstraction_layer_ = std::make_shared<mc::TypeAbstractionLayer>();
   }

   if (!command_line_argument_.empty()) {
      addNote("Preliminarily processing the command line input to have the options right from the start (will be repeated during tactical planner run).");
      preprocessProgram("", true);
   }

   if (options_.isGatekeeper()) {
      addNote("Entering gatekeeper mode.");
   }

   if (!has_env_model_data) {
      MathStruct::rand_vars = std::vector<float>{ 100 };
      MathStruct::rand_var_count = 0;
      MathStruct::first_free_private_var_num_ = 0;
      MathStruct::resetAllRules();

      data_ = std::make_shared<DataPack>();
      data_->initializeValuesBy(data_to_take_over);
      parser_ = std::make_shared<FormulaParser>();

      type_abstraction_layer_->setFailableName(mc::TYPE_ABSTRACTION_LAYER_FAILABLE_NAME);
      types_of_variables_.clear();
      variables_ordering_.clear();
      data_types_.clear();
      addAtomicDataTypes();
      function_aka_from_new_to_old_.clear();
      global_primitives_aka_descriptions_.clear();
      global_primitives_tal_range_descriptions_.clear();
      global_primitives_init_values_.clear();
      mc_specs_.first.clear();
      mc_specs_.second.clear();
      temp_variable_counter_ = 0;
      parser_->addDefaultDynamicTerms();
      ltl_parser_ = std::make_shared<FormulaParser>();
      ctl_parser_ = std::make_shared<FormulaParser>();
      ltl_parser_->addDefaultDynamicTerms();
      ctl_parser_->addDefaultDynamicTerms();
      //ltl_parser_->addnuSMVOperators(TLType::LTL);
      //ctl_parser_->addnuSMVOperators(TLType::CTL);
   }

   addFailableChild(Failable::getSingleton(), "");
   addFailableChild(Failable::getSingleton(FAILABLE_NAME_SANITY_CHECK));
   addFailableChild(Failable::getSingleton(FAILABLE_NAME_CPP_DATATYPES));
   addFailableChild(Failable::getSingleton(FAILABLE_NAME_FOR_AKA_REPLACEMENT));
   addFailableChild(type_abstraction_layer_);

   if (!parser_->getDynamicTermMeta(SYMB_NONDET_FUNCTION_FOR_MODEL_CHECKING, 2)) {
      StaticHelper::addNDetDummyFunctions(parser_, data_);
   }

   static const std::map<std::string, std::pair<CppTypeWithQualifiers, std::string>> HARDCODED{
      { "ego.gaps___609___.v_front", {{ std::make_shared<CppTypeAtomic>("Int", DataPack::AssociationType::None, -1, 70), {} }, "-1" }},
      { "ego.gaps___619___.v_front", {{ std::make_shared<CppTypeAtomic>("Int", DataPack::AssociationType::None, -1, 70), {} }, "-1" }},
      { "ego.gaps___629___.v_front", {{ std::make_shared<CppTypeAtomic>("Int", DataPack::AssociationType::None, -1, 70), {} }, "-1" }},
      { "ego.action.type", {{ std::make_shared<CppTypeEnum>("ActionType", std::vector<std::string>{
         "UNDEFINED",
         "OFFROAD",
         "LANE_FOLLOWING",
         "LANECHANGE_LEFT",
         "LANECHANGE_RIGHT",
         "LANECHANGE_ABORT",
         "CONVERGE_TO_LANE",
         "EGO_OPEN_LOOP",
         "IN_COLLISION"
      }), {} }, "LANE_FOLLOWING"}}
   };

   for (const auto& VAR_PAIR : HARDCODED) {
      auto VAR{ VAR_PAIR.first };
      auto TYPE{ VAR_PAIR.second.first };
      auto INIT_VALUE{ VAR_PAIR.second.second };
      if (!type_abstraction_layer_->contains(VAR) || !types_of_variables_.count(VAR)) {
         type_abstraction_layer_->addVariableWithTypeByDerivingFrom(VAR, TYPE.first, INIT_VALUE);
         insertTypeOfVariable(VAR, TYPE, true);
         fillTypeIntoTAL(VAR, type_abstraction_layer_);
         addWarning("TODO<1>: The variable '" + VAR + "' has been hardcoded to '" + TYPE.first->toString() + "'. Needs to be solved on env model side eventually. For DEFINEs, the type cannot be inferred automatically, yet.");
      }
   }

   main_function_name_ = "";
   options_.reset(); // Clears pointerized_arguments_in_operators_.
   using_mapping_.clear();
   function_definitions_.clear();
   function_signatures_.clear();
   ignore_tokens_for_functions_ = { "const", "&" };
   grammars_for_chunks_.clear();

   data_->addOrSetSingleVal("true", 1, false, true);  // C++ constant
   data_->addOrSetSingleVal("false", 0, false, true); // C++ constant
   data_->addOrSetSingleVal("TRUE", 1, false, true);  // nuxmv constant
   data_->addOrSetSingleVal("FALSE", 0, false, true); // nuxmv constant

   // Mappings from C++ functions to vfm functions.
   parser_->addDynamicTerm(MathStruct::parseMathStruct("max(p_(0), p_(1))")->toTermIfApplicable(), "std::max", true);
   parser_->addDynamicTerm(MathStruct::parseMathStruct("min(p_(0), p_(1))")->toTermIfApplicable(), "std::min", true);
   parser_->addDynamicTerm(MathStruct::parseMathStruct("abs(p_(0))")->toTermIfApplicable(), "std::abs", true);
   parser_->addDynamicTerm(MathStruct::parseMathStruct("sqrt(p_(0))")->toTermIfApplicable(), "vfc::sqrt", true);
   
   // Helper functions for parsing process.
   parser_->addDynamicTerm(MathStruct::parseMathStruct("id(p_(0))")->toTermIfApplicable(), INNER_SIMPLIFY_KEYWORD, true);

   // Grammars for gatekeepers.
   earley::Grammar enum_class_grammar(START_SYMBOL_ENUM_CLASS);
   enum_class_grammar.addProductions(GRAMMAR_GENERAL_RULES);
   enum_class_grammar.addProductions(GRAMMAR_RULES_FOR_ENUM_CLASS);
   enum_class_grammar.declareTrailingSymbolsAsTerminal();
   // grammars_for_chunks_.insert({ ChunkTypeEnum::EnumClass, enum_class_grammar });
}

void removeCppNumTypeDenotersFromNumber(std::string& number_string) {
   number_string.erase(std::remove_if(number_string.begin(), number_string.end(),
                                      [](char c) { return !std::isdigit(c) && c != '.'; }),
                       number_string.end());
}

ChunkTypeEnum vfm::CppParser::findIndices(
   std::string& program,
   std::string& chunk,
   std::string& name,
   std::string& type,
   std::vector<std::string>& signature,
   int& beg,
   int& end,
   std::vector<int>& except,
   std::string& namespace_str,
   std::deque<std::string>& relevant_prefix_tokens,
   std::vector<std::string>& father_classes) const {
   ChunkTypeEnum t(ChunkTypeEnum::Unknown);
   relevant_prefix_tokens.clear();
   father_classes.clear();

   std::string pprog = program;
   for (int num : except) {
      if (num >= 0 && num < pprog.size()) {
         pprog[num] = '#';
      }
   }

   beg = StaticHelper::indexOfFirstInnermostBeginBracket(pprog, "{", "}", { "/*" }, { "*/" });

   if (beg < 0) return ChunkTypeEnum::None;

   end = StaticHelper::findMatchingEndTagLevelwise(pprog, "{", "}", beg, { "/*" }, { "*/" });
   int beg_temp = beg;

   auto tokens = StaticHelper::tokenize(
      program, 
      *SingletonFormulaParser::getLightInstance(), 
      beg_temp, 
      std::numeric_limits<int>::max(), 
      true, 
      DEFAULT_REGEX_FOR_TOKENIZER, 
      DEFAULT_IGNORE_CLASS_FOR_TOKENIZER, 
      false, true, AkaTalProcessing::none, {}, true);

   int level2 = 0;
   for (int i = 1; i < tokens->size() - 2; i++) { // Braces within struct always treated as brace initializer.
      if (tokens->at(i) == "{") {
         level2++;
      }
      else if (tokens->at(i) == "}") {
         level2--;
      }

      if (level2 == 1) {
         while (i < tokens->size() - 2 && StaticHelper::isAlphaNumericOrUnderscoreOrColonOrComma(tokens->at(i + 2))) {
            if (tokens->at(i + 2) == "struct" || (tokens->at(i + 2) == "class")) {
               if (end == beg + 1) { // It's {}; TODO: This doesnt't cover {*WS*}; better always include '=' and treat later.
                  program[beg] = '=';
                  program[end] = '0';
               }
               else {
                  program[beg] = '=';
                  program[end] = ' ';
               }

               return ChunkTypeEnum::BraceInitializer;
            }

            i++;
         }

         break;
      }
   }

   std::string last;
   std::string lastlast;
   std::string lastlastlast;

   for (int i = 0; i < tokens->size(); i++) {
      std::string token = tokens->at(i);

      if (token == "{" && last == "{") { // Within initialization T x{...{...{...}...}...};
         break;
      }

      relevant_prefix_tokens.push_front(token);

      if (t != ChunkTypeEnum::Function && token == "enum") {
         if (last == "class") {
            t = ChunkTypeEnum::EnumClass;
            name = lastlast;
         }
         else {
            t = ChunkTypeEnum::Enum;
            name = last;
         }

         break;
      }
      else if (token == "namespace") {
         t = ChunkTypeEnum::Namespace;
         break;
      }
      else if (i == 1 && token == "=") { // If it's a "=" and it came right after the "{".
         program[beg] = ' ';
         program[end] = ' ';
         break; // Ignore member initializations as in "m_state = {LastStateMachineState::passive}".
      }
      else if (token == CLOSING_BRACKET_STR) {
         bool opening_bracket_found = false;
         bool name_found = false;
         std::string type_name;
         int max = i + 1;

         for (int j = i + 1; j < tokens->size(); j++) {
            auto token2 = tokens->at(j);

            if (name_found) {
               type_name = token2;
               break;
            }

            if (opening_bracket_found) {
               name_found = true;
            }

            if (token2 == OPENING_BRACKET_STR) {
               opening_bracket_found = true;
            }

            max = j;
         }

         t = ChunkTypeEnum::Unknown;
         for (const auto& el : data_types_) {
            if (el->getName() == type_name) {
               t = ChunkTypeEnum::Function;
               break;
            }
         }
      }
      else if (token == OPENING_BRACKET_STR) {
         relevant_prefix_tokens.push_front(tokens->at(i + 1));
         relevant_prefix_tokens.push_front(tokens->at(i + 2));

         name = tokens->at(i + 1);
         type = tokens->at(i + 2);
         break;
      }
      else if (t != ChunkTypeEnum::Function && (token == "struct" || (token == "class" && (tokens->size() <= i + 1 || tokens->at(i + 1) != "enum")))) {
         bool is_struct_or_class = true;

         for (int j = i - 2; j >= 1; j--) { // tokens->at(1) is "{". First two are struct/class and the name.
            if (StaticHelper::isAlphaNumericOrUnderscoreOrColonOrComma(tokens->at(j))) {
               if (tokens->at(j) != "," && tokens->at(j) != ":" && tokens->at(j) != "public" && tokens->at(j) != "protected" && tokens->at(j) != "private") {
                  father_classes.push_back(tokens->at(j));
               }
            } else {
               is_struct_or_class = false;
               break;
            }
         }
         
         if (is_struct_or_class) {
            t = ChunkTypeEnum::Struct;
            name = last;
            break;
         }
      }
      else if (t == ChunkTypeEnum::Function) {
         std::string new_name = token;
         signature.insert(signature.begin(), new_name);
      }

      lastlastlast = lastlast;
      lastlast = last;
      last = token;
   }

   if (beg >= 0 && end >= 0) {
      chunk = program.substr(beg, end - beg + 1);
      namespace_str = findSurroundingNamespace(program, (end + beg) / 2);

      if (t != ChunkTypeEnum::Unknown) {
         program = StaticHelper::substrComplement(program, beg, end - beg + 1);
         except.clear();
      }

      return t;
   }

   return ChunkTypeEnum::None;
}

std::vector<std::shared_ptr<CppTypeStruct>> getPredefinedAtomicDatatypes() {
   std::vector<std::shared_ptr<CppTypeStruct>> data_types;

   data_types.push_back(std::make_shared<CppTypeAtomic>("void", DataPack::AssociationType::None));
   data_types.push_back(std::make_shared<CppTypeAtomic>("int", DataPack::AssociationType::None));
   data_types.push_back(std::make_shared<CppTypeAtomic>("Int", DataPack::AssociationType::None));
   data_types.push_back(std::make_shared<CppTypeAtomic>("Int64", DataPack::AssociationType::None));
   data_types.push_back(std::make_shared<CppTypeAtomic>("Real", DataPack::AssociationType::None));
   data_types.push_back(std::make_shared<CppTypeAtomic>("Float", DataPack::AssociationType::Float));
   data_types.push_back(std::make_shared<CppTypeAtomic>("float", DataPack::AssociationType::Float));
   data_types.push_back(std::make_shared<CppTypeAtomic>("bool", DataPack::AssociationType::Bool));
   data_types.push_back(std::make_shared<CppTypeAtomic>("vfc::uint8_t", DataPack::AssociationType::Char));
   data_types.push_back(std::make_shared<CppTypeAtomic>("vfc::uint16_t", DataPack::AssociationType::Char));
   data_types.push_back(std::make_shared<CppTypeAtomic>("vfc::uint32_t", DataPack::AssociationType::Char));
   data_types.push_back(std::make_shared<CppTypeAtomic>("vfc::float32_t", DataPack::AssociationType::Float));
   data_types.push_back(std::make_shared<CppTypeAtomic>("vfc::CSI::si_scalar_f32_t", DataPack::AssociationType::Float));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_kilo_gram_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_milli_second_ui16_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_second_ui32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_degree_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_percent_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_percent_ui8_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_per_metre_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_second_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_metre_per_cubic_second_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_metre_per_square_second_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_milli_second_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_milli_second_ui32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_metre_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_miles_per_hour_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_kilometre_per_hour_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE));
   data_types.push_back(std::make_shared<CppTypeAtomic>(
      "vfc::CSI::si_metre_per_second_f32_t",
      DataPack::AssociationType::Float,
      DEFAULT_VFC_ASSOCIATIVITY_SUITE,
      _equation(_var(IN_VAR_NAME), _mult(_var(OUT_VAR_NAME), _val(3.6))),
      _equation(_var(OUT_VAR_NAME), _div(_var(IN_VAR_NAME), _val(3.6)))));

   return data_types;
}

void vfm::CppParser::addAtomicDataTypes()
{
   for (const auto& datatype : getPredefinedAtomicDatatypes()) {
      data_types_.push_back(datatype);
   }

   for (const auto& d : data_types_) {
      //ignore_tokens_for_functions_.insert(d->getName());
   }

   insertTypeOfVariable("false", { std::make_shared<CppTypeAtomic>(IMMUTABLE_BOOL_CONST_TYPE_NAME, DataPack::AssociationType::Bool), {} });
   insertTypeOfVariable("true", { std::make_shared<CppTypeAtomic>(IMMUTABLE_BOOL_CONST_TYPE_NAME, DataPack::AssociationType::Bool), {} });
}

void findNextNotWithinQuotesCore(const std::string& code, const std::string& keyword, int& pos) 
{
   pos = code.find(keyword, pos);

   while (pos >= 0 && StaticHelper::isWithinLevelwise(code, pos, "\"", "\"")) {
      pos = code.find(keyword, pos + 1);
   }
}

int findNextNotWithinQuotes(const std::string& code, const std::string& keyword, const int pos = 0) 
{
   int pos_dummy = pos;
   findNextNotWithinQuotesCore(code, keyword, pos_dummy);
   return pos_dummy;
}

int findNext(const std::string& code, const std::string& keyword, const int pos = 0)
{
   return code.find(keyword, pos); // Currently this version is used almost everywhere. TODO: Quote check necessary?
}

std::string fetchVfmOptionBlock(const std::string& program, const int pos)
{
   int pos_begin_bracket = program.find(TAG_OPTION_OPENING_BRACKET, pos);
   int pos_end_bracket = StaticHelper::findMatchingEndTagLevelwise(program, pos_begin_bracket, TAG_OPTION_OPENING_BRACKET, TAG_OPTION_CLOSING_BRACKET);
   std::string code_result = program.substr(pos_begin_bracket + TAG_OPTION_OPENING_BRACKET.size(), pos_end_bracket - pos_begin_bracket - TAG_OPTION_CLOSING_BRACKET.size());
   StaticHelper::trim(code_result);
   return code_result;
}

void vfm::CppParser::parseOptions(const std::string& program)
{
   int pos = findNext(program, VFM_OPTION_DENOTER);

   while (pos >= 0) {
      std::string option_code = fetchVfmOptionBlock(program, pos);
      auto keys_values = StaticHelper::extractKeyValuePairs(option_code, OPTION_EQUAL_SIGN);

      options_.fetchOptions(keys_values, type_abstraction_layer_, this);

      pos = findNext(program, VFM_OPTION_DENOTER, pos + 1);
   }
}

void vfm::CppParser::performCodeInjection(const std::string& program) const
{
   int pos = findNext(program, VFM_INJECTION_DENOTER);

   while (pos >= 0) {
      std::string code_to_inject = fetchVfmOptionBlock(program, pos);
      addNote("Injecting code: '" + code_to_inject + "'.");

      auto fmla = MathStruct::parseMathStruct(code_to_inject, true, true, parser_, data_);
      fmla->eval(data_, parser_);

      pos = findNext(program, VFM_INJECTION_DENOTER, pos + 1);
   }
}

void vfm::CppParser::performTalOrAkaConversion(std::string& program, const VariableSpecifierMode aka_mode) const
{
   const std::string mode_denoter = aka_mode == VariableSpecifierModeEnum::AKA 
      ? STRING_PREFIX_AKA 
      : (aka_mode == VariableSpecifierModeEnum::TAL 
         ? STRING_PREFIX_TAL
         : STRING_PREFIX_INIT); // Two dots for TAL, three for AKA, four for INIT.

   const std::string mode_name = aka_mode == VariableSpecifierModeEnum::AKA 
      ? "AKA" 
      : (aka_mode == VariableSpecifierModeEnum::TAL 
         ? "TAL"
         : "INIT");

   int pos = findNext(program, aka_mode.getEnumAsString());

   while (pos >= 0) {
      std::string tal_denoter = fetchVfmOptionBlock(program, pos);
      std::string result = mode_denoter + StaticHelper::safeString(tal_denoter);
      addDebug("Processed " + mode_name + " denoter '" + tal_denoter + "' to safe string '" + result + "'.");

      int end_pos = program.find(TAG_OPTION_CLOSING_BRACKET, pos);
      std::string before = program.substr(0, pos);
      std::string after = program.substr(end_pos + TAG_OPTION_CLOSING_BRACKET.size());

      program = before + result + after;

      pos = findNext(program, aka_mode.getEnumAsString(), pos + 1);
   }
}

std::string vfm::CppParser::serializeNuSMV(
   const MCTranslationTypeEnum translation_type,
   const MCSpecification& MC_specs,
   const std::set<std::string> blacklist)
{
   auto formula{ function_definitions_.at(main_function_name_) };
   formula->findSetVariables(data_);

   for (const auto& ignore_item : blacklist) {
      all_fsm_controlled_variables_.erase(ignore_item);
      all_fsm_controlled_variables_.erase(SYMB_REF + ignore_item);
   }

   std::string s{};

   if (translation_type == MCTranslationTypeEnum::fan_out_non_atomic_states) {
      mc::MCTypeWithValueGetter last_type = type_abstraction_layer_->getMCIntegerType(1, 230, "last"); // TODO

      mc::FullType full_type{
         nullptr,
         last_type.first.first,
         last_type.first.second,
         last_type.second,
      };

      type_abstraction_layer_->addVariableWithType("last", full_type, mc::MCInitialValue("1"));
   }

   s += "MODULE main\n";

   // Define constants.
   std::pair<std::map<std::string, std::string>, std::string> dummy{};
   for (const auto& cvar : all_constants_to_model_checker_) {
      s += getInitVarStringNuSMVOrKratos(cvar, dummy);
   }

   // Declare external variables.
   s += "\n";
   s += "VAR\n";
   for (const auto& evar : all_external_variables_) {
      s += getInitVarStringNuSMVOrKratos(evar, dummy);
   }

   if (translation_type == MCTranslationTypeEnum::emulate_program_counter) {
      s += "\n";
      s += "   pc : 0..$$$PLACEHOLDER$$$;\n";
   }

   // Declare internal variables.
   s += "\n";
   for (const auto& ivar : all_fsm_controlled_variables_) {
      s += getInitVarStringNuSMVOrKratos(ivar, dummy);
   }

   if (translation_type == MCTranslationTypeEnum::fan_out_non_atomic_states) {
      s += getInitVarStringNuSMVOrKratos("last", dummy);
   }

   //Add INIT blocks containing initial state constraints if there are any, nuSMV permits multiple init blocks per model
   for (const auto init_constr : all_initial_state_constraints_) {
      s += "\nINIT " + init_constr->serializeNuSMV(data_, parser_) + ";";
   }

   s += "\n";

   for (const auto invar : all_invariants_) {
      s += "\nINVAR " + invar->serializeNuSMV(data_, parser_) + ";";
   }

   s += "\n\n";
   s += "ASSIGN\n";
   // Initialize external variables (shouldn't be done to allow model checker to check all combinations of inital states).
   // for (const auto& ivar : all_external_variables_) {
   //    s += getInitVarStringNuSMVOrKratos(ivar, true);
   // }

   // s += "\n";

   // Initialize internal variables.
   for (const auto& ivar : all_fsm_controlled_variables_) {
      //if (!state_name_to_state_id_.count(ivar)) { // Exclude state names. // Only for old-style nuxmv translation modes.
         s += getInitVarStringNuSMVOrKratos(ivar, dummy, true);
      //}
   }

   if (translation_type == MCTranslationTypeEnum::emulate_program_counter) {
      s += "\n";
      s += "   init(pc) := 1;\n"; //TODO: shouldn't this start at 0? at least we reset it to zero
   }
   else if (translation_type == MCTranslationTypeEnum::fan_out_non_atomic_states) {
      s += "   init(last) := 1;\n";
   }

   s += "\n";
   //s += serializeTransitionFunctionNuSMV(translation_type);
   s += "serializeTransitionFunctionNuSMV(translation_type) NOT impleneted.";

   s += "\n";
   int max_pc = 0;
   //s += serializeCallbacksNuSMV(translation_type, max_pc);
   s += "TODO: serializeCallbacksNuSMV is currently not implemented properly.";
   s = StaticHelper::replaceAll(s, "$$$PLACEHOLDER$$$", std::to_string(max_pc)); // insert max pc value into definition of the variable

   s += "\n\n";

   for (const auto& ltl_spec : MC_specs.first) {
      s += "LTLSPEC " + ltl_spec->serializeNuSMV(data_, parser_) + "\n";
   }

   for (const auto& ctl_spec : MC_specs.second) {
      s += "CTLSPEC " + ctl_spec->serializeNuSMV(data_, parser_) + "\n";
   }

   return s;
}

void vfm::CppParser::collectLTLSpecs(const std::string& program)
{
   int pos = findNext(program, VFM_LTL_SPEC_DENOTER);

   while (pos >= 0) {
      std::string ltl_to_collect = fetchVfmOptionBlock(program, pos);
      addNote("Collected LTL: '" + ltl_to_collect + "'.");
      addConstraint(ltl_to_collect, mc_specs_.first, ltl_parser_);
      pos = findNext(program, VFM_LTL_SPEC_DENOTER, pos + 1);
   }
}

void vfm::CppParser::collectCTLSpecs(const std::string& program)
{
    int pos = findNext(program, VFM_CTL_SPEC_DENOTER);

    while (pos >= 0) {
        std::string ctl_to_collect = fetchVfmOptionBlock(program, pos);
        addNote("Collected CTL: '" + ctl_to_collect + "'.");
        addConstraint(ctl_to_collect, mc_specs_.second, ctl_parser_);
        pos = findNext(program, VFM_CTL_SPEC_DENOTER, pos + 1);
    }
}

void vfm::CppParser::collectKratosSpecs(const std::string& program)
{
   int pos = findNext(program, VFM_KRATOS_SPEC_DENOTER);

   while (pos >= 0) {
      std::string spec_to_collect = fetchVfmOptionBlock(program, pos);
      addNote("Collected kratos spec: '" + spec_to_collect + "'.");
      addConstraint(spec_to_collect, getKratosSpecs());
      pos = findNext(program, VFM_KRATOS_SPEC_DENOTER, pos + 1);
   }
}

void vfm::CppParser::collectInitConstraints(const std::string& program) {
    int pos = findNext(program, VFM_INITIAL_STATE_CONSTRAINT_DENOTER);

    while (pos >= 0) {
        std::string init_constraint_to_collect = fetchVfmOptionBlock(program, pos);
        addNote("Collected Init State Constraint: '" + init_constraint_to_collect + "'.");
        addConstraint(init_constraint_to_collect, getInitialStateConstraints());
        pos = findNext(program, VFM_INITIAL_STATE_CONSTRAINT_DENOTER, pos + 1);
    }
}

void vfm::CppParser::collectInvariants(const std::string& program) {
    int pos = findNext(program, VFM_INVARIANT_DENOTER);

    while (pos >= 0) {
        std::string invariant_to_collect = fetchVfmOptionBlock(program, pos);
        addNote("Collected Invariant: '" + invariant_to_collect + "'.");
        addConstraint(invariant_to_collect, getInvariants());
        pos = findNext(program, VFM_INVARIANT_DENOTER, pos + 1);
    }
}

void vfm::CppParser::processUsingKeyword(std::string& code_without_comments)
{
   addNote("Processing 'using' keyword.");
   int pos = 0;
   findNextNotWithinQuotesCore(code_without_comments, "using", pos);

   while (pos >= 0) {
      int pos2 = code_without_comments.find(';', pos);
      std::string using_str = code_without_comments.substr(pos, pos2 - pos);
      std::string alias = StaticHelper::split(using_str, '=')[0];
      std::string origin = StaticHelper::split(using_str, '=')[1];

      alias = StaticHelper::replaceAll(alias, "using", "");
      origin = StaticHelper::replaceAll(origin, ";", "");
      StaticHelper::trim(alias);
      StaticHelper::trim(origin);

      addDebug("Using '" + alias + "' for '" + origin + "'.");

      if (using_mapping_.count(alias)) {
         addError("Conflicting use of 'using'. '" + alias + "' defined as both '" + origin + "' and '" + using_mapping_.at(alias) + "'.");
      }
      else {
         using_mapping_.insert({ alias, origin });
      }

      for (size_t i = pos; i <= pos2; i++) {
         code_without_comments[i] = '-';
      }

      pos++;
      findNextNotWithinQuotesCore(code_without_comments, "using", pos);
   }
}

void uniqueInsertInto(std::vector<std::string>& vars_ordered, const std::string& var_name)
{ // TODO: Could be made more efficient by looking into types_of_variables_, which is a map.
   if (std::find(vars_ordered.begin(), vars_ordered.end(), var_name) == vars_ordered.end()) {
      vars_ordered.push_back(var_name);
   }
}

void vfm::CppParser::insertTypeOfVariable(const std::string& var_name, const CppTypeWithQualifiers& type, const bool force_override)
{
   if (force_override) { // No check if variable already registered.
      types_of_variables_[var_name] = type;
      uniqueInsertInto(variables_ordering_, var_name);
   }
   else {
      if (types_of_variables_.insert({ var_name, type }).second) {
         uniqueInsertInto(variables_ordering_, var_name);
      }
      else { // When !force_override and variable already registered, we check the new entry for consistency.
         auto old_type = types_of_variables_.at(var_name).first->getName();
         auto new_type = type.first->getName();
         auto old_qualifiers = types_of_variables_.at(var_name).second;
         auto new_qualifiers = type.second;

         if (new_type == old_type) {
            auto old_qualifiers_str = StaticHelper::tokensAsString(old_qualifiers);
            auto new_qualifiers_str = StaticHelper::tokensAsString(new_qualifiers);

            if (StaticHelper::removeWhiteSpace(old_qualifiers_str) == StaticHelper::removeWhiteSpace(new_qualifiers_str)) {
               addDebug("Variable '" + var_name + "' of type '" + new_type + "' already registered, no action is taken. Note, though, that variable scopes are not supported so far.");
            }
            else {
               addWarning("Variable '" + var_name + "' of type '" + new_type + "' already registered, but qualifiers differ...");
               addWarningPlain("Old qualifiers: '" + old_qualifiers_str + "' (these are kept).");
               addWarningPlain("New qualifiers: '" + new_qualifiers_str + "' (these are ignored).");
            }
         } else { 
            addError("Variable '" + var_name + "' of type '" + new_type + "' cannot be registered, it is already associated to type '" + old_type + "'. Note that variable scopes are currently not supported.");
         }
      }
   }
}

std::string vfm::CppParser::recoverRangeDescriptionForIntVariables(const std::shared_ptr<std::string> range_description, int& low, int& high, const std::string& member) const
{
   if (!range_description) {
      addError("Empty range description received for member '" + member + "'.");
      return "";
   }

   std::string plain_range = StaticHelper::fromSafeString(range_description->substr(2));

   addDebug("Recovered range description '" + plain_range + "' from safe string '" + *range_description + "'.");

   auto pair = StaticHelper::split(plain_range, STRING_PREFIX_TAL); // Assuming ".." cannot be part of any valid C++ token.

   auto fmla_low = MathStruct::parseMathStruct(pair[0], parser_, data_);
   auto fmla_high = MathStruct::parseMathStruct(pair[1], parser_, data_);

   checkForUndeclaredVariables(fmla_low);
   checkForUndeclaredVariables(fmla_high);

   low = fmla_low->eval(data_, parser_);
   high = fmla_high->eval(data_, parser_);

   std::string new_string = std::to_string(low) + STRING_PREFIX_TAL + std::to_string(high);

   if (plain_range != new_string) {
      addDebug("Translating TAL range for '" + member + "' from '" + plain_range + "' to '" + new_string + "'.");
   }
   else {
      addDebug("Adding plain TAL range for '" + member + "' given by '" + plain_range + "'.");
   }

   std::string low_str = low >= 0 ? std::to_string(low) : "--(" + std::to_string(-low) + ")";
   std::string high_str = high >= 0 ? std::to_string(high) : "--(" + std::to_string(-high) + ")";

   return "rndet(" + low_str + ", " + high_str + ")";
}

std::string vfm::CppParser::getTypeBaseName(const std::string& member) const
{
   if (StaticHelper::stringStartsWith(member, GLOBAL_VARIABLES_PREFIX)) {
      return member;
   }

   int pos = member.find(".", isLocalVarName(member).size() + 1); // local function name empty leads to start at 1; ok since dot at pos 0 not allowed.

   while (StaticHelper::isWithinAnyLevelwise(member, pos, { ARRAY_INDEX_DENOTER_OPEN }, { ARRAY_INDEX_DENOTER_CLOSE })) {
      pos = member.find(".", pos + 1);
   }

   return pos < 0
      ? member
      : member.substr(0, pos);
}

void vfm::CppParser::processTypeForTAL(
   const vfm::TypeWithInitAndRangeOrAka& pair, 
   const std::string& NO_INIT_DENOTER, 
   const std::string& member, 
   const vfm::CppType& type,
   const std::shared_ptr<mc::TypeAbstractionLayer> tal) const
{

   bool quiet = tal != type_abstraction_layer_; // Only write warnings if working on REAL tal.

   auto init_value = pair.second.first;
   std::string init_value_str = WARNING_COLOR + NO_INIT_DENOTER + RESET_COLOR;

   data_->declareVariable(member, type->isConst());

   auto aka_description = pair.second.second.second;
   auto range_description = pair.second.second.first;

   if (!range_description && global_primitives_tal_range_descriptions_.count(member)) {
      range_description = std::make_shared<std::string>(global_primitives_tal_range_descriptions_.at(member));
   }

   if (!aka_description && global_primitives_aka_descriptions_.count(member)) {
      aka_description = std::make_shared<std::string>(global_primitives_aka_descriptions_.at(member));
   }

   if (aka_description && range_description) {
      addError("Variable '" + member + "' has both a TAL and an AKA description attached. Which one is it?");
   }

   if (init_value || global_primitives_tal_range_descriptions_.count(member)) { // We need an init value for model checking, except for parameters which are input to a function.
      int low = 0;
      int high = 0;
      std::string plain_range;

      if (range_description) {
         plain_range = recoverRangeDescriptionForIntVariables(range_description, low, high, member);
      }

      if (!init_value && plain_range.empty()) {
         addError("Range description missing for '" + member + "'.");
      }

      init_value_str = init_value ? *init_value : plain_range;

      if (StaticHelper::stringStartsWith(init_value_str, STRING_PREFIX_INIT)) {
         init_value_str = StaticHelper::fromSafeString(StaticHelper::replaceAll(init_value_str, STRING_PREFIX_INIT, ""));
      }

      auto init_value_fmla = init_value_str == FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER
         ? _val(12345) // Use strange arbitrary value. It shouldn't pop up anywhere in nusmv code, and when we see it in the data pack we are reminded that the init value is irrelevant.
         : MathStruct::parseMathStruct(init_value_str, parser_, data_);
      int last_dot_pos = member.find_last_of('.');

      if (last_dot_pos != std::string::npos) { // Handle local variables in structs during initialization. E.g. struct A { int x = 4; int y = x; };
         std::string member_qualification = member.substr(0, last_dot_pos + 1); // We use the actual instance A a which "member" is part of; i.e., replace "a.y = x" with "a.y = a.x".

         init_value_fmla->applyToMeAndMyChildrenIterative([&member_qualification, this](const MathStructPtr m) {
            auto m_var = m->toVariableIfApplicable();

            if (m_var) {
               std::string possible_qualified_name = member_qualification + m_var->getVariableName();
               if (data_->isDeclared(possible_qualified_name)) { // ...But we only replace x with a.x if a.x is declared. Otherwise, a global variable can be meant.
                  m_var->setVariableName(possible_qualified_name); // Raison: only members of A can be used in initialization like this. If it's not a.x, it has to be a global x.
               }                                                   // If it is declared, AND there is a global variable x, too, a.x is still the correct choice due to scoping. (TODO: Check if this is actually true...)
            }
         }, TraverseCompoundsType::avoid_compound_structures);
      }

      if (init_value_str != FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER) { // Update init_value_str with possibly newly qualified variable names.
         init_value_str = init_value_fmla->serializePlainOldVFMStyle();
      }

      //init_value_fmla = MathStruct::parseMathStruct(init_value_fmla->serialize(), parser_, data_)->toTermIfApplicable();

      if (!quiet) {
         checkForUndeclaredVariables(init_value_fmla);
      }

      float init_val = init_value_fmla->eval(data_, parser_);
      data_->addOrSetSingleVal(member, init_val);

      if (!tal->getVariablesWithTypes().count(member)) {
         if (!type->toAtomicIfApplicable()) {
            addFatalError("Unexpected complex type found.");
         }

         if (type->toEnumIfApplicable()) {
            tal->addVariableWithEnumType(member, type->toEnumIfApplicable(), init_value_str);

            if (range_description && !quiet) {
               addWarning("Ignored unnecessary TAL range description '" + *range_description + "' for enum type.");
            }
         }
         else if (type->toAtomicIfApplicable() && type->getName() == "bool") {
            tal->addBooleanVariable(member, init_value_str);

            if (range_description && !quiet) {
               addWarning("Ignored unnecessary TAL range description '" + *range_description + "' for bool type.");
            }
         }
         else if (range_description) {
            tal->addIntegerVariable(member, low, high, init_value_str);
         }
         else {
            const auto type = types_of_variables_.count(member) ? types_of_variables_.at(member).first : nullptr;

            if (type && type->toAtomicIfApplicable() && type->toAtomicIfApplicable()->getBaseType() == DataPack::AssociationType::Float) {
               addWarning("Variable '" + member + "' has no TAL info attached, deriving type from 'types_of_variables_', which is Float ==> int.");
               tal->addIntegerVariable(member, 0, 1);
            }
            else {
               tal->addDummyTypeVariable(member, init_value_str, "float", DataPack::AssociationType::Float);

               if (!quiet) {
                  addDebug("Variable '" + member + "' has no TAL info attached, and MC type cannot be automatically derived. Created a dummy entry.");
               }
            }
         }
      }
   }
   else {
      if (type->toAtomicIfApplicable() && type->getName() == IMMUTABLE_BOOL_CONST_TYPE_NAME
         || type->toAtomicIfApplicable() && type->getName() == IMMUTABLE_ENUM_TYPE_NAME) {
         int val = data_->getSingleVal(member); // This type is not propagated to MC.
         tal->addIntegerVariable(member, val, val, std::to_string(val));
      } 
      else if (!aka_description && !quiet) {
         addDebug("Variable '" + member + "' has not been explicitly initialized and is not 'as well known as' another variable. It will be missing in the type abstraction layer.");
      }
   }

   if (type->toEnumIfApplicable()) {
      data_->associateVarToEnum(member, type->getName());
   }

   if (!quiet) {
      addDebugPlain("  " + member + " = " + init_value_str);
   }
}

bool vfm::CppParser::fillTypeIntoTAL(const std::string& member, const std::shared_ptr<mc::TypeAbstractionLayer> tal) const
{
   if (StaticHelper::stringContains(member, "m_tFswZeitInZustandAbgeschlossen")) {
      int x{};
   }

   if (tal->contains(member)) {
      return true; // TODO: Is returning true fine? Since value is in there already, there's nothing else to do...
   }

   static const std::string NO_INIT_DENOTER = "<noinit>";
   std::string base_name = getTypeBaseName(member);
   TypeWithInitAndRangeOrAka pair{ nullptr, {} };

   if (types_of_variables_.count(base_name)) {
      auto base = types_of_variables_.at(base_name);
      pair = base.first->deriveSubTypeFor(member, !isLocalVarName(member).empty(), false, ErrorLevelEnum::invalid);
   }
   
   if (!pair.first) {
      if (types_of_variables_.count(member)) {
         pair = { types_of_variables_.at(member).first, {
            global_primitives_init_values_.count(member) ? std::make_shared<std::string>(global_primitives_init_values_.at(member)) : nullptr, {
            global_primitives_tal_range_descriptions_.count(member) ? std::make_shared<std::string>(global_primitives_tal_range_descriptions_.at(member)) : nullptr,
            global_primitives_aka_descriptions_.count(member) ? std::make_shared<std::string>(global_primitives_aka_descriptions_.at(member)) : nullptr } } };

      }
      else {
         addWarning("No type found for variable '" + member + "' nor its base '" + base_name + "'. Assuming it is a DEFINE in the EnvModel, and guessing 'int'.");

         pair = { findType("Int", data_types_), {
            global_primitives_init_values_.count(member) ? std::make_shared<std::string>(global_primitives_init_values_.at(member)) : std::make_shared<std::string>("0"), {
            global_primitives_tal_range_descriptions_.count(member) ? std::make_shared<std::string>(global_primitives_tal_range_descriptions_.at(member)) : nullptr,
            global_primitives_aka_descriptions_.count(member) ? std::make_shared<std::string>(global_primitives_aka_descriptions_.at(member)) : nullptr } } };
         tal->addIntegerVariable(member, 0, 0, "0");
         const_cast<CppParser*>(this)->processTypeForVariableName(member, findType("Int", data_types_), { "" });
         fillTypeIntoTAL(member, tal);
      }
   }

   auto type{ pair.first };


   if (type) {
      if (type->getName() == IMMUTABLE_BOOL_CONST_TYPE_NAME || type->getName() == IMMUTABLE_ENUM_TYPE_NAME) {
         processTypeForTAL(pair, NO_INIT_DENOTER, member, type, tal);
      } else {
         if (!pair.second.first) {
            if (global_primitives_init_values_.count(member)) {
               pair.second.first = std::make_shared<std::string>(global_primitives_init_values_.at(member));
            }
            else {
               std::string error_str = "No init value given for '" + member + "'.";

               if (type->toEnumIfApplicable() && !type->toEnumIfApplicable()->getPossibleValues().empty()) {
                  auto rand_val = *type->toEnumIfApplicable()->getPossibleValues().begin();
                  addDebug(error_str + " Randomly picking init value '" + std::to_string(rand_val.first) + "' ('" + rand_val.second + "')."); // TODO: Should be a Warning.
                  pair.second.first = std::make_shared<std::string>(type->getName() + "::" + rand_val.second);
               }
               else {
                  //addError(error_str); // TODO: Output this error only for non-function-param variables.
               }
            }
         }

         processTypeForTAL(pair, NO_INIT_DENOTER, member, type, tal);
      }
   }
   else {
      addError("No type found for '" + member + "'.");
      return false;
   }

   return true;
}

std::vector<std::string> vfm::CppParser::findAllRecursiveVariableNames(const bool quiet) const
{
   if (!quiet) {
      addDebugPlain("\nThese are all the atomic variables with their initial values:");
   }

   std::vector<std::string> members_recursively;
   std::vector<std::string> const_ones; // TODO: I guess these are currently not used. Can be removed.

   for (const auto& var_name : variables_ordering_) {
      auto var_type = types_of_variables_.at(var_name);

      if (!quiet) {
         addDebugPlain(toStringFullType({ var_name, var_type }));
      }

      bool is_const = containsConstQualifier({ var_name, var_type });

      if (var_type.first && var_type.first->toAtomicIfApplicable()) {
         auto vec = var_type.first->getCppAssociations(var_name, is_const, 0);
         if (!vec.empty() && !quiet) {
            addDebugPlain("  Association: " + vec[0].second);
         }
      }

      auto members_el = var_type.first ? var_type.first->getAllAtomicMemberNamesRecursively(var_name + ".") : std::vector<std::string>{};

      if (members_el.empty()) { // If there are no members, we need to remember this as global variable (at least in the vfm sub-scope we receive).
         members_el.push_back(var_name);
      }

      members_recursively.insert(members_recursively.end(), members_el.begin(), members_el.end());

      if (is_const) {
         const_ones.insert(const_ones.end(), members_el.begin(), members_el.end());
      }
   }

   return members_recursively;
}

void vfm::CppParser::printInfos()
{
   addNote("*** Parsed and retrieved " + std::to_string(data_types_.size()) + " datatypes ***");
   for (const auto& el : data_types_) {
      addDebugPlain(el->toString());

      auto assoc = el->getCppAssociations("some_name", false, 0);

      if (!assoc.empty()) {
         addDebugPlain("--- Example associations:");

         for (const auto& el2 : assoc) {
            addDebugPlain("  " + el2.second);
         }

         addDebugPlain("");
      }
   }

   addDebugPlain("");
   addNote("*** Parsed " + std::to_string(types_of_variables_.size()) + " variables ***");
   addDebugPlain("\nThis is the according info in the type abstraction layer (TAL):");
   addDebugPlain(type_abstraction_layer_->serialize());

   addDebugPlain("");
   addNote("*** Parsed " + std::to_string(function_definitions_.size()) + " functions ***");
   for (auto iter = function_definitions_.begin(); iter != function_definitions_.end(); ++iter) {
      auto formula = function_definitions_.at(iter->first);

      if (iter->first == main_function_name_) {
         addDebug("This is the main FSM function:");
      }

      std::string sig = toStringFunctionSignature(function_signatures_[iter->first]);
      addDebugPlain(iter->first + " [" + sig + "] {" + "\n    " + formula->serialize() + "\n}\n");
   }
}

std::string vfm::CppParser::preprocessProgram(const std::string& program, const bool preliminary)
{
   std::string prog = program;

   prog = StaticHelper::replaceAll(prog, "\\\n", ""); // Ignore sequence of "\ before EOL" which, in this context in C++, can only denote an ongoing line.
   prog = StaticHelper::replaceAllRegex(prog, VFM_CONTINUING_COMMENT_DENOTER + "\\s*//", ""); // vfm's own ongoing line mechanism removing all "// $$ *whitespace* //".
   prog += command_line_argument_;

   parseOptions(prog);
   performCodeInjection(prog);
   collectLTLSpecs(prog);
   collectCTLSpecs(prog);
   collectKratosSpecs(prog);

   const int loc_original = StaticHelper::split(prog, '\n').size();
   collectInitConstraints(prog);
   for (const auto& aka_mode : { VariableSpecifierModeEnum::AKA, VariableSpecifierModeEnum::TAL, VariableSpecifierModeEnum::INIT }) performTalOrAkaConversion(prog, VariableSpecifierMode(aka_mode));
   collectInvariants(prog);

   if (!preliminary) {
      prog = StaticHelper::replaceAll(prog, VFM_GENCODE_DENOTER_BEGIN, VFM_GENCODE_PERSISTING_DENOTER + "\n" + VFM_GENCODE_DENOTER_BEGIN);
      prog = StaticHelper::replaceAll(prog, VFM_INSERT_CODE, ""); // Remove prefix for lines that are supposed to be inserted into the vfm code, while commented out to C++.
      prog = StaticHelper::removeMultiLineComments(prog, VFM_CUTOUT_DENOTER_BEGIN, VFM_CUTOUT_DENOTER_END); // Remove code parts marked as vfm cutout.
      prog = StaticHelper::removePartsOutsideOf(prog, VFM_BEGIN, VFM_END); // Remove parts outside of // #vfm-begin ... // #vfm-end
      prog = StaticHelper::removeComments(prog); // Remove regular single-line and multi-line C++ comments.
      prog = StaticHelper::removeBlankLines(prog);

      int prog_size_temp_before = prog.size();
      prog = StaticHelper::replaceAllRegex(prog, "static_cast\\s*<\\s*[Ii]nt\\s*>\\s*\\(\\s*(.*?)\\s*\\)", "$1"); // Remember, the ? means lazy.
      if (prog_size_temp_before > prog.size()) {
         addNote("Replaced at least one occurence of 'static_cast<[Ii]nt>(X)' with 'X' to handle enum casts. CAUTION, there may be situations where this behavior is unwanted. Works only if no nested brackets in inner part.");
      }

      prog = StaticHelper::replaceAllRegex(prog, "static_cast\\s*<\\s*[Ff]loat\\s*>\\s*\\(\\s*(.*?)\\s*\\)", "$1"); // TODO: Special case for Viper, replace eventually with more general solution.

      StaticHelper::preprocessCppConvertArraysToCStyle(prog);
      StaticHelper::preprocessCppConvertCStyleArraysToVars(prog);
      int loc = StaticHelper::split(prog, '\n').size();

      addNote("Parsing " + std::to_string(loc) + " (remaining from originally " + std::to_string(loc_original) + ") lines of code.");
      addDebug("*** Code to parse ***");
      addDebugPlain(prog);
      addDebug("*** EO Code to parse ***");
      processUsingKeyword(prog);
   }

   return prog;
}

void CppParser::applyInits(const std::string& name)
{
   auto inits = smv_module_->getAllVariableInits();

   for (const auto& init : inits) {
      if (init.first == name) {
         std::string value = init.second;
         addDebug("Assigning SMV INIT value '" + value + "' to variable '" + name + "'.");

         applyDefines(name, value);

         global_primitives_init_values_.insert({ 
            name, 
            value == "TRUE" ? "true" : (value == "FALSE" ? "false" : value)
         });
         return;
      }
   }

   addDebug("No SMV INIT value found for '" + name + "'.");
}

void CppParser::applySMVOperatorsToParser() const
{
   parser_->applyFormulaToParser("@f(|'operatorType=infix) {x, y} {x || y}");
   parser_->applyFormulaToParser("@f(&'operatorType=infix) {x, y} {x && y}");
}

void CppParser::applyDefines(const std::string& name, std::string& type) const
{
   if (StaticHelper::stringContains(type, "..")) {
      auto split{StaticHelper::split(type, "..")};
      auto left{ split[0] };
      auto right{ split[1] };

      applyDefines(name + "--->left", left);
      applyDefines(name + "--->right", right);
      type = left + ".." + right;
      return;
   }

   auto defines{ smv_module_->getVariableDefines() };
   for (const auto& def_pair : defines) {
      const std::string def_name{ def_pair.first };
      const std::string def_def{ def_pair.second };

      if (StaticHelper::stringContains(type, def_name)) {
         auto formula{ _id(MathStruct::parseMathStruct(type, parser_)->toTermIfApplicable()) };
         bool changed{ false };

         formula->applyToMeAndMyChildrenIterative([&def_name, &def_def, &changed, this](const MathStructPtr m) {
            auto m_var{ m->toVariableIfApplicable() };

            if (m_var && m_var->getVariableName() == def_name) {
               std::string preprocessed{ StaticHelper::trimAndReturn(def_def) };

               if (StaticHelper::stringStartsWith(preprocessed, "case") && StaticHelper::stringEndsWith(preprocessed, "esac")) {
                  std::string preamble{ def_name + " := " };
                  preprocessed = preamble + preprocessed + ";";
                  StaticHelper::preprocessSMVConvertAllSwitchsToIfs(preprocessed);
                  StaticHelper::preprocessCppConvertElseIfToPlainElse(preprocessed);
                  preprocessed = preprocessed.substr(preamble.size());
               }

               auto def_def_formula = MathStruct::parseMathStruct(preprocessed, parser_);
               addDebug("Replacing '" + m_var->serializeWithinSurroundingFormula(20, 20) + "' with '" + def_def_formula->serialize() + "' from define.");
               m_var->replace(def_def_formula->copy()->toTermIfApplicable());
               changed = true;
            }
         }, TraverseCompoundsType::avoid_compound_structures);

         if (changed) {
            auto formula_str{ formula->child0()->serialize() };
            addDebug("Updating variable '" + name + "' with define '" + def_name + " := " + def_def + "'\nfrom: '" + type + "'\nto:   '" + formula_str + "'.");
            type = formula_str;
         }
      }
   }
}

bool CppParser::parseNativeEnvModel(const std::string& program)
{
   smv_module_->parseProgram(program);

   for (const bool datatype_run : { true, false }) {
      for (const auto& var_type : smv_module_->getVariablesWithTypes()) {
         const std::string name{ var_type.first };
         std::string type{ var_type.second->getSMVName() };
         auto cpp_type{ var_type.second->getCppType() };

         if (!datatype_run) {
            addDebug("Found   variable '" + name + "' of type '" + type + "' (cpp type '" + StaticHelper::trimAndReturn(cpp_type->toString()) + "') in native env model.");

            addDebug("WARNING: Omitting defines and inits!");
            //applyDefines(name, type); // TODO: Doing this for every variable individually is inefficient, but for now who cares...
            //applyInits(name);

            if (type == "integer") {
               static const std::string MAX_VAL_STR = std::to_string(1);
               type = "-" + MAX_VAL_STR + ".." + MAX_VAL_STR; // Unbounded integer. It doesn't really matter what range we pick (except that too large ranges trigger errors).
            }

            if (StaticHelper::stringContains(type, "..")) { // Bounded integer.
               global_primitives_tal_range_descriptions_.insert({ name, STRING_PREFIX_TAL + StaticHelper::safeString(type) });
            }
         }

         if (StaticHelper::stringContains(type, "{")) { // Enum.
            bool already_there{};
            for (const auto& type_old : data_types_) {
               if (type_old->getName() == cpp_type->getName()) {
                  already_there = true;
               }
            }

            if (!already_there) {
               std::string artificial_chunk = "{\n";

               for (const auto& possible_value_pair : cpp_type->toEnumIfApplicable()->getPossibleValues()) {
                  const std::string& possible_value = possible_value_pair.second;
                  const std::string& possible_value_num = std::to_string(possible_value_pair.first);

                  artificial_chunk += "   " + possible_value + " = " + possible_value_num + ";\n";
               }

               artificial_chunk += "}";

               addDebug("Adding artificial enum chunk for 'enum class " + cpp_type->getName() + "':");
               addDebugPlain(artificial_chunk);
               addEnum(cpp_type->getName(), artificial_chunk, "");
            }
         }
         else if (!datatype_run) {
            processTypeForVariableName(name, cpp_type, { "" });
            fillTypeIntoTAL(name, type_abstraction_layer_);
         }
      }
   }

   return true;
}

bool vfm::CppParser::parseProgram(const std::string& program)
{
   if (isCurrentlyDoingNativeEnvModelGeneration()) {
      return parseNativeEnvModel(program);
   }
   else {
      addNotePlain("\n          *** PARSING --- PRE_PROCESSING ***\n");
      std::string prog = preprocessProgram(program, false);

      addNotePlain("\n          *** PARSING --- MAIN_PART ***\n");
      int begin = -1;
      int end = -1;
      std::string chunk;
      std::string name;
      std::string type;
      ChunkTypeEnum t = ChunkTypeEnum::Unknown;
      std::vector<int> except;
      std::vector<std::string> signature;
      std::string namespace_str;
      std::deque<std::string> prefix_tokens;
      std::vector<std::string> father_classes;
      std::string main_function_chunk;

      while (t != ChunkTypeEnum::None) {
         std::string sig;
         main_function_chunk = "";

         if (t == ChunkTypeEnum::Enum || t == ChunkTypeEnum::EnumClass) {
            addEnum(name, chunk, namespace_str);
         }
         else if (t == ChunkTypeEnum::Struct) {
            addStruct(name, chunk, namespace_str, father_classes);
         }
         else if (t == ChunkTypeEnum::Function) {
            signature = preprocessArraysInStructOrSignature(signature, '(', ')', ",", false, "<function> " + name);
            main_function_chunk = addFunction(name, type, signature, chunk, namespace_str);
         }
         else if (t == ChunkTypeEnum::Unknown) {
            except.push_back(begin);
            except.push_back(end);
         }

         signature.clear();
         t = findIndices(prog, chunk, name, type, signature, begin, end, except, namespace_str, prefix_tokens, father_classes);

         if (!prefix_tokens.empty()) {
            prefix_tokens.pop_back();
         }

         gatekeeper(t, chunk, prefix_tokens);
      }

      addNotePlain("\n          *** PARSING --- POST_PROCESSING ***\n");
      assert(!main_function_chunk.empty()); // Assuming main function is the last chunk parsed.
      postprocessSemanticStuff(nullptr, main_function_chunk);
   }

   return true;
}

bool vfm::CppParser::parseProgramFromFiles(const std::vector<std::string>& file_list)
{
   std::string program{};

   for (const auto& in_path : file_list) {
      addNote("Adding vfm-related content from '" + StaticHelper::absPath(in_path) + "' to the parsing base.");
      program += StaticHelper::readFile(in_path);
   }

   return parseProgram(program);
}

std::vector<std::string> vfm::CppParser::readFileListFromFile(const std::string& file_path)
{
   const std::string dir_to_file_list_file = StaticHelper::removeFileNameFromPath(file_path);
   std::ifstream input(file_path);
   std::vector<std::string> vec;

   if (input.good()) {
      std::string file_list;
      std::stringstream sstr;
      while (input >> sstr.rdbuf());
      file_list = sstr.str();

      file_list = StaticHelper::removeComments(file_list);

      for (const auto& file : StaticHelper::split(file_list, PROGRAM_COMMAND_SEPARATOR)) {
         if (!StaticHelper::isEmptyExceptWhiteSpaces(file)) {
            std::string processed = StaticHelper::removeWhiteSpace(file);
            vec.push_back(dir_to_file_list_file + "/" + processed);
         }
      }
   }
   else {
      addError("Cannot read file list file '" + StaticHelper::absPath(file_path) + "'.");
   }

   input.close();

   return vec;
}

bool vfm::CppParser::parseProgramByLoadingFileListFromFile(const std::string& file_name)
{
   if (isCurrentlyDoingNativeEnvModelGeneration()) {
      return parseProgram(StaticHelper::readFile(file_name));
   }

   addNote("Retrieving file list from '" + StaticHelper::absPath(file_name) + "'.");
   return parseProgramFromFiles(readFileListFromFile(file_name));
}

std::map<std::string, CppFunctionSignature>& vfm::CppParser::getFunctionSignatures()
{
   return function_signatures_;
}

std::vector<CppType>& vfm::CppParser::getDataTypes()
{
   return data_types_;
}

std::string vfm::CppParser::toStringFunctionSignature(const CppFunctionSignature& func_sig)
{
   std::string s = func_sig.first->toString() + "(";

   for (int i = 0; i < func_sig.second.size(); i++) {
      if (func_sig.second.size() > i) {
         auto el = func_sig.second[i];
         if (el.second.first) {
            s += toStringFullType(el) + (i != func_sig.second.size() - 1 ? ", " : "");
         }
         else {
            return ERROR_STRING;
         }
      }
      else {
         return ERROR_STRING;
      }
   }

   return s + ")";
}

bool vfm::CppParser::signaturesAreEqual(const CppFunctionSignature& s1, const CppFunctionSignature& s2)
{
   if (/*s1.first != s2.first || */s1.second.size() != s2.second.size()) {
      return false;
   }

   for (int i = 0; i < s1.second.size(); i++) {
      if (!typesAreEqual(s1.second[i], s2.second[i])) {
         return false;
      }
   }

   return true;
}

bool vfm::CppParser::typesAreEqual(const CppFullTypeWithName& s1, const CppFullTypeWithName& s2, const bool ignore_qualifiers)
{
   bool type_equal;
   if (!s1.second.first || !s2.second.first) { // Special case: type empty.
      type_equal = s2.second.first == s2.second.first;
   }
   else {
      type_equal = s1.second.first->getName() == s2.second.first->getName();
   }

   bool equal = s1.first == s2.first                                  // Names are equal
      && type_equal
      && (ignore_qualifiers || s1.second.second == s2.second.second); // Qualifiers are equal

   return equal;
}

void vfm::CppParser::extractFunctionSignature(const std::string& function_name, const std::string& return_type, const std::vector<std::string>& tokens)
{
   CppFunctionSignature signature;
   bool type_mode = true;
   std::string last;
   std::string type;
   std::vector<std::string> qualifiers = {};

   signature.first = findType(return_type, data_types_);

   for (size_t i = 0; i < tokens.size(); i++) {
      std::string el = tokens.at(i);

      if (el == "const") {
         qualifiers.push_back("paramconst");
      }
      else if (el == "*" || el == "&") {
         qualifiers.push_back(el);
      }
      else if (last != "=") {
         if (el == ",") {
            type_mode = true;
         }
         else {
            if (type_mode) {
               type = el;
            }
            else {
               auto cpp_type = findType(type, data_types_);
               signature.second.push_back({ el, { cpp_type, qualifiers } });
               qualifiers = {};

               if (type == "bool") {
                  processTypeForVariableName(el, cpp_type->copy(true), {});
                  fillTypeIntoTAL(el, type_abstraction_layer_);
               }
            }

            type_mode = !type_mode;
         }

         if (el == "," || i == tokens.size() - 2) {
            if (i + 1 < tokens.size()) { // TODO: Trailing comma probably not allowed in C++, so this condition should be unneccessary.
               std::string possible_description = tokens.at(i + 1);
               std::string par_name = el == "," ? last : el;

               if (StaticHelper::stringContains(possible_description, STRING_PREFIX_INIT)) { // Captures INIT only (4 dots).
                  global_primitives_init_values_.insert({ par_name, possible_description });
                  i++;
               }
               else if (StaticHelper::stringContains(possible_description, STRING_PREFIX_AKA)) { // Captures AKA only (3 dots).
                  global_primitives_aka_descriptions_.insert({ par_name, possible_description });
                  i++;
               }
               else if (StaticHelper::stringContains(possible_description, STRING_PREFIX_TAL)) { // Captures TAL only (2 dots).
                  global_primitives_tal_range_descriptions_.insert({ par_name, possible_description });
                  i++;
               }
            }
         }
      }

      last = el;
   }

   function_signatures_.insert({ function_name, signature });

   for (const auto& el : signature.second) {
      processTypeForVariableName(el.first, el.second.first, el.second.second);
   }

   if (function_signatures_.size() >= 2) {
      auto it1 = ++function_signatures_.rbegin();
      auto it2 = function_signatures_.rbegin();

      //if (!signaturesAreEqual(it1->second, it2->second)) { // TODO: Signatures (even of not-inlined functions) don't need to be equal only subset of main function's. 
      //   addNote("The following functions have differing parameter definitions. If this is intended, carefully consider the implications.\n"
      //   + it1->first + " " + toStringFunctionSignature(it1->second) + "\n"
      //   + it2->first + " " + toStringFunctionSignature(it2->second));
      //}
   }
}

void vfm::CppParser::addEnum(const std::string& enum_name_raw, const std::string& chunk, const std::string& namespace_name)
{
   auto values = std::make_shared<std::map<float, std::string>>();
   std::map<std::string, int> special_values;
   std::string current_name;
   int cnt = 0;
   auto tokens_raw = StaticHelper::getChunkTokens(chunk, AkaTalProcessing::none);
   std::string enum_name = namespace_name + enum_name_raw;

   addNote("Adding enum (class) '" + enum_name + "' to code base...");

   std::vector<std::string> tokens;
   for (int i = 0; i < tokens_raw->size() - 1; i++) { // Preprocess tokens to catch negative numbers.
      if (tokens_raw->at(i) == "-" && StaticHelper::isParsableAsInt(tokens_raw->at(i + 1))) {
         tokens.push_back(tokens_raw->at(i) + tokens_raw->at(i + 1));
         i++;
      }
      else {
         tokens.push_back(tokens_raw->at(i));
      }
   }

   for (const auto& el : tokens) {
      if (StaticHelper::isParsableAsInt(el)) {
         if (current_name.empty()) {
            addError("Token |" + el + "| occurred at wrong position in enum chunk:\n" + chunk);
            addError("Skipping this chunk..."); // Note that syntax errors are caught by C++. This is just for debugging and can be removed later.
            return;
         }

         special_values.insert({ current_name, std::stoi(el) });
      }
      else if (StaticHelper::isAlphaNumericOrUnderscore(el)) {
         values->insert({ cnt++, el });
         current_name = el;
      }
   }

   for (const auto& el : special_values) {
      auto it = values->find(el.second);

      std::string old_val_str = it == values->end() ? "" : it->second;
      int old_val_int;

      for (const auto& el2 : *values) {
         if (el2.second == el.first) {
            old_val_int = el2.first;
            break;
         }
      }

      if (old_val_str.empty()) {
         values->erase(old_val_int);
      } else {
         (*values)[old_val_int] = old_val_str;
      }

      (*values)[el.second] = el.first;
   }

   addPlainEnumVariable(enum_name, values);
}

void CppParser::addPlainEnumVariable(const std::string& enum_name, const std::shared_ptr<std::map<float, std::string>> values)
{
   data_types_.push_back(std::make_shared<CppTypeEnum>(enum_name, values));
   std::map<int, std::string> int_map{};

   for (const auto& f : *values) {
      int_map.insert({ f.first, f.second });
   }

   data_->addEnumMapping(enum_name, int_map);

   for (const auto& enum_val : *values) {
      insertTypeOfVariable(enum_name + "::" + enum_val.second, // TODO: There is a better way to derive the "::" enum name.
         { std::make_shared<CppTypeAtomic>(IMMUTABLE_ENUM_TYPE_NAME, DataPack::AssociationType::Float), {} });
   }
}

std::vector<std::string> vfm::CppParser::preprocessArraysInStructOrSignature(
   const std::vector<std::string>& tokens, 
   const char begin_bracket, 
   const char end_bracket, 
   const std::string& delimiter,
   const bool insert_delimiter_after_last_item,
   const std::string& chunk_name) const
{
   int dummy_pos = 0;
   std::string tokens_as_string = StaticHelper::tokensAsString(tokens);
   tokens_as_string = preprocessArraysInStructOrSignature(tokens_as_string, begin_bracket, end_bracket, delimiter, insert_delimiter_after_last_item, chunk_name);
   return *StaticHelper::tokenize(tokens_as_string, *parser_, dummy_pos, std::numeric_limits<int>::max(), false, DEFAULT_REGEX_FOR_TOKENIZER, DEFAULT_IGNORE_CLASS_FOR_TOKENIZER, false, false);
}

std::string vfm::CppParser::preprocessArraysInStructOrSignature(
   const std::string& chunk, 
   const char begin_bracket, 
   const char end_bracket, 
   const std::string& delimiter,
   const bool insert_delimiter_after_last_item,
   const std::string& chunk_name) const
{
   std::string s;
   bool contains_array_any = false;

   int beg;
   int end;
   for (beg = 0; beg < chunk.size() && chunk[beg] == begin_bracket; beg++);
   for (end = chunk.size() - 1; end >= 0 && (chunk[end] == end_bracket || chunk.substr(end, delimiter.size()) == delimiter); end--);

   auto lines = StaticHelper::split(chunk.substr(beg, end - beg), delimiter);

   const auto DELIMITER = [insert_delimiter_after_last_item, &delimiter](const bool is_last, const bool contains_tal_aka, const bool is_single_token) {
      const bool is_tal_aka_info_of_last_line = is_last && contains_tal_aka && is_single_token;
      return (!is_tal_aka_info_of_last_line && (insert_delimiter_after_last_item || !is_last)) ? delimiter : "";
   };

   bool last_line_was_array = false;

   for (int line_num = 0; line_num < lines.size(); line_num++) {
      auto line = lines.at(line_num);
      auto next_line = line_num + 1 < lines.size() ? lines.at(line_num + 1) : "";

      if (StaticHelper::isEmptyExceptWhiteSpaces(next_line)) {
         next_line = "NOTHINGTOSEEHERE"; // Just any string that resolves to at least one token.
      }

      bool is_last = line_num == lines.size() - 1;
      bool line_contains_array = false;
      StaticHelper::trim(line);

      if (!line.empty()) {
         if (line[line.size() - 1] == '=') {
            line = line.substr(0, line.size() - 1);
         }

         auto sides = StaticHelper::split(line, "=", [](const std::string& split_str, const int pos) -> bool {
            return pos != 0 && pos != split_str.size() - 1 && split_str.at(pos - 1) != '=' && split_str.at(pos + 1) != '='; // Avoid splitting on "==".
         });

         auto left_side = sides[0];
         auto tokens = StaticHelper::splitOnWhiteSpaces(left_side); // Formulas x___3+CONST_1 may not have white spaces at this point.
         bool contains_tal_aka = false;

         if (StaticHelper::stringContains(tokens.at(0), STRING_PREFIX_TAL)) { // Add aka/tal notation to last line.
            contains_tal_aka = true;
         }
         else {
            s += "\n";
         }

         if (tokens.size() > contains_tal_aka) {
            std::string type_name = tokens.at(contains_tal_aka);
            for (int i = 1 + contains_tal_aka; i < tokens.size() - 1; i++) {
               type_name += " " + tokens.at(i);
            }

            if (StaticHelper::stringContains(tokens.at(tokens.size() - 1), ARRAY_INDEX_DENOTER_OPEN)) { // It's an array.
               line_contains_array = true;
               contains_array_any = true;
               int dummy = 0;
               auto tokens_next_line = StaticHelper::tokenize(next_line, *parser_, dummy);
               auto next_line_tal_aka = StaticHelper::stringContains(tokens_next_line->at(0), STRING_PREFIX_TAL) ? tokens_next_line->at(0) : "";

               if (StaticHelper::stringStartsWith(tokens.at(0), STRING_PREFIX_TAL)) { // TAL or AKA info from last line.
                  s += "   " + tokens.at(0) + "\n";
               }

               auto initialization = sides.size() > 1 ? StaticHelper::extractArbitraryBracketStructure(sides[1], "{", "}", ",", { "\"" }, { "\"" }) : nullptr;
               auto array_desc = StaticHelper::split(tokens.at(tokens.size() - 1), ARRAY_INDEX_DENOTER_OPEN); // Assume int x[i][j][k]...;
               auto arr_name = array_desc[0];                                                                 // ...there's no such thing as "int x[i[j[k...]]] at this level.
               std::vector<int> dims;
               std::vector<int> dims_counter;

               for (int i = 1; i < array_desc.size(); i++) {
                  const auto array_desc_current = array_desc[i].substr(0, array_desc[i].size() - ARRAY_INDEX_DENOTER_CLOSE.size()); // ...therefore ignore ARRAY_INDEX_DENOTER_CLOSE.
                  int curr_dim = options_.isGatekeeper()
                     ? 1
                     : MathStruct::parseMathStruct(array_desc_current, parser_, data_)->eval(data_, parser_);

                  dims.push_back(curr_dim);
                  dims_counter.push_back(curr_dim - 1);
               }

               dims_counter[0]++;

               while (!VECTOR_COUNTER_IS_ALL_ZERO(dims_counter)) {
                  VECTOR_COUNTER_DECREMENT(dims, dims_counter);
                  s += "   " + type_name + " " + arr_name;

                  for (const auto& dim : dims_counter) {
                     s += ARRAY_INDEX_DENOTER_OPEN + std::to_string(dim) + ARRAY_INDEX_DENOTER_CLOSE;
                  }

                  if (initialization) {
                     auto init_value = initialization->getContentAt(dims_counter);

                     if (!init_value.empty()) {
                        StaticHelper::trim(init_value);
                        s += " = " + init_value;
                     }
                  }

                  s += DELIMITER(is_last && VECTOR_COUNTER_IS_ALL_ZERO(dims_counter), contains_tal_aka, tokens.size() == 1) + "   " + next_line_tal_aka + "\n";
               }
            }
         }

         if (line_contains_array) {
            last_line_was_array = true;
         } else {
            if (!last_line_was_array || !contains_tal_aka || tokens.size() != 1) { // Don't add line if it's a TAL/AKA and last line was array, since it was already inserted.
               s += "   " + line + DELIMITER(is_last, contains_tal_aka, tokens.size() == 1);
            }

            last_line_was_array = false;
         }
      }
   }

   for (int i = 0; i < beg; i++) {
      s = StaticHelper::makeString(begin_bracket) + s + "\n" + StaticHelper::makeString(end_bracket);
   }

   if (contains_array_any) {
      addDebug("Array preprocessing in chunk '" + chunk_name + "' FROM:");
      addDebugPlain("----------------");
      addDebugPlain(chunk);
      addDebugPlain("----------------");
      addDebug("Array preprocessing RESULT:");
      addDebugPlain("----------------");
      addDebugPlain(s);
      addDebugPlain("----------------");
   }

   return s;
}

void vfm::CppParser::addStruct(
   const std::string& struct_name_raw, 
   const std::string& chunk_raw, 
   const std::string& namespace_name, 
   const std::vector<std::string>& father_classes)
{
   std::string chunk{ preprocessArraysInStructOrSignature(chunk_raw, '{', '}', ";", true, "<struct> " + struct_name_raw) };

   auto members{ std::make_shared<MembersType>() };
   auto tokens{ StaticHelper::getChunkTokens(chunk, AkaTalProcessing::none) };
   int num_per_line{ 0 };
   bool skip_one{ false };
   std::string last_type{};
   std::string struct_name{ namespace_name + struct_name_raw };
   std::map<std::string, std::string> temp_init_values{};

   addNote("Adding struct/class '" + struct_name + "' to code base...");

   for (const auto& father_name : father_classes) { // Arrays already resolved in father classes.
      addNote("Found inheritance relation for struct/class '" + struct_name + "' from father '" + father_name + "'.");

      for (const auto& some_type : data_types_) {
         if (some_type->getName() == father_name) {
            for (const auto& father_member : some_type->getMembers()) {
               addDebug("Adding member '" + father_member.first + "' from father class...");
               members->push_back({ father_member.first, CppTypeStruct::copy(father_member.second, true) });
            }
         }
      }
   }

   for (int i = 0; i < tokens->size(); i++) {
      while (StaticHelper::isEmptyExceptWhiteSpaces(tokens->at(i))) {
         i++; // Go over empty tokens which can appear due to automatic TAL derivation below.
      }

      auto token{ tokens->at(i) };

      if (std::regex_match(StaticHelper::makeString(token[0]), VAR_AND_FUNCTION_NAME_REGEX)) { // Check only first character since classified already by tokenized.
         if (token == "struct" || token == "enum" || token == "class") {
            num_per_line = std::numeric_limits<int>::max(); // Skip over remainings of nested chunks.
         }
         else if (num_per_line == 0) {
            last_type = token;

            for (const auto& using_type : using_mapping_) {
               if (last_type == using_type.first) {
                  last_type = using_type.second;
               }
            }
         }
         else if (num_per_line == 1) {
            bool type_found{ false };
            bool has_const_qualifier{ last_type == "const" || last_type == "constexpr" };
            bool has_static_const_qualifier{ last_type == "static" && (token == "const" || token == "constexpr") };
            std::string const_prefix{};
            
            if (has_const_qualifier) {
               last_type = token;
               i++;
               token = tokens->at(i);
            } 
            else if (has_static_const_qualifier) {
               i++;
               token = tokens->at(i);
               last_type = token;
               i++;
               token = tokens->at(i);
               const_prefix = struct_name + "::";
            }

            std::shared_ptr<std::string> init_value{};

            for (const auto& el : data_types_) {
               if (el->getName() == namespace_name + last_type || (el->getName() == last_type)) {
                  auto subtype{ el->copy(true) };
                  std::shared_ptr<std::string> range_description{};
                  std::shared_ptr<std::string> aka_description{};

                  if (tokens->size() > i + 2 && tokens->at(i + 1) == "=") { // Construct initial value of member variable.
                     int j{ i + 2 };
                     init_value = std::make_shared<std::string>();
                     
                     while (tokens->at(j) != ";") { // Cf. (almost) double code in preprocessCppFunctionComplexDatatypes.
                        auto proc_token{ tokens->at(j) };

                        if (std::isdigit(proc_token[0]) || proc_token[0] == '.') {
                           removeCppNumTypeDenotersFromNumber(proc_token);
                        }

                        *init_value += proc_token;
                        j++;
                     }

                     if (tokens->size() > j + 1) { // TAL and AKA information.
                        if (StaticHelper::stringContains(tokens->at(j + 1), STRING_PREFIX_AKA)) {     // Assuming "..." cannot be part of any relevant C++ token.
                           aka_description = std::make_shared<std::string>(tokens->at(j + 1));
                           tokens->at(j + 1) = "";
                        }
                        else if (StaticHelper::stringContains(tokens->at(j + 1), STRING_PREFIX_TAL)) { // Assuming ".." cannot be part of any relevant C++ token.
                           range_description = std::make_shared<std::string>(tokens->at(j + 1));
                           tokens->at(j + 1) = "";
                        }
                     }
                  }

                  if (init_value
                     && !StaticHelper::stringContains(*init_value, ",") // TODO: Allow complex init values such as {{a, b, c}, {d, e, f}}.
                     ) { // Insert actual values for subformulas with already initialized variables from this struct.
                     auto init_value_fmla{ _id(MathStruct::parseMathStruct(*init_value, parser_, data_)->toTermIfApplicable()) };

                      init_value_fmla->getTermsJumpIntoCompounds()[0]->applyToMeAndMyChildrenIterative([&temp_init_values](const MathStructPtr m) {
                         auto m_var{ m->toVariableIfApplicable() };

                         if (m_var && temp_init_values.count(m_var->getVariableName())) {
                            m->replace(MathStruct::parseMathStruct(temp_init_values[m_var->getVariableName()])->toTermIfApplicable());
                         }
                      }, TraverseCompoundsType::avoid_compound_structures);

                      init_value = std::make_shared<std::string>(init_value_fmla->getTermsJumpIntoCompounds()[0]->serializePlainOldVFMStyle());
                      temp_init_values[token] = *init_value;
                  }

                  subtype->setConst(has_const_qualifier || has_static_const_qualifier);
                  members->push_back({ token, { subtype, { init_value, { range_description, aka_description } } } });

                  if (has_static_const_qualifier) {
                     const std::string full_name{ const_prefix + token };

                     if (init_value) {
                        std::string range{ *init_value + ".." + *init_value }; // Has to exist since const variables need to be initialized.
                        insertTypeOfVariable(full_name, { subtype, { "const", "static" } });
                        global_primitives_tal_range_descriptions_[full_name] = STRING_PREFIX_TAL + StaticHelper::safeString(range);
                        //fsm_->addConstantToModelChecker(full_name);
                     }
                     else {
                        addError("Unitialized static const variable found: '" + full_name + "'.");
                     }
                  }

                  type_found = true;
                  break;
               }
            }

            if (type_found) {
               addDebug("Found member '" + token + "' with type '" + last_type + "' in definition of '" + struct_name + "'.");
            } else {
               addError("Unknown type '" + last_type + "' of member '" + token + "'. Definition of '" + struct_name + "' cannot be processed:\n" + chunk);
               addNote("Hint: This error can be caused by a wrong ordering of the included files.");
               addNote("Hint: If this is an atomic type, it needs to be included into the 'addAtomicDataTypes' function of 'cpp_parser.cpp'. These are the data types defined there so far:");

               CppParser temp_dummy{ command_line_argument_ };
               for (const auto& data_type : temp_dummy.data_types_) {
                  addDebugPlain("  " + data_type->toString());
               }
               addError("Skipping this chunk...");

               return;
            }
         }

         num_per_line++;
      }
      else if (token == ";") {
         num_per_line = 0;
      }
   }

   auto type{ std::make_shared<CppTypeStruct>(struct_name, members) };
   data_types_.push_back(type);
   //ignore_tokens_for_functions_.insert(struct_name);
}

bool isChunkEmpty(const std::string& chunk) 
{
   return StaticHelper::isEmptyExceptWhiteSpaces(StaticHelper::replaceAll(StaticHelper::replaceAll(chunk, "{", ""), "}", ""));
}

std::string vfm::CppParser::addFunction(const std::string& function_name_raw, const std::string& return_type, const std::vector<std::string>& signature_raw, const std::string& chunk_raw, const std::string& namespace_name)
{
   std::string function_name = namespace_name + function_name_raw;
   std::string chunk = chunk_raw;
   auto signature = signature_raw;

   addNote("Adding function '" + function_name + "' to code base...");

   if (isChunkEmpty(chunk)) {
      chunk = "{0}";
      addWarning("Empty function body found for function '" + function_name + "'.");
   }

   std::string last_token;
   for (int i = 1; i + 1 < signature.size(); i++) { // Handle pointers as parameters.
      auto& last_token = signature[i - 1];
      auto& token = signature[i];
      auto& next_token = signature[i + 1];

      if (token == "*") {
         if (StaticHelper::stringContains(chunk, " ->") 
             || StaticHelper::stringContains(chunk, "\t->") 
             || StaticHelper::stringContains(chunk, "\n->") 
             || StaticHelper::stringContains(chunk, "\v->") 
             || StaticHelper::stringContains(chunk, "\f->") 
             || StaticHelper::stringContains(chunk, "\r->")) {
            addWarning("Found possible C++ pointer operator '->' with white space in front, which is forbidden in vfm. Please check if I'm right...");
         }

         chunk = StaticHelper::replaceAll(chunk, next_token + "->", next_token + ".");
         chunk = StaticHelper::replaceAll(chunk, "*" + next_token, next_token); // TODO: Here we just assume (hope) noone will write "*   myvar". In theory it could also be multiplication on a pointer... 
      }
   }

   auto tokens = StaticHelper::getChunkTokens(chunk, AkaTalProcessing::none);

   std::vector<std::string> function_signatures_raw;      
   function_signatures_raw.push_back(return_type);
   function_signatures_raw.insert(function_signatures_raw.end(), signature.begin(), signature.end());
   extractFunctionSignature(function_name, return_type, signature);
   bool isMainGencodePart = tokens->size() > 1 && tokens->at(1) == VFM_GENCODE_PERSISTING_DENOTER;

   if (isMainGencodePart) {
      main_function_name_ = function_name;
      main_namespace_name_ = namespace_name;
      chunk = StaticHelper::replaceAll(chunk, VFM_GENCODE_PERSISTING_DENOTER, "");
   }

   auto formula = parseFunctionFromCpp(function_name, chunk.substr(1, chunk.size() - 2));
   parser_->addDynamicTerm(formula, function_name, true);

   return isMainGencodePart ? chunk : "";
}

constexpr bool CREATE_PARSE_TREES_FOR_DEBUGGING = false; // Can take lots of time.

void vfm::CppParser::createGrammarTreesForDebugging(const earley::Grammar& grammar_orig, const std::vector<std::string>& whole_tokens) const
{
   if (CREATE_PARSE_TREES_FOR_DEBUGGING) {
      earley::Grammar grammar = grammar_orig;
      grammar.makeEpsilonFree();

      addDebug("Using this epsilon-free grammar:\n" + grammar.toString(false));

      addDebug("Creating parse tree(s) for debugging...");
      earley::Parser p(grammar);
      p.parseProgram(grammar.getTerminalDummyTokenString(whole_tokens));

      auto valid_trees = p.getParseTreesFromLastCalculation();
      auto broken_trees = p.getBrokenParseTreesFromLastCalculation();

      addDebug("Created " + std::to_string(valid_trees.size()) + " VALID parse tree(s):");

      for (auto& tree : valid_trees) {
         if (tree.getEdge()->lhs_ == grammar.getStartsymbol()) {
            addDebugPlain(tree.toString() + "\n");
         }
      }

      addDebug("Created " + std::to_string(broken_trees.size()) + " BROKEN parse tree(s):");

      for (const auto& tree : broken_trees) {
         addDebugPlain(tree.toString() + "\n");
      }
   }
}

bool vfm::CppParser::gatekeeper(const ChunkTypeEnum type, const std::string& inner, const std::deque<std::string>& prefix) const
{
   std::string whole;

   for (const auto& token : prefix) {
      whole += token + " ";
   }

   whole += inner;
   auto whole_tokens = StaticHelper::tokenizeCharacterwise(whole, true, true);

   if (grammars_for_chunks_.count(type)) {
      auto grammar = grammars_for_chunks_.at(type);
      addNote("Earley gatekeeper - recognizing chunk of type '" + ChunkType(type).getEnumAsString() + "':");
      addDebugPlain(whole);

      if (earley::Recognizer::recognizeConst(grammar, whole_tokens)) {
         addNote("Earley gatekeeper - recognized " + OK_COLOR + "SUCCESSFULLY" + RESET_COLOR + ".");
         createGrammarTreesForDebugging(grammar, whole_tokens);
      }
      else {
         addError("Earley gatekeeper - recognizing " + FAILED_COLOR + "FAILED" + RESET_COLOR + ".");
         addNote("Earley gatekeeper - chunk of type '" + ChunkType(type).getEnumAsString() + "' is not produced by the following gramamr:");
         addNotePlain(grammar.toString());
         createGrammarTreesForDebugging(grammar, whole_tokens);

         return false;
      }
   }
   else {
      //addDebug("Earley gatekeeper - skipping chunk of type '" + ChunkType(type).getEnumAsString() + "'. No grammar provided.");
   }

   return true;
}

bool vfm::CppParser::checkForUndeclaredVariables(const MathStructPtr m) const
{    
   bool undeclared_variable_exists = false;

   m->applyToMeAndMyChildrenIterative([&undeclared_variable_exists, this](const MathStructPtr m) {
      if (m->isTermVar()) {
         std::string m_var_name{ StaticHelper::replaceAll(m->toVariableIfApplicable()->getVariableName(), "____", "::") }; // TODO: Magic constants

         if (!data_->isDeclared(m_var_name)) {
            bool is_smv_define{false};

            if (isCurrentlyDoingNativeEnvModelGeneration()) {
               auto defines = smv_module_->getVariableDefines();
               auto vartypes = smv_module_->getVariablesWithTypes();

               for (const auto& def_pair : defines) {
                  if (def_pair.first == m_var_name) {
                     is_smv_define = true;
                     break;
                  }
               }

               for (const auto& def_pair : vartypes) {
                  if (def_pair.first == m_var_name) {
                     is_smv_define = true;
                     break;
                  }
               }
            }

            if (!is_smv_define) {
               addWarning("Variable '" + m_var_name + "' has not been declared.");
               addWarning("This is the formula in question:\n'" + m->serializeWithinSurroundingFormula() + "'.");
            }
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   return undeclared_variable_exists;
}

std::string cleanUp(const std::string dirty) // Essentially trims, possibly more if something comes up.
{
   std::string cleaned_up = dirty;
   StaticHelper::trim(cleaned_up);
   return cleaned_up;
}

std::vector<std::string> extractArgs(const std::string& function_call_raw, const int begin_pos, int& end_pos_raw) // Something like f(x, y, a + b, z) ==> { x, y, a + b, z }
{
   std::vector<std::string> vec{};
   int begin_raw{ begin_pos };
   end_pos_raw = StaticHelper::findMatchingEndTagLevelwise(function_call_raw, begin_raw, "(", ")", { "\"" }, { "\"" });
   int last_begin{};
   std::string function_call{ function_call_raw.substr(begin_raw, end_pos_raw - begin_raw + 1) };

   assert(begin_raw >= 0 && end_pos_raw >= 0);

   int begin{ 0 };
   int end_pos{ end_pos_raw - begin_raw + 1 };

   for (;;) {
      last_begin = begin + 1;
      begin = StaticHelper::indexOfOnTopLevel(function_call, { "," }, begin + 1, "(", ")", { "\"" }, { "\"" });

      if (begin < 0) {
         break;
      } else {
         vec.push_back(cleanUp(function_call.substr(last_begin, begin - last_begin)));
      }
   }

   vec.push_back(cleanUp(function_call.substr(last_begin, end_pos - last_begin)));
   
   return vec;
}

// If we have a call in function style, can be actual function call or constructor.
// isAllowedToDrive(...) or vfc::CSI::si_kilometre_per_hour_f32_t(...)
bool vfm::CppParser::isFunctionStyle(const std::string& string, const int pos, const std::string& function_name) {
   int  pos_dummy = pos + function_name.size() - 1;
   auto tokens_before = StaticHelper::tokenize(string, *parser_, pos_dummy, 1, true);
   pos_dummy = pos + function_name.size();
   auto tokens_after = StaticHelper::tokenize(string, *parser_, pos_dummy, 1, false);

   return !tokens_before->empty() && !tokens_after->empty()
      && tokens_before->at(0) == function_name && tokens_after->at(0) == "(";
}

void vfm::CppParser::populateDatatypesToLookAt(std::map<std::string, CppFunctionSignature>& tokens_to_look_at) const
{
   for (const auto& type : data_types_) {
      tokens_to_look_at.insert({ type->getName(), NULL_SIGNATURE });
   }

   for (const auto& pair : using_mapping_) {
      tokens_to_look_at.insert({ pair.first, NULL_SIGNATURE });
   }
}

void vfm::CppParser::replaceReturnWithAssignment(const TermPtr enc_function, const std::string& set_var_name)
{
   enc_function->applyToMeAndMyChildrenIterative([&set_var_name, this](const MathStructPtr m) {
      if (m->getOptorOnCompoundLevel() == SYMB_RETURN) {
         auto m_0{ m->getTermsJumpIntoCompounds()[0] };
         m->replace(_set(set_var_name, m_0));
      }
   }, TraverseCompoundsType::avoid_compound_structures);
}

void vfm::CppParser::inlineFunction(
   std::string& result, 
   const int index_begin, 
   const std::string& function_name, 
   const vfm::CppFunctionSignature& sig, 
   const int index_begin_orig,
   const bool function_call_is_isolated_in_line)
{
   addNote("Inlining function '" + function_name + "'.");

   auto end_pos{ 0 };
   auto real_args_raw{ extractArgs(result, index_begin, end_pos) };
   std::vector<std::string> real_args{};
   auto meta_term{ parser_->getDynamicTermMeta(function_name, 0) }; // We have always 0 parameters because we don't mimic the calling behavior of the function.
   auto enc_function{ _id(meta_term->copy()) };

   // Increment local variable names (isAllowedToDrive.myvar ==> isAllowedToDrive.myvar.called_nr)
   if (!function_call_counters_.count(function_name)) {
      function_call_counters_.insert({ function_name, 0 });
   }
   else {
      function_call_counters_.at(function_name)++;
   }

   enc_function->applyToMeAndMyChildrenIterative([this, &function_name](const MathStructPtr m) { // Rename local variables.
      auto m_var{ m->toVariableIfApplicable() };

      if (m_var) {
         auto m_var_name{ m_var->getVariableName() };

         if (StaticHelper::cleanVarNameOfPossibleRefSymbol(isLocalVarName(m_var_name)) == function_name) { // It's a local variable of this funtion.
            std::string m_var_name_new{ localVarNameActualCall(function_name, m_var_name) };
            m_var->setVariableName(m_var_name_new);


            if (types_of_variables_.count(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name))) { // It's a base type ("A a"; not a subtype like "a.x").
               auto type = types_of_variables_.at(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name));
               insertTypeOfVariable(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name_new), { type.first->copy(true), type.second }, true);
            }

            auto it_tal { global_primitives_tal_range_descriptions_.find(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name)) };
            auto it_aka { global_primitives_aka_descriptions_.find(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name)) };
            auto it_init{ global_primitives_init_values_.find(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name)) };

            if (it_tal != global_primitives_tal_range_descriptions_.end()) {
               global_primitives_tal_range_descriptions_[m_var_name_new] = it_tal->second;
            }

            if (it_aka != global_primitives_aka_descriptions_.end()) {
               global_primitives_aka_descriptions_[m_var_name_new] = it_aka->second;
            }

            if (it_init != global_primitives_init_values_.end()) {
               global_primitives_init_values_[m_var_name_new] = it_init->second;
            }
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   // Handle arrays in function call.
   int orig_par_num{ 0 };
   int real_par_num{ 0 };
   bool is_in_array_mode{ false };
   for (; orig_par_num < sig.second.size(); orig_par_num++) {
      if (StaticHelper::stringContains(sig.second.at(orig_par_num).first, ARRAY_INDEX_DENOTER_OPEN)) {
         is_in_array_mode = true;
         auto split{ StaticHelper::split(sig.second.at(orig_par_num).first, ARRAY_INDEX_DENOTER_OPEN) };
         real_args.push_back(real_args_raw.at(real_par_num) + ARRAY_INDEX_DENOTER_OPEN + split[1]);
      }
      else {
         if (is_in_array_mode) {
            real_par_num++;
            is_in_array_mode = false;
         }

         real_args.push_back(real_args_raw.at(real_par_num));
         real_par_num++;
      }
   }

   // Match parameters of caller with callee's function signature.
   for (int par_num = 0; par_num < real_args.size(); par_num++) {
      std::string real_arg{ real_args.at(par_num) };
      std::string param_arg{ sig.second.at(par_num).first };

      if (StaticHelper::stringStartsWith(real_arg, "&")) {
         addDebug("Ignoring pointerization '&' of argument '" + real_arg + "'.");
         real_arg = real_arg.substr(1);
      }

      if (real_arg != param_arg) {
         addDebug("Matching parameter '" + param_arg + "' to argument '" + real_arg + "'.");

         const CppTypeWithQualifiers type_with_qualifiers{ sig.second.at(par_num).second };
         const CppType type_simple{ type_with_qualifiers.first };
         const std::vector<std::string> qualifiers{ type_with_qualifiers.second };
         insertTypeOfVariable(param_arg, { type_simple->copy(true), qualifiers });

         enc_function->applyToMeAndMyChildrenIterative([&param_arg, &real_arg, &function_name, this](const MathStructPtr m) {
            auto m_var{ m->toVariableIfApplicable() };

            if (m_var) {
               std::string m_var_name{ m_var->getVariableName() };

               // TODO: Find out actual name clashes.
               //if (m_var_name == real_arg || StaticHelper::stringStartsWith(m_var_name, real_arg + ".")
               //   || m_var_name == SYMB_REF + real_arg || StaticHelper::stringStartsWith(m_var_name, SYMB_REF + real_arg + ".")) {
               //   addWarning("Possible name clash between argument '" + real_arg + "' given to function '" + function_name + "' and local variable '" + m_var_name + "' used there. Please check.");
               //}

               if (m_var_name == param_arg 
                  || StaticHelper::stringStartsWith(m_var_name, param_arg + ".")
                  || StaticHelper::stringStartsWith(m_var_name, param_arg + ARRAY_INDEX_DENOTER_OPEN)) {
                  std::string old_arg{ param_arg + m_var_name.substr(param_arg.size()) };
                  std::string new_arg{ real_arg + m_var_name.substr(param_arg.size()) };
                  m_var->setVariableName(new_arg);

                  //if (function_aka_from_new_to_old_.count(old_arg)) {
                  //   addDebug("Ignoring type for AKA'd variable '" + old_arg + "' (we'll find it later).");
                  //}
                  //else {
                  //   auto pair = types_of_variables_.at(param_arg).first->deriveSubTypeFor(old_arg, false);

                  //   if (pair.first && pair.first->isConst()) {
                  //      auto init_value = pair.second.first;

                  //      data_->declareVariable(new_arg, true);

                  //      if (init_value) {
                  //         auto init_value_str = *init_value;
                  //         auto init_value_float = MathStruct::parseMathStruct(init_value_str, parser_, data_)->eval(data_, parser_);
                  //         data_->addOrSetSingleVal(new_arg, init_value_float);
                  //         m_var->setConstVariable(init_value_float);
                  //      }
                  //   }
                  //   else if (!pair.first) {
                  //      addError("No type found for '" + old_arg + "'.");
                  //   }
                  //}
               }
               else if (m_var_name == SYMB_REF + param_arg || StaticHelper::stringStartsWith(m_var_name, SYMB_REF + param_arg + ".")) {
                  m_var->setVariableName(SYMB_REF + real_arg + m_var_name.substr(param_arg.size() + 1));
               }
            }
         }, TraverseCompoundsType::avoid_compound_structures);
      }
      else {
         addDebug("Found parameter '" + param_arg + "' which is equal to the given argument, so no action is taken.");
      }
   }

   // Do the actual inlining.
   const int start_pos{ (int) (index_begin_orig - function_name.size()) };
   int dummy_pos{ start_pos };
   auto tokens_before{ *StaticHelper::tokenize(
      result, *parser_, dummy_pos, std::numeric_limits<int>::max(), true, DEFAULT_REGEX_FOR_TOKENIZER, DEFAULT_IGNORE_CLASS_FOR_TOKENIZER, false, false, AkaTalProcessing::none, {}, false, [](const std::vector<std::string> tokens_so_far) {
      return !tokens_so_far.empty() && (tokens_so_far.back() == ";" || tokens_so_far.back() == "{" || tokens_so_far.back() == "}");
   }) };

   std::string between_part{};
   std::string line_between_part{};
   size_t pos_of_begin_of_line{ (size_t) std::max(dummy_pos, 0) };

   auto func_check{ [](const MathStructPtr m) {
      //m->checkIfAllChildrenHaveConsistentFather();
      //m->checkCompoundConsistency();
   } };

   func_check(enc_function);

   if (enc_function->getTermsJumpIntoCompounds()[0]->getOptorJumpIntoCompound() == SYMB_RETURN) { // The function is a single "return(...);" statement.
      between_part = enc_function->getTermsJumpIntoCompounds()[0]->getTermsJumpIntoCompounds()[0]->serialize();
   }
   else if (function_call_is_isolated_in_line) {
      if (!tokens_before.empty() && tokens_before.at(0) == "=") { // Case "* = f(...);". Assume another token which is the variable to be set.
         std::string set_var_name{ tokens_before.at(1) };
         between_part += set_var_name + ";\n";
         replaceReturnWithAssignment(enc_function, set_var_name);
         func_check(enc_function);
      }                                                           // Case "f(...);" needs no further action.

      between_part += StaticHelper::replaceAll(enc_function->getTermsJumpIntoCompounds()[0]->serialize(), SYMB_REF, "");
   }
   else { // Function has no sideeffects (otherwise it would be isolated).
      auto return_type{ sig.first };
      std::string temp_var_name{ TEMP_VAR_BASE_NAME + std::to_string(temp_variable_counter_++) };
      replaceReturnWithAssignment(enc_function, temp_var_name);

      processTypeForVariableName(temp_var_name, return_type->copy(true), {});
      fillTypeIntoTAL(temp_var_name, type_abstraction_layer_);

      int i{ 0 };

      while (i < tokens_before.size() && tokens_before.at(i) != "=") {
         i++;
      }

      std::string set_var_name{};
      if (i == tokens_before.size()) { // No equal sign, so no assignment but pure function.
         if (tokens_before.at(i - 1) != ";" && tokens_before.at(i - 1) != "{" && tokens_before.at(i - 1) != "}") {
            set_var_name = tokens_before.at(i - 1);
         }
         else {
            set_var_name = tokens_before.at(i - 2);
         }
      }
      else {
         set_var_name = tokens_before.at(i + 1);
      }

      while (result.substr(pos_of_begin_of_line, set_var_name.size()) != set_var_name) {
         pos_of_begin_of_line++;
      }

      line_between_part += StaticHelper::replaceAll(enc_function->getTermsJumpIntoCompounds()[0]->serialize(), SYMB_REF, "");

      //dummy_pos = start_pos;
      //auto tokens_after = findTokensAfterFunctionCall(result, dummy_pos);
      between_part = temp_var_name;
   }

   std::string before_part{ result.substr(0, index_begin_orig - function_name.size() + 1) };
   std::string after_part{ result.substr(end_pos + 1) };
   result = before_part + between_part + after_part;

   if (!line_between_part.empty()) {
      std::string before_part_line{ result.substr(0, pos_of_begin_of_line) };
      std::string from_line_part{ result.substr(pos_of_begin_of_line) };
      result = before_part_line + line_between_part + ";\n" + from_line_part;
   }
}

std::string vfm::CppParser::preprocessCppFunctionInlineFunctionsAndConstructors(const std::string& overall_function_name, const std::string& function)
{
   std::string result{ function };
   std::map<std::string, CppFunctionSignature> tokens_to_look_at{ function_signatures_ };

   populateDatatypesToLookAt(tokens_to_look_at);

   for (const auto& sig_pair : tokens_to_look_at) {
      std::string function_name{ sig_pair.first };
      CppFunctionSignature sig{ sig_pair.second };
      int index_begin{ (int) result.find(function_name) };

      while (index_begin >= 0) {
         if (isFunctionStyle(result, index_begin, function_name)) {
            if (sig.first->getName() == NULL_SIGNATURE_RETURN_TYPE) {
               // For constructor calls replace with input-converted value: vfc::CSI::si_kilometre_per_hour_f32_t(5) ==> (5 / 3.6)
               int index_begin_inner{ (int) (index_begin + function_name.size()) };
               int index_end{ StaticHelper::findMatchingEndTagLevelwise(result, index_begin_inner, "(", ")") };
               std::string inner{ result.substr(index_begin_inner + 1, index_end - index_begin_inner - 1) };
               std::string whole{ result.substr(index_begin, index_end - index_begin + 1) };

               StaticHelper::trim(inner);

               if (inner.empty()) { // Assume 0 when empty.
                  inner = "0";
               }
               else { // Remove 'f', 'U' etc. if number.
                  if (std::isdigit(inner[0]) || inner[0] == '.') {
                     removeCppNumTypeDenotersFromNumber(inner);
                  }
               }

               std::string actual_name{ function_name };
               if (using_mapping_.count(function_name)) {
                  actual_name = using_mapping_.at(function_name);
               }

               for (const auto& type : data_types_) {
                  if (type->getName() == actual_name) {
                     auto in_map = type->toAtomicIfApplicable()->getInMapping()->copy();

                     in_map->applyToMeAndMyChildren([&inner](const MathStructPtr m) {
                        if (m->isTermVar() && m->toVariableIfApplicable()->getVariableName() == OUT_VAR_NAME) {
                           m->getFather()->replaceOperand(m->toTermIfApplicable(), _var(inner));
                        }
                     });

                     inner = in_map->getTermsJumpIntoCompounds()[1]->serialize();
                  }
               }

               result = StaticHelper::replaceAll(result, whole, "(" + inner + ")");
            }
            else { // For functions take out the arguments: isAllowedToDrive(input, output) ==> isAllowedToDrive() or match arguments and inline.
               index_begin += function_name.size() - 1;
               int index_begin_orig = index_begin;
               for (; index_begin + 1 < result.size() && result[index_begin + 1] == ' '; index_begin++);

               if (options_.getFunctionInlineType() == FunctionInlineTypeEnum::Always) {
                  addNote("Found function '" + function_name + "' to be inlined within function '" + overall_function_name + "'.");
                  const bool function_has_sideeffects = hasCppFunctionSideeffects(function_name);
                  const bool function_call_is_isolated_in_line = functionIsIsolatedOnLine(result, index_begin);

                  if (!function_has_sideeffects || function_call_is_isolated_in_line) {
                     inlineFunction(result, index_begin, function_name, sig, index_begin_orig, function_call_is_isolated_in_line);
                     return preprocessCppFunctionInlineFunctionsAndConstructors(overall_function_name, result);
                  }
                  else {
                     addError("Function '" + function_name + "' has sideeffects, but occurs NOT ISOLATED on either its own line or the right side of an assignment. Here's the context:");
                     const size_t beg = std::max(0, index_begin - 220);
                     const size_t end = index_begin - beg + 350;
                     addError("[...]" + result.substr(beg, end) + "[...]");
                  }
               } 
               else if (options_.getFunctionInlineType() == FunctionInlineTypeEnum::Never) {
                  int i = index_begin;
                  int arg_count = 0;

                  for (const auto& type : sig.second) {
                     arg_count++;
                     for (; i < result.size() && result[i] != ',' && result[i] != '('; i++); // TODO: This is flat, the new inlining functionality allows nested brackets in arguments, too: f(a, (b+4), c).
                     i++;

                     std::string arg_name = type.first;
                     bool arg_found = false;

                     for (; i + arg_name.size() < result.size(); i++) {
                        if (result[i] == ',' || result[i] == ')') {
                           break;
                        }
                        else if (result.substr(i, arg_name.size()) == arg_name) {
                           arg_found = true;
                           i += arg_name.size();
                           break;
                        }
                     }

                     if (!arg_found) {
                        addError("Argument '" + arg_name + "' (#arg " + std::to_string(arg_count) + " of type '" + toStringFullType(type) + "') expected, but not found in call of function '" + function_name + "'.");
                        addDebug("This is the code in question: '" + function + "'.");
                        addError("Assuming you want to emulate a function call, but the option '" + VFM_OPTION_FUNCTION_INLINING + "' has been set to '" + options_.getFunctionInlineType().getEnumAsString() + "'.");
                     }
                  }

                  for (; i < result.size() && result[i] != ')' && result[i] != ','; i++);
                  if (result[i] == ',') {
                     i++;
                  }

                  std::string before_part = result.substr(0, index_begin + 2);
                  std::string after_part = result.substr(i);
                  result = before_part + " " + after_part;
               }
               else {
                  addFatalError("Unknown function inlining type.");
               }
            }
         }

         index_begin = result.find(function_name, index_begin + 1);
      }
   }

   return result;
}

std::string vfm::CppParser::localVarName(const std::string& function_name, const std::string& raw_var_name) const
{
   return function_name + "." + raw_var_name;
}

std::string vfm::CppParser::isLocalVarName(const std::string& qualified_var_name) const
{
   int pos = qualified_var_name.find(".");
   std::string base_name = pos >= 0 ? qualified_var_name.substr(0, pos) : qualified_var_name;
   return function_definitions_.count(StaticHelper::cleanVarNameOfPossibleRefSymbol(base_name)) ? base_name : "";
}

std::string vfm::CppParser::localVarNameActualCall(const std::string& function_name, const std::string& qualified_var_name)
{
   int caller_num = function_call_counters_.at(function_name);
   
   if (caller_num) { // Only for repeated call to same function qualify further.
      return qualified_var_name + "." + std::to_string(caller_num);
   }

   return qualified_var_name;
}

void vfm::insertIfNotAlreadyThere( // TODO: Yeah, wouldn't need this if we used a set instead of a vector.
   std::vector<std::pair<std::string, vfm::CppType>>& local_variables_raw_names_with_type, 
   const std::string& insert_name, 
   const CppType type)
{
   bool already_there = false;
   for (const auto& item : local_variables_raw_names_with_type) {
      if (item.first == insert_name) {
         already_there = true;
         break;
      }
   }

   if (!already_there) {
      local_variables_raw_names_with_type.push_back({ insert_name, type->copy(true) });
   }
}

void vfm::CppParser::renameLocalVariablesAndCreateInitsForComplexDatatypes(
   const std::string& function_name, const std::vector<std::pair<std::string, CppType>>& local_variables_raw_names_with_type, std::vector<std::string>& tokens2)
{
   for (int i = 0; i < tokens2.size(); i++) { // Rename local variables.
      auto& token = tokens2.at(i);

      for (const auto& variable : local_variables_raw_names_with_type) {
         std::vector<std::string> init_tokens;

         if (token == variable.first || StaticHelper::stringStartsWith(token, variable.first + ".")) {
            token = localVarName(function_name, token);

            if ((token == variable.first || token == localVarName(function_name, variable.first))
               && !variable.second->toAtomicIfApplicable()) {
               if (tokens2.at(i + 1) == ";") { // Only "Type x;" treated as constructor call.
                  addDebug("Creating initializations for newly constructed variable '" + token + "' of complex type '" + variable.second->getName() + "'.");

                  for (const auto& subvar : variable.second->getAllAtomicMemberNamesRecursively(token + ".")) {
                     auto vvv = variable.second->deriveSubTypeFor(subvar, true);

                     if (vvv.second.first) {
                        tokens2.insert(tokens2.begin() + i++, subvar);
                        tokens2.insert(tokens2.begin() + i++, SYMB_SET_VAR_A);
                        tokens2.insert(tokens2.begin() + i++, *vvv.second.first);
                        tokens2.insert(tokens2.begin() + i++, SYMB_SEQUENCE);

                        addDebugPlain("   " + tokens2.at(i - 4) + tokens2.at(i - 3) + tokens2.at(i - 2) + tokens2.at(i - 1));
                     }
                     else {
                        addDebugPlain("   Skipping '" + subvar + "'.");
                     }
                  }
               }
               else if (tokens2.at(i + 1) == "{" || tokens2.at(i + 1) == "(") {
                  addError("Currently vfm doesn't support construction via '" + tokens2.at(i + 1) + "'.");
               }
            }

            break;
         }
         else { // Rename local variables for array access.
            if (StaticHelper::stringContains(token, ARRAY_INDEX_DENOTER_OPEN)) {
               auto token2 = StaticHelper::replaceAll(token, ARRAY_INDEX_DENOTER_OPEN + variable.first, ARRAY_INDEX_DENOTER_OPEN + localVarName(function_name, variable.first));

               if (StaticHelper::stringStartsWith(token2, variable.first + ARRAY_INDEX_DENOTER_OPEN)) {
                  token2 = localVarName(function_name, token2);
               }

               if (token != token2) {
                  token = token2;
               }
            }
         }
      }
   }
}

std::string vfm::CppParser::preprocessCppFunctionComplexDatatypes(const std::string& function_name, const std::string& function)
{
   std::string result{ function };
   std::map<std::string, CppFunctionSignature> tokens_to_look_at{};

   populateDatatypesToLookAt(tokens_to_look_at);
   auto tokens{ *StaticHelper::tokenizeSimple(function) };
   std::vector<std::string> tokens2{};

   for (std::vector<std::string>::iterator found = tokens.begin(); found != tokens.end(); found++) {
      bool has_been_found{ false };

      for (const auto& token_to_look_at : tokens_to_look_at) { // Handle arrays: int x[3] = {1, 2, 3}; ==> int x___2 = 3; int x___1 = 2; int x___0 = 1;
         if (*found == token_to_look_at.first) {
            has_been_found = true;
            std::vector<std::string> datatype_tokens;
            found++;

            for (; *(found - 1) != SYMB_SEQUENCE && found != tokens.end(); found++) {
               datatype_tokens.push_back(*(found - 1));
            }

            datatype_tokens.push_back(*(found - 1));
            datatype_tokens = preprocessArraysInStructOrSignature(datatype_tokens, '{', '}', ";", true, function_name);
            tokens2.insert(tokens2.end(), datatype_tokens.begin(), datatype_tokens.end());
            found--;
            break;
         }
      }

      if (!has_been_found) {
         tokens2.push_back(*found);
      }
   }

   std::vector<std::pair<std::string, CppType>> local_variables_raw_names_with_type{};
   std::vector<std::string>::iterator previous{ tokens2.begin() };
   for (std::vector<std::string>::iterator found = tokens2.begin(); found != tokens2.end(); found++) { // Memorize and remove datatypes from declarations.
      for (const auto& token_to_look_at : tokens_to_look_at) {
         if (*found == token_to_look_at.first) {
            for (const auto& type : data_types_) {
               if (type->getName() == *found) {
                  int i{ 1 };
                  std::string var_name{ *(found + i) };
                  //std::string init_value; // TODO: Remove this and below lines. Init value can be completely arbitrary for local variables.

                  while (var_name == "&" || var_name == "*" || var_name == "const" || var_name == "constexpr" || var_name == "static") {
                     i++;
                     var_name = *(found + i);
                  }

                  //if (type->toAtomicIfApplicable()) {
                  //   int i2 = i + 1;
                  //   bool ass_found = false;

                  //   while (*(found + i2) != ";") {
                  //      if (*(found + i2) == "=") {
                  //         ass_found = i2;
                  //         //*(found + i2) = ""; // Here and below we remove the assignment and replace it by a specific "init value".
                  //         break;
                  //      }
                  //      else {
                  //         i2++;
                  //      }
                  //   }

                  //   if (ass_found) {
                  //      i2++;
                  //      while (*(found + i2) != ";") { // Cf. (almost) double code in addStruct.
                  //         auto proc_token = *(found + i2);

                  //         if (std::isdigit(proc_token[0]) || proc_token[0] == '.') {
                  //            removeCppNumTypeDenotersFromNumber(proc_token);
                  //         }

                  //         init_value += proc_token;
                  //         //*(found + i2) = "";
                  //         i2++;
                  //      }
                  //   }
                  //}

                  insertIfNotAlreadyThere(local_variables_raw_names_with_type, var_name, type);

                  size_t index{ var_name.find(ARRAY_INDEX_DENOTER_OPEN) };
                  if (index >= 0) { // For arrays "arr___6i9___" insert "arr" as well.
                     insertIfNotAlreadyThere(local_variables_raw_names_with_type, var_name.substr(0, index), type);
                  }
                  
                  global_primitives_init_values_[localVarName(function_name, var_name)] = FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER;

                  break;
               }
            }

            for (int i = previous == found; i <= 3; i++) { // Clear datatype declaration for later removal. "const" "Type" "*" "const" "myvar" ==> "" "" "" "" "myvar"
               if (previous == tokens2.end()) {
                  break;
               } else {
                  if (previous == found || *previous == "constexpr" || *previous == "static" || *previous == "const" || *previous == "&" || *previous == "*") {
                     *previous = "";
                  }
               }

               previous++;
            }

            break;
         }
      }
   
      previous = found;
   }

   tokens2.erase(remove(tokens2.begin(), tokens2.end(), ""), tokens2.end()); // Remove cleared elements.

   renameLocalVariablesAndCreateInitsForComplexDatatypes(function_name, local_variables_raw_names_with_type, tokens2);

   for (const auto& variable : local_variables_raw_names_with_type) { // Register variable types. // TODO: Throws error if variable already has a different datatype within same function, even when in another scope.
      insertTypeOfVariable(localVarName(function_name, variable.first), { variable.second, {} }, false);
   }

   return StaticHelper::tokensAsString(tokens2);
}

void vfm::CppParser::findVariableNamesInArrayAccess(std::string& original_arr_full_access, std::string& arr_full_access, std::set<std::string>& var_names_in_single_array)
{
   std::set<std::string> blacklist;

   while (arr_full_access.find(ARRAY_INDEX_DENOTER_OPEN) != std::string::npos) {
      int begin1 = arr_full_access.find(ARRAY_INDEX_DENOTER_OPEN);
      int begin2 = StaticHelper::indexOfFirstInnermostBeginBracket(arr_full_access, ARRAY_INDEX_DENOTER_OPEN, ARRAY_INDEX_DENOTER_CLOSE);

      if (begin1 != begin2) { // Variable at position begin1 is nested array variable.
         begin1 = begin1 + ARRAY_INDEX_DENOTER_OPEN.size();
         int end1 = arr_full_access.find(ARRAY_INDEX_DENOTER_OPEN, begin1);
         blacklist.insert(arr_full_access.substr(begin1, end1 - begin1));
      }

      int end = StaticHelper::findMatchingEndTagLevelwise(arr_full_access, begin2, ARRAY_INDEX_DENOTER_OPEN, ARRAY_INDEX_DENOTER_CLOSE);
      int begin_pos_of_interest = begin2 + ARRAY_INDEX_DENOTER_OPEN.size();
      std::string var_name = arr_full_access.substr(begin_pos_of_interest, end - begin_pos_of_interest);

      char* p;
      long converted = strtol(var_name.c_str(), &p, 10);
      if (!*p) { // It's a number.
         blacklist.insert(var_name);
      }

      arr_full_access = arr_full_access.substr(0, begin2) + "<" + var_name + ">" + arr_full_access.substr(end + ARRAY_INDEX_DENOTER_CLOSE.size());

      if (!blacklist.count(var_name) && !StaticHelper::stringContains(var_name, "<")) {
         var_names_in_single_array.insert(var_name);
      }
   }
}

void vfm::CppParser::createDimsVector(
   std::set<std::string>& var_names_in_single_array, 
   std::shared_ptr<vfm::mc::TypeAbstractionLayer>& tal, 
   std::vector<int>& dims_counter, 
   std::vector<int>& dims, 
   std::vector<int>& dims_min)
{
   for (const auto& var_name : var_names_in_single_array) {
      processTypeForVariableName(var_name);
      fillTypeIntoTAL(var_name, tal);

      if (tal->getVariablesWithTypes().count(var_name)) {
         auto type = tal->getVariablesWithTypes().at(var_name);
         auto values = mc::TypeAbstractionLayer::getMCValues(tal->getVariablesWithTypes().at(var_name).first);

         if (values.empty()) {
            addError("No values found in range for variable '" + var_name + "'.");
         }
         else {
            if (StaticHelper::isParsableAsFloat(values.at(0)) && StaticHelper::isParsableAsFloat(values.at(values.size() - 1))) {
               float range_min{ std::stof(values.at(0)) };
               float range_max{ std::stof(values.at(values.size() - 1)) };

               dims_counter.push_back(range_max - range_min);
               dims.push_back(range_max - range_min + 1);
               dims_min.push_back(range_min);
            }
            else if (mc::TypeAbstractionLayer::getCppType(type.first)->toEnumIfApplicable()) { // TODO: Actual enums not possible, only casts to int.
               auto enum_type = mc::TypeAbstractionLayer::getCppType(type.first)->toEnumIfApplicable();
               int range_min = std::numeric_limits<int>::max();
               int range_max = std::numeric_limits<int>::min();
               std::string vals = " ";

               for (const auto& el : enum_type->getPossibleValues()) {
                  auto val = el.first;
                  vals += std::to_string(val) + " ";

                  if (val < range_min) {
                     range_min = val;
                  }
                  if (val > range_max) {
                     range_max = val;
                  }
               }

               if (range_max - range_min != enum_type->getPossibleValues().size() - 1) {
                  addError("Detected gap in numeric values '" + vals 
                     + "' for enum '" + mc::TypeAbstractionLayer::getCppType(type.first)->getName() 
                     + "'. Array processing won't work correctly for '" + var_name + "'.");
               }

               dims_counter.push_back(range_max - range_min); // TODO: Double code.
               dims.push_back(range_max - range_min + 1);
               dims_min.push_back(range_min);
            }
            else {
               addError("TODO: value '" + values.at(0) + "' in range for '" + var_name + "' is not constant, but a formula. This still needs to be implemented.");
            }
         }
      }
      else if (tal) {
         addError("No TAL range found for variable '" + var_name + "'.");
      }
   }
}

void vfm::CppParser::createIfStatement(std::vector<int>& dims_counter, std::shared_ptr<vfm::Term>& current_if, std::vector<int>& dims, std::string& arr_full_access, std::vector<int>& dims_min, std::set<std::string>& var_names_in_single_array, std::shared_ptr<vfm::TermVar>& m2_var, vfm::TermPtr& m2_var_right_side, std::string& original_arr_full_access, std::shared_ptr<vfm::mc::TypeAbstractionLayer>& tal)
{
   if (original_arr_full_access == "ego.gaps___6tar_dir9___.i_agent_rear") {
      int x{};
   }

   if (VECTOR_COUNTER_IS_ALL_ZERO(dims)) {
      // TODO

      return;
   }

   CppType inferred_type{ nullptr };

   while (!VECTOR_COUNTER_IS_ALL_ZERO(dims_counter)) {
      VECTOR_COUNTER_DECREMENT(dims, dims_counter);
      std::string curr_arr_full_access = arr_full_access;
      auto condition = _true();
      bool has_negative_indices = false;

      for (int i = 0; i < dims_counter.size(); i++) {
         int current_val = dims_counter.at(i) + dims_min.at(i);
         std::string var_name = *std::next(var_names_in_single_array.begin(), i);
         std::string old_name = "<" + var_name + ">";
         std::string new_name = ARRAY_INDEX_DENOTER_OPEN + std::to_string(current_val) + ARRAY_INDEX_DENOTER_CLOSE;
         curr_arr_full_access = StaticHelper::replaceAll(curr_arr_full_access, old_name, new_name);

         if (current_val < 0) {
            addWarning("Array '" + arr_full_access + "' has potentially negative index " + std::to_string(current_val) + " in '" + var_name + "'. Skipping this case - please make sure it actually cannot occur.");
            has_negative_indices = true;
            break;
         }

         TermPtr final_val = _val(current_val); // Assume it's a plain integer index.

         if (types_of_variables_.count(var_name) && types_of_variables_.at(var_name).first->toEnumIfApplicable()) {
            auto enum_type = types_of_variables_.at(var_name).first->toEnumIfApplicable(); // It's an enum after all.
            final_val = _var(enum_type->getName() + "::" + enum_type->getPossibleValues().at(current_val));
         }

         condition = _and(condition, _eq(_var(var_name), final_val));
      }

      curr_arr_full_access = StaticHelper::cleanVarNameOfPossibleRefSymbol(
         StaticHelper::replaceAll(StaticHelper::replaceAll(curr_arr_full_access, "<", ARRAY_INDEX_DENOTER_OPEN), ">", ARRAY_INDEX_DENOTER_CLOSE));

      if (!has_negative_indices) {
         current_if = current_if->getTermsJumpIntoCompounds()[2]; // Go into else case.

         auto assignment = m2_var->isTermVarOnLeftSideOfAssignment()
            ? _set_alt(_var(SYMB_REF + curr_arr_full_access), m2_var_right_side->copy())
            : _set_alt(_var(SYMB_REF + original_arr_full_access), _var(curr_arr_full_access));

         auto new_if = _ifelse(condition, assignment, _false());
         current_if->replace(new_if);
         current_if = new_if;

      //if (VECTOR_COUNTER_IS_ALL_ZERO(dims_counter)) {
         processTypeForVariableName(curr_arr_full_access);

         if (!fillTypeIntoTAL(curr_arr_full_access, tal)) {
            continue;
         }

         auto type_int = types_of_variables_.count(curr_arr_full_access) 
            ? types_of_variables_.at(curr_arr_full_access).first 
            : nullptr;

         // Part for the auto-generated env model in native SMV.
         TypeWithInitAndRangeOrAka type = TypeWithInitAndRangeOrAka{ type_int, { {nullptr}, {nullptr, nullptr} } }; // Type for the case we have no struct cascade due to SMV env model.

         if (StaticHelper::stringContains(curr_arr_full_access, "ego.gaps___6") && StaticHelper::stringContains(curr_arr_full_access, "9___.v_front")) {
            addWarning("TODO<2>: The variable '" + curr_arr_full_access + "' has been handled hardcoded, needs to be solved on env model side eventually. For DEFINEs, the type cannot be inferred yet.");
            type.second.second.first = std::make_shared<std::string>(".." + StaticHelper::safeString("0..70"));
         }

         if (!type.first) {
            auto pair = types_of_variables_.at(getTypeBaseName(curr_arr_full_access));
            type = pair.first->deriveSubTypeFor(curr_arr_full_access, !isLocalVarName(curr_arr_full_access).empty());
         }

         if (!type.second.second.first) { // Try finding TAL range description in global variables.
            if (global_primitives_tal_range_descriptions_.count(original_arr_full_access)) {
               type.second.second.first = std::make_shared<std::string>(global_primitives_tal_range_descriptions_.at(original_arr_full_access));
            }

            if (global_primitives_tal_range_descriptions_.count(curr_arr_full_access)) {
               type.second.second.first = std::make_shared<std::string>(global_primitives_tal_range_descriptions_.at(curr_arr_full_access));
            }
         }
         // EO part for the auto-generated env model in native SMV.

         if (types_of_variables_.count(getTypeBaseName(curr_arr_full_access))) { // Type if we have a struct cascade after all.
            auto pair = types_of_variables_.at(getTypeBaseName(curr_arr_full_access));
            type = pair.first->deriveSubTypeFor(curr_arr_full_access, !isLocalVarName(curr_arr_full_access).empty());
         }

         if (type.first) {
            m2_var->setVariableName(original_arr_full_access);

            // Collect "super type" from all ranges this variable could take on.
            if (!inferred_type) {
               inferred_type = type.first->copy(false);
            }

            auto inferred_type_int{ inferred_type->toIntegerIfApplicable() };

            if (inferred_type_int) {
               const std::pair<int, int> type_range{ type.first->toIntegerIfApplicable()->getRange() };
               inferred_type_int->extendRange(type_range); // In case optional range was already set.
               const std::string global_primitives_range{ StaticHelper::fromSafeString(type.second.second.first->substr(2)) };
               const auto global_range{ StaticHelper::split(global_primitives_range, STRING_PREFIX_TAL) };
               const int min{ static_cast<int>(MathStruct::parseMathStruct(global_range.at(0), parser_, data_)->eval(data_, parser_)) }; // TODO: Is it ok to do the eval() here already or should it be serialize()?
               const int max{ static_cast<int>(MathStruct::parseMathStruct(global_range.at(1), parser_, data_)->eval(data_, parser_)) };

               assert(type_range.first > type_range.second || (min == type_range.first && max == type_range.second)); // Either type_range is initialized or equal to the other.
               inferred_type_int->extendRange(min, max);
            }

            if (!type.second.second.first) {
               addError("No TAL range description derived for '" + curr_arr_full_access + "'/'" + original_arr_full_access + "'.");
            }

            //processTypeForVariableName(original_arr_full_access);
            //fillTypeIntoTAL(original_arr_full_access, type_abstraction_layer_);
         }
         else {
            addError("No subtype derived for '" + curr_arr_full_access + "'.");
         }
      //}
      }
   }

   if (inferred_type) {
      // Set the type collected as super-type of all the possible types this variable could take on.
      insertTypeOfVariable(original_arr_full_access, { inferred_type,{} });
      auto inferred_type_int{ inferred_type->toIntegerIfApplicable() };

      if (inferred_type_int) {
         std::pair<int, int> range{ inferred_type_int->getRange() };
         std::string string_range{ STRING_PREFIX_TAL + StaticHelper::safeString(std::to_string(range.first) + STRING_PREFIX_TAL + std::to_string(range.second)) };

         global_primitives_tal_range_descriptions_.insert( // TODO: This will intentionally fail when the TAL is global. Fix it then and don't hate your past self...
            { original_arr_full_access, string_range });
      }
      else {
         addError("Derived type '" + inferred_type->toString() + "' of '" + original_arr_full_access + "' is not int. TODO: Not sure if this can happen in a non-error run, if so, remove this error message.");
      }
   }
}

std::string vfm::CppParser::findSomePossibleValueFor(const std::string& inner, const std::string& var_name_right)
{
   std::string some_possible_value;
   std::string base_name = getTypeBaseName(inner);

   if (!types_of_variables_.count(base_name)) {
      addError("Variable '" + base_name + "' not found in types_of_variables_.");
      return "";
   }

   auto pair = types_of_variables_.at(base_name).first->deriveSubTypeFor(inner, !isLocalVarName(inner).empty());
   auto type = pair.first;
   auto range = pair.second.second.first;

   if (!range) {
      if (global_primitives_tal_range_descriptions_.count(inner)) {
         range = std::make_shared<std::string>(global_primitives_tal_range_descriptions_.at(inner));
      }
   }

   if (type->toEnumIfApplicable() && !type->toEnumIfApplicable()->getPossibleValues().empty()) {
      some_possible_value = _val(type->toEnumIfApplicable()->getPossibleValues().begin()->first)->serialize();
   }
   else if (type->toAtomicIfApplicable() && type->getName() == "bool") {
      some_possible_value = _val0()->serialize();
   }
   else if (range) {
      auto range_decrypted = StaticHelper::fromSafeString(range->substr(STRING_PREFIX_TAL.size()));
      auto last = StaticHelper::split(range_decrypted, STRING_PREFIX_TAL)[1]; // We take the upper bound since we use it in an array, and the upper bound is the "least negative one".
      auto fmla = MathStruct::parseMathStruct(last, parser_, data_);
      auto value = fmla->eval(data_, parser_);
      some_possible_value = _val(value)->serialize();
   }
   else {
      std::string optional_part = var_name_right.empty() ? "" : " as used in '" + var_name_right + "'";
      addError("Could not derive any possible value for variable '" + inner + "'" + optional_part + ".");
      some_possible_value = _val0()->serialize();
   }

   return some_possible_value;
}

void vfm::CppParser::inferType(const std::string& var_name_to_infer_type_for, const std::string& var_name_with_temporarrays_replaced)
{
   auto var_name_to_infer_type_for_clean = StaticHelper::cleanVarNameOfPossibleRefSymbol(var_name_to_infer_type_for);

   //var_right->setVariableName(new_var_name_right);
   std::string base_name = getTypeBaseName(var_name_with_temporarrays_replaced);

   if (types_of_variables_.count(base_name)) {
      auto pair = types_of_variables_.at(base_name).first->deriveSubTypeFor(var_name_with_temporarrays_replaced, !isLocalVarName(var_name_with_temporarrays_replaced).empty());

      if (pair.second.first) {
         global_primitives_init_values_[var_name_to_infer_type_for_clean] = *pair.second.first;
      }
      else {
         addError("No init value found for '" + var_name_to_infer_type_for + "'.");
      }

      if (pair.second.second.first) {
         global_primitives_tal_range_descriptions_[var_name_to_infer_type_for_clean] = *pair.second.second.first;
      }
      else if (pair.second.second.second) {
         global_primitives_aka_descriptions_[var_name_to_infer_type_for_clean] = *pair.second.second.second;
      }
      else {
         addError("No range nor aka description found for '" + var_name_to_infer_type_for + "'.");
      }
   }
   else if (global_primitives_tal_range_descriptions_.count(var_name_with_temporarrays_replaced)) {
      addDebug("Assuming '" + var_name_with_temporarrays_replaced + "' is a native SMV global env model variable. Won't check if '" + var_name_to_infer_type_for_clean + "' has an init value or an aka descripion, but just give it the same range.");
      global_primitives_tal_range_descriptions_[var_name_to_infer_type_for_clean] = global_primitives_tal_range_descriptions_.at(var_name_with_temporarrays_replaced);
   } else {
      addError("No base type '" + base_name + "' found in types_of_variables_.");
   }

   if (types_of_variables_.count(var_name_with_temporarrays_replaced)) {
      processTypeForVariableName(var_name_to_infer_type_for_clean, types_of_variables_.at(var_name_with_temporarrays_replaced).first->copy(false), { "" });
      fillTypeIntoTAL(var_name_to_infer_type_for_clean, type_abstraction_layer_);
   }
   else {
      addError("Variable '" + var_name_with_temporarrays_replaced + "' not found in TAL. Cannot infer type for '" + var_name_to_infer_type_for_clean + "'.");
   }
}

void vfm::CppParser::flattenNestedArrayAccess(const TermPtr formula)
{
   addNote("Flattening nested arrays.");

   bool changed{ true };

   while (changed) {
      changed = false;

      formula->applyToMeAndMyChildrenIterative([&changed, this](const MathStructPtr m2) {
         if (m2->isTermSetVarOrAssignment()) {
            std::string temp_var_name{};
            std::string inner_part{};

            m2->applyToMeAndMyChildrenIterative([&changed, this, &temp_var_name, &inner_part](const MathStructPtr m) {
               auto m_var{ m->toVariableIfApplicable() };

               if (m_var) {
                  auto m_var_name{ m_var->getVariableName() };

                  int pos_begin{ (int) m_var_name.find(ARRAY_INDEX_DENOTER_OPEN) };
                  while (!changed && pos_begin >= 0) { // It's an array access x[Y].
                     int pos_end{ StaticHelper::findMatchingEndTagLevelwise(m_var_name, pos_begin, ARRAY_INDEX_DENOTER_OPEN, ARRAY_INDEX_DENOTER_CLOSE) };
                     std::string before_part{};
                     inner_part = m_var_name;
                     std::string after_part{};

                     StaticHelper::distributeIntoBeforeInnerAfter(before_part, inner_part, after_part, pos_begin + ARRAY_INDEX_DENOTER_OPEN.size(), pos_end);

                     assert(before_part + inner_part + after_part == m_var_name);

                     if (StaticHelper::stringContains(inner_part, ARRAY_INDEX_DENOTER_OPEN)) { // It's a nested array access x[y[z]].
                        temp_var_name = TEMP_VAR_ARRAYS_BASE_NAME + std::to_string(temp_variable_counter_++);
                        const std::string full_name = before_part + temp_var_name + after_part;
                        m_var->setVariableName(full_name);

                        changed = true;
                     }
                     
                     pos_begin = m_var_name.find(ARRAY_INDEX_DENOTER_OPEN, pos_begin + 1);
                  }
               }
            }, TraverseCompoundsType::avoid_compound_structures, changed);

            if (changed) {
               auto line{ _set_alt(_var(SYMB_REF + temp_var_name), _var(inner_part)) };
               m2->replace(_seq(line, m2->copy()->toTermIfApplicable()));
            }
         }
      }, TraverseCompoundsType::avoid_compound_structures, changed);
   }

   addNote("Inferring types and ranges for '" + TEMP_VAR_ARRAYS_BASE_NAME + "...' variables.");

   formula->applyToMeAndMyChildrenIterative([this](const MathStructPtr m2) {
      if (m2->isTermSetVarOrAssignment()) {
         auto var_left{ m2->getTermsJumpIntoCompounds()[0]->toVariableIfApplicable() };
         auto var_name_to_infer_type_for{ var_left->getVariableName() };

         if (StaticHelper::stringStartsWith(StaticHelper::cleanVarNameOfPossibleRefSymbol(var_name_to_infer_type_for), TEMP_VAR_ARRAYS_BASE_NAME)) {
            auto var_right{ m2->getTermsJumpIntoCompounds()[1]->toVariableIfApplicable() };
            auto var_name_right{ var_right->getVariableName() };
            std::string var_name_with_temporarrays_replaced{ var_name_right };

            int pos_begin{ (int) var_name_right.find(ARRAY_INDEX_DENOTER_OPEN) };
            while (pos_begin >= 0) {
               int pos_end{ StaticHelper::findMatchingEndTagLevelwise(var_name_right, pos_begin, ARRAY_INDEX_DENOTER_OPEN, ARRAY_INDEX_DENOTER_CLOSE) };
               std::string some_possible_value{};
               std::string inner{ var_name_right };

               StaticHelper::distributeGetOnlyInner(inner, pos_begin + ARRAY_INDEX_DENOTER_OPEN.size(), pos_end);

               processTypeForVariableName(inner);
               fillTypeIntoTAL(inner, type_abstraction_layer_);

               some_possible_value = findSomePossibleValueFor(inner, var_name_right);

               var_name_with_temporarrays_replaced = StaticHelper::replaceAll(
                  var_name_with_temporarrays_replaced,
                  ARRAY_INDEX_DENOTER_OPEN + inner + ARRAY_INDEX_DENOTER_CLOSE,
                  ARRAY_INDEX_DENOTER_OPEN + some_possible_value + ARRAY_INDEX_DENOTER_CLOSE);

               pos_begin = var_name_right.find(ARRAY_INDEX_DENOTER_OPEN, pos_begin + 1);
            }

            addDebug("Inferring type of '" + var_name_to_infer_type_for + "' by using variable '" + var_name_with_temporarrays_replaced + "' as special case of '" + var_name_right + "'.");
            inferType(var_name_to_infer_type_for, var_name_with_temporarrays_replaced);
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   addNote("Inferring types and ranges for variables containing '" + TEMP_VAR_ARRAYS_BASE_NAME + "...' subparts.");

   formula->applyToMeAndMyChildrenIterative([this](const MathStructPtr m2) {
      auto m_var{ m2->toVariableIfApplicable() };

      if (m_var) {
         auto m_var_name{ StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName()) };

         if (StaticHelper::stringContains(m_var_name, TEMP_VAR_ARRAYS_BASE_NAME) // Var name contains "TEMPORARRAY"...
            && StaticHelper::isWithinLevelwise(                                  // ...and it's within ___6...9___
               m_var_name, 
               m_var_name.find(TEMP_VAR_ARRAYS_BASE_NAME), 
               ARRAY_INDEX_DENOTER_OPEN, 
               ARRAY_INDEX_DENOTER_CLOSE)) {
            auto new_var_name{ m_var_name };
            int pos_begin{ (int) m_var_name.find(ARRAY_INDEX_DENOTER_OPEN) };

            while (pos_begin >= 0) {
               int pos_end{ StaticHelper::findMatchingEndTagLevelwise(m_var_name, pos_begin, ARRAY_INDEX_DENOTER_OPEN, ARRAY_INDEX_DENOTER_CLOSE) };
               std::string some_possible_value{};
               std::string inner{ m_var_name };

               StaticHelper::distributeGetOnlyInner(inner, pos_begin + ARRAY_INDEX_DENOTER_OPEN.size(), pos_end);

               some_possible_value = findSomePossibleValueFor(inner, m_var_name);

               if (some_possible_value.empty()) {
                  addError("No possible value found for '" + inner + "'.");
               } else {
                  new_var_name = StaticHelper::replaceAll(
                     new_var_name,
                     ARRAY_INDEX_DENOTER_OPEN + inner + ARRAY_INDEX_DENOTER_CLOSE,
                     ARRAY_INDEX_DENOTER_OPEN + some_possible_value + ARRAY_INDEX_DENOTER_CLOSE);
               }
               pos_begin = m_var_name.find(ARRAY_INDEX_DENOTER_OPEN, pos_begin + 1);
            }

            inferType(m_var_name, new_var_name);
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);
}

void CppParser::processVariableAccessOnce(const TermPtr formula, const float node_count, float& current_count, int& old_percent, const std::string& message)
{
   auto abandon_children{ std::make_shared<bool>() };

   formula->applyToMeAndMyChildren([this, node_count, &current_count, &old_percent, &message, abandon_children](const MathStructPtr m) {
      current_count++;

      int percent{ (int)(100 * current_count / node_count) };

      if (percent != old_percent) {
         std::cout << StaticHelper::printProgress(message, percent - 1, 100, 100);

         if (percent == 100) {
            std::cout << "\n";
         }
      }

      old_percent = percent;

      if (m->isValid() && m->isSingleLineIfTypeLimited() && !m->isTermVar()) {
         TermPtr m2_var_right_side{ nullptr };

         auto m_deep = m->isTermIf() || m->isTermIfelse() ? m->getTermsJumpIntoCompounds()[0] : m;

         std::vector<std::string> vars_with_arrays_ordered{};
         std::vector<std::shared_ptr<TermVar>> m_vars_to_process{};

         m_deep->applyToMeAndMyChildren([&vars_with_arrays_ordered, &m_vars_to_process, this](const MathStructPtr m2) {
            auto m2_var = m2->toVariableIfApplicable();

            if (m2_var
               && StaticHelper::stringContains(m2_var->getVariableName(), ARRAY_INDEX_DENOTER_OPEN)
               //&& !StaticHelper::stringStartsWith(m2_var->getVariableName(), GLOBAL_VARIABLES_PREFIX) // We've NOT already done this in to-be-inlined function, since array processing shifted to the end.
               ) {
               vars_with_arrays_ordered.push_back(m2_var->getVariableName());
               m_vars_to_process.push_back(m2_var);
            }
         }, TraverseCompoundsType::avoid_compound_structures, nullptr, nullptr, nullptr, nullptr, [](const MathStructPtr m) {
            return m->isTermSetVarOrAssignment();
         });

         auto if_seq = _val0();
         bool changed = false;
         for (int idx = 0; idx < vars_with_arrays_ordered.size(); idx++) {
            bool is_on_left_side_of_assignment = false;
            std::set<std::string> var_names_in_single_array;
            auto& arr_full_access = vars_with_arrays_ordered.at(idx);
            auto m2_var = m_vars_to_process.at(idx);

            std::string original_arr_full_access = arr_full_access;

            if (StaticHelper::stringStartsWith(original_arr_full_access, GLOBAL_VARIABLES_PREFIX)) {
               continue;
            }

            findVariableNamesInArrayAccess(original_arr_full_access, arr_full_access, var_names_in_single_array);

            addDebug("Check if some of the found index variables are constants.");
            bool constant_found = false;
            for (const auto& varname_in_array : var_names_in_single_array) {
               auto var_name_in_array_name{ getTypeOf(varname_in_array) };
               if (var_name_in_array_name) {
                  if (var_name_in_array_name->getName() == IMMUTABLE_ENUM_TYPE_NAME) {
                     constant_found = true;
                     std::string old_name = m2_var->getVariableName();
                     std::string new_name = StaticHelper::replaceAll(
                        old_name,
                        ARRAY_INDEX_DENOTER_OPEN + varname_in_array + ARRAY_INDEX_DENOTER_CLOSE,
                        ARRAY_INDEX_DENOTER_OPEN + std::to_string((int)data_->getSingleVal(varname_in_array)) + ARRAY_INDEX_DENOTER_CLOSE);

                     addDebug("Replacing array access '" + old_name + "' with '" + new_name + "' due to constness of variable '" + varname_in_array + "'.");

                     m2_var->setVariableName(new_name);
                  }
               }
               else {
                  addError("Could not find type for variable '" + varname_in_array + "'.");
               }
            }

            if (constant_found) {
               idx--; // Go for another round with the new array access with less variables.
               continue;
            }

            std::vector<int> dims_counter{};
            std::vector<int> dims_min{};
            std::vector<int> dims{};

            for (const auto& var_name : findAllRecursiveVariableNames(true)) {
               fillTypeIntoTAL(var_name, type_abstraction_layer_); // TODO: Is filling the tal permanently fine? There should be no change in the datatypes over time... right?
            }

            createDimsVector(var_names_in_single_array, type_abstraction_layer_, dims_counter, dims, dims_min);

            if (dims.empty()) {
               continue;
            }

            if (m2_var->isTermVarOnLeftSideOfAssignment()) {
               m2_var_right_side = m->getTermsJumpIntoCompounds()[1]->copy(); // It's an assignment like: veh[i].a = veh[*].v; ==> veh[*].v
            } // else { m2_var_right_side = nullptr;         // It's:                    veh[0].v = veh[i].a; ==> EMPTY }

            changed = true;
            dims_counter[0]++;

            auto current_if = _ifelse(_false(), _false(), _false());
            auto full_if = current_if;

            createIfStatement(dims_counter, current_if, dims, arr_full_access, dims_min, var_names_in_single_array, m2_var, m2_var_right_side, original_arr_full_access, type_abstraction_layer_);

            if (options_.getOptimizationMode() == OptimizationModeEnum::all || options_.getOptimizationMode() == OptimizationModeEnum::inner_only) {
               addDebug("Simplifying IF statement '" + full_if->serialize() + "'.");
               full_if = mc::simplification::simplifyFast(full_if, parser_);
               StaticHelper::checkForOutdatedSimplification(parser_);
            }
            else {
               addWarning("Omitting simplification of IF statement '" + full_if->serialize() + "' due to optimization mode '" + options_.getOptimizationMode().getEnumAsString() + "'. This is not recommended.");
            }

            if_seq = _seq(if_seq, full_if);
         }

         changed = changed && !if_seq->isOverallConstant(); // Don't insert 0.

         if (changed) {
            auto m_copy = m->copy()->toTermIfApplicable();

            if (m2_var_right_side) {
               addDebug("Replacing line '" + m->serialize() + "' with variable array access logic '" + if_seq->serialize() + "'.");
               m->replaceJumpOverCompounds(_seq(if_seq, m_copy));
               m_copy->removeLineFromSequence();
            }
            else {
               addDebug("Adding variable array access logic '" + if_seq->serialize() + "' in front of line '" + m->serialize() + "'.");
               m->replaceJumpOverCompounds(_seq(if_seq, m_copy));
               addDebug("Result: '" + m->getPtrToRoot()->serialize() + "'.");

               if (m_copy->isTermIf() || m_copy->isTermIfelse()) {
                  processVariableAccessOnce(m_copy->child1JumpIntoCompounds(), node_count, current_count, old_percent, message);
               }

               if (m_copy->isTermIfelse()) {
                  processVariableAccessOnce(m_copy->child2JumpIntoCompounds(), node_count, current_count, old_percent, message);
               }
            }

            *abandon_children = true;
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures, abandon_children);
}

void vfm::CppParser::processVariableArrayAccess(const TermPtr formula)
{
   pauseOutputOfMessages();
   
   float node_count{ (float) formula->getNodeCount() };
   float current_count{ 0 };
   int old_percent{ 0 };
   addNote("Processing array access with variable indices.");
   processVariableAccessOnce(formula, node_count, current_count, old_percent, "Array processing <logging paused>");

   resumeOutputOfMessages();
}

void vfm::CppParser::processInFunctionTalDescriptions(const TermPtr formula)
{
   formula->applyToMeAndMyChildrenIterative([this](const MathStructPtr m) {
      auto m_var = m->toVariableIfApplicable();

      if (m_var) {
         auto m_var_name = m_var->getVariableName();
         
         if (StaticHelper::stringContains(m_var_name, STRING_PREFIX_TAL) 
            && !StaticHelper::stringContains(m_var_name, STRING_PREFIX_AKA)) {
            auto split = StaticHelper::split(m_var_name, STRING_PREFIX_TAL);

            assert(split.size() == 2);

            auto actual_var_name = split[0];
            auto range_desc = STRING_PREFIX_TAL + split[1];

            if (global_primitives_tal_range_descriptions_.count(actual_var_name)) {
               const auto plain_text_range = StaticHelper::fromSafeString(split[1]);
               const auto plain_text_range_old = StaticHelper::fromSafeString(global_primitives_tal_range_descriptions_.at(actual_var_name).substr(STRING_PREFIX_TAL.size()));

               if (plain_text_range != plain_text_range_old) {
                  addError("Variable '" + actual_var_name + "' has already range '" + plain_text_range_old + "', but range '" + plain_text_range + "' is requested to be set.");
               }
            }

            global_primitives_tal_range_descriptions_.insert({ actual_var_name, range_desc });
            m_var->setVariableName(actual_var_name);
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);
}

void vfm::CppParser::collectDatatypesInFunction(const vfm::TermPtr & formula)
{
   auto ignore_msg = [this](const std::string& var_name) {addDebug("Ignoring type for AKA'd variable '" + var_name + "' (we'll find it later)."); };

   addNote("Collecting datatypes in function.");
   formula->applyToMeAndMyChildrenIterative([this, ignore_msg](const MathStructPtr m) {
      auto m_var = m->toVariableIfApplicable();

      if (m_var) {
         auto m_var_name = StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName());
         auto it = types_of_variables_.find(m_var_name);

         if (it != types_of_variables_.end() && it->second.first) { // TODO: it->second.first shouldn't become NULL.
            addDebug("Found type '" + it->second.first->getName() + "' for variable '" + m_var_name + "'.");
         }
         else if (StaticHelper::stringContains(m_var_name, STRING_PREFIX_AKA)) {
            ignore_msg(m_var_name);
         }
         else {
            if (function_aka_from_new_to_old_.count(m_var_name)) {
               ignore_msg(m_var_name);
            }
            else {
               it = types_of_variables_.find(getTypeBaseName(m_var_name));
               auto type = it == types_of_variables_.end() ? TypeWithInitAndRangeOrAka{ nullptr,{} } : it->second.first->deriveSubTypeFor(m_var_name, !isLocalVarName(m_var_name).empty());

               if (type.first) {
                  addNote("Found subtype '" + type.first->getName() + "' for variable '" + m_var_name + "'.");
                  insertTypeOfVariable(m_var_name, { type.first,{} }); // TODO: Qualifiers are dropped ("{}" in the end).
               }
               else {
                  addError("No type derived for '" + m_var_name + "'.");
               }
            }
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);
}

TermPtr vfm::CppParser::flattenNestedArrayAccessSafe(const TermPtr formula)
{
   auto formula_safe = _id(formula);
   flattenNestedArrayAccess(formula_safe);
   return formula_safe->getTermsJumpIntoCompounds()[0];
}

TermPtr vfm::CppParser::removeUneffectiveLinesSafe(const TermPtr formula)
{
   auto formula_safe = _id(formula);
   removeUneffectiveLines(formula_safe);
   return formula_safe->getTermsJumpIntoCompounds()[0];
}

void vfm::CppParser::writeMortyGUIProgressFile(const int percent, const std::string& stage_name) const
{
   if (!TARGET_PATH_FOR_MORTY_GUY_PROGRESS.empty()) {
      std::filesystem::path morty_progress_path{ TARGET_PATH_FOR_MORTY_GUY_PROGRESS };
      morty_progress_path /= "progress.morty";
      StaticHelper::writeTextToFile(std::to_string(percent) + "#100#" + stage_name, morty_progress_path.string());
   }
}

void vfm::CppParser::deleteMortyGUIProgressFile() const
{
   if (!TARGET_PATH_FOR_MORTY_GUY_PROGRESS.empty()) {
      std::filesystem::path morty_progress_path{ TARGET_PATH_FOR_MORTY_GUY_PROGRESS };
      morty_progress_path /= "progress.morty";
      if (std::filesystem::exists(morty_progress_path)) {
         std::filesystem::remove(morty_progress_path);
      }
   }
}

void vfm::CppParser::applyConstnessToAllMCItems()
{
   applyToAllMCItems([this](const MathStructPtr m) {
      auto m_var{ m->toVariableIfApplicable() };

      if (m_var && data_->isConst(m_var->getVariableName())) {
         m_var->setConstVariable(data_->getSingleVal(m_var->getVariableName()));
      }
      }, true);
}

void vfm::CppParser::postprocessSemanticStuff(const vfm::TermPtr& formula_raw, const std::string& main_function_chunk)
{
   std::set<int> main_function_params{ parser_->getNumParams(main_function_name_) };
   
   if (main_function_params.size() > 1) {
      addError("Found " + std::to_string(main_function_params.size()) + " overloaded versions of main function '" + main_function_name_ + "'. Only 1 is ok. I'll keep going by using a random one.");
   }
   else if (main_function_params.empty()) {
      addError("No main function '" + main_function_name_ + "' found. I'll skip the postprocessing.");
      return;
   }

   auto formula{ formula_raw ? formula_raw : parser_->getDynamicTermMeta(main_function_name_, *main_function_params.begin()) };

   formula = removeUneffectiveLinesSafe(formula);
   formula = flattenNestedArrayAccessSafe(formula);
   processVariableArrayAccess(formula);
   processTypesForVariablesInFormula(formula);
   handleGlobalAKAs(formula);
   collectDatatypesInFunction(formula);

   if (!formula_raw) { // "formula" is main function, we're at the end of parsing.
      formula = removeUneffectiveLinesSafe(formula);

      std::vector<std::string> members_recursively = findAllRecursiveVariableNames(false);
      for (const auto& member : members_recursively) {
         fillTypeIntoTAL(member, type_abstraction_layer_);
      }

      applyConstnessToAllMCItems();
      printInfos();
   }
}

void vfm::CppParser::removeUneffectiveLines(const vfm::TermPtr& formula)
{ // TODO: Remove function once general simplifying works.
   addNote("Removing lines of type 'var = var;', 'var;' and '0;' (which can occur during function parsing).");
   StaticHelper::makeAssociative(formula, ";", AssociativityTypeEnum::left);

   formula->applyToMeAndMyChildrenIterative([this](const MathStructPtr m) {
      auto m_var{ m->toVariableIfApplicable() };

      if (m_var) {
         auto m_father{ m->getFatherJumpOverCompound() };

         if (m_father) {
            if (m_father->isTermSequence()) { // "...; var; ...".
               m->removeLineFromSequence();
            }
            else if (m_var->isTermVarOnLeftSideOfAssignment()) { // "...; var = var; ...".
               auto var_right{ m_father->getTermsJumpIntoCompounds()[1]->toVariableIfApplicable() };

               if (var_right && StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName()) == StaticHelper::cleanVarNameOfPossibleRefSymbol(var_right->getVariableName())) {
                  if (m_father->isRootTerm()) {
                     addError("Cannot remove line from sequence in '" + m_father->serializeWithinSurroundingFormula() + "'; it's at the root.");
                  }
                  else {
                     m->getFatherJumpOverCompound()->thisPtrGoUpToCompound()->removeLineFromSequence();
                  }
               }
            }
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   //formula->checkIfAllChildrenHaveConsistentFather();
   //formula->checkCompoundConsistency();

   formula->applyToMeAndMyChildrenIterative([this](const MathStructPtr m) {
      if (m->isValid() && m->isSingleLineIfTypeLimited() && m->isAlwaysFalse()) { // Remove zero ("0;") lines.
         m->removeLineFromSequence();
         m->makeInvalid(true);
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   //addDebug("This is the new formula with removed lines of type 'var = var;', 'var;' and '0;'.");
   //addDebugPlain(formula->serialize());
}

std::string vfm::CppParser::getAKAFromHeap(const MathStructPtr new_var_name_part_fmla)
{
   float address = new_var_name_part_fmla->eval(data_, parser_, false);
   std::string new_var_name_part;

   while (data_->getHeapLocation(address) != 0) {
      new_var_name_part += std::string(1, (char)data_->getHeapLocation(address));
      address++;
   }

   return new_var_name_part;
}

void vfm::CppParser::collectRemainingDatatypesAndScopeVariables(const TermPtr formula)
{
   processInFunctionTalDescriptions(formula);

   if (options_.getFunctionInlineType() != FunctionInlineTypeEnum::Always) {
      postprocessSemanticStuff(formula, ""); // TODO: Remove this line once semantic processing works as last part of parsing process for non-inlined functions as well.
   }

   addNote("Replacing function-scoped variables 'also known as' something else.");
   formula->applyToMeAndMyChildrenIterative([this](const MathStructPtr m) {
      auto m_var{ m->toVariableIfApplicable() };
      if (m_var) {
         const std::string& old_var_name{ m_var->getVariableName() };
         std::string new_var_name{};
         //std::string old_var_name_plain{};

         if (StaticHelper::stringContains(old_var_name, STRING_PREFIX_AKA)) {
            const auto logger{ Failable::getSingleton(FAILABLE_NAME_FOR_AKA_REPLACEMENT) };
            auto list_of_pairs{ StaticHelper::deriveListOfPairsForAkaAnnotatedVarName(old_var_name) };

            for (const auto& pair : list_of_pairs) {
               if (pair.second.empty()) {
                  new_var_name += pair.first;
               }
               else {
                  auto old_var_name_part{ pair.first };
                  auto new_var_name_part_fmla_str{ StaticHelper::fromSafeString(pair.second) };
                  auto new_var_name_part_fmla{ MathStruct::parseMathStruct(new_var_name_part_fmla_str, parser_, data_)->toTermIfApplicable() };
                  //old_var_name_plain += old_var_name_part;

                  std::string new_var_name_part{ getAKAFromHeap(new_var_name_part_fmla) };

                  StaticHelper::preprocessCppConvertCStyleArraysToVars(new_var_name_part);
                  new_var_name += (new_var_name.empty() ? "" : ".") + new_var_name_part;
               }
            }

            if (m->isRootTerm()) {
               logger->addFatalError("Cannot rename variable '" + old_var_name + "' to its aka '" + new_var_name + "' since I'm at the root of the formula.");
            }
            else {
               logger->addNote("Replacing '" + old_var_name + "' with its aka '" + new_var_name + "'.");
               m->replace(_var(new_var_name), true);
               function_aka_from_new_to_old_.insert({ new_var_name, old_var_name });

               // TODO: Delete, not needed.
               //type_abstraction_layer_->addAkaMapping(old_var_name_plain, new_var_name);
            }
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);
}

std::shared_ptr<Term> vfm::CppParser::parseFunctionFromCpp(const std::string& name, const std::string& function)
{
   size_t old_parser_error_count{ parser_->getErrors().size() };

   std::string cpp_prog{ StaticHelper::replaceAllRegex(function, "\\s+static\\s+constexpr\\s+", " constexpr ") };
   cpp_prog = StaticHelper::replaceAllRegex(cpp_prog, "\\s+static\\s+const\\s+", " const "); // TODO: This replaces in strings etc., too.

   addNote("Preprocessing function '" + name + "'.");
   StaticHelper::preprocessCppConvertAllSwitchsToIfs(cpp_prog);
   StaticHelper::preprocessCppConvertElseIfToPlainElse(cpp_prog);
   cpp_prog = FormulaParser::preprocessCPPProgram(cpp_prog);
   cpp_prog = preprocessCppFunctionInlineFunctionsAndConstructors(name, cpp_prog);
   cpp_prog = preprocessCppFunctionComplexDatatypes(name, cpp_prog); // Has to come after preprocessCppFunctionInlineFunctionsAndConstructors.

   auto formula = MathStruct::parseMathStruct(
      cpp_prog, 
      *parser_, 
      false, // Preprocess C++ already done.
      false, // Preprocess C++ already done.
      DEFAULT_REGEX_FOR_TOKENIZER, 
      DEFAULT_IGNORE_CLASS_FOR_TOKENIZER, 
      ignore_tokens_for_functions_,
      data_,
      AkaTalProcessing::do_it)->toTermIfApplicable();

   if (function_definitions_.count(name)) {
      addError("A function named '" + name + "' already exists. I will override it. (Function overloading is not permitted.)");
   }

   function_definitions_[name] = nullptr; // Dummy entry to allow proper postprocessing. Overriden later with correct value.
   addNote("Postprocessing function '" + name + "'.");
   formula = _id(formula);
   collectRemainingDatatypesAndScopeVariables(formula);

   addDebug("This is the processed version of function '" + name + "':");
   addDebugPlain(formula->serialize());

   parser_->postprocessFormulaFromCPP(formula, options_.pointerized_arguments_in_operators_);

   if (parser_->getErrors().size() > old_parser_error_count) {
      addError("Error parsing function '" + name + "':");
      addErrorPlain(cpp_prog);
   }

   function_definitions_[name] = formula->getOperands()[0];
   return formula->getOperands()[0];
}

CppType vfm::CppParser::findType(const std::string& name, const std::vector<std::shared_ptr<CppTypeStruct>> in_types) const
{
   for (const auto& el : in_types) {
      if (el->getName() == name) {
         return el;
      }
   }

   return nullptr;
}

void vfm::CppParser::processTypeForVariableName(const std::string& n)
{
   if (function_aka_from_new_to_old_.count(n)) {
      addDebug("Ignoring type for AKA'd variable '" + n + "' (we'll find it later).");
   }
   else {
      auto t = this->getTypeOf(n);

      if (t) {
         auto c = t->isConst() ? std::vector<std::string>{ "const" } : std::vector<std::string>{};
         this->processTypeForVariableName(n, t, c);
      }
   }
}

void vfm::CppParser::processTypesForVariablesInFormula(const std::shared_ptr<Term> formula)
{
   addNote("Processing types of variables.");

   formula->applyToMeAndMyChildren([this](const std::shared_ptr<MathStruct> m) {
      auto v = m->toVariableIfApplicable();

      if (v) {
         auto n = v->getVariableName();

         processTypeForVariableName(n);
      }
   });
}

bool vfm::CppParser::processTypeForVariableName(const std::string& var_name_raw, const CppType type, const std::vector<std::string>& qualifiers)
{
   std::string var_name = StaticHelper::cleanVarNameOfPossibleRefSymbol(var_name_raw);

   if (!type) {
      addError("Variable '" + var_name + "' has no type.");
      return false;
   }

   if (type->toEnumIfApplicable()) {
      data_->associateVarToEnum(var_name, type->getName());
   }

   if (types_of_variables_.count(var_name)) {
      CppFullTypeWithName t1 = { var_name, types_of_variables_.at(var_name) };
      CppFullTypeWithName t2 = { var_name, { type, qualifiers } };

      if (!typesAreEqual(t1, t2, true)) {
         addError("Variable '" + var_name +  "' has already been declared. Old type: '" + toStringFullType(t1) + "'; new type: '" + toStringFullType(t2) + "'.");
      }
   }
   else {
      insertTypeOfVariable(var_name, { type, qualifiers });
   }

   return true;
}

CppType vfm::CppParser::getTypeOf(const std::string& var_name_raw)
{
   std::string var_name{ StaticHelper::cleanVarNameOfPossibleRefSymbol(var_name_raw) };

   if (types_of_variables_.count(var_name)) {
      return types_of_variables_.at(var_name).first;
   }

   std::string first_name{ StaticHelper::split(var_name, ".")[0] };
   
   if (types_of_variables_.count(first_name)) {
      auto full_type{ types_of_variables_.at(first_name) };
      auto type{ full_type.first->deriveSubTypeFor(var_name, !isLocalVarName(var_name).empty()) };
      insertTypeOfVariable(var_name, { type.first, full_type.second }, true);
      return type.first;
   }

   return nullptr;
}

std::string vfm::CppParser::toStringFullType(const CppFullTypeWithName& type)
{

   std::string s{};

   for (const auto& qualifier : type.second.second) {
      s += qualifier + " ";
   }

   if (type.second.first) {
      s += type.second.first->getName();
   }
   else {
      s += WARNING_COLOR + "<notype>" + RESET_COLOR;
   }

   return s + " " + type.first;
}

bool vfm::CppParser::containsConstQualifier(const CppFullTypeWithName& type, const bool include_paramconst)
{
   return containsConstQualifier(type.second, include_paramconst);
}

bool vfm::CppParser::containsConstQualifier(const CppTypeWithQualifiers& type, const bool include_paramconst)
{
   if (type.first && type.first->isConst()) { // This const comes from const variables in structs or functions.
      return true;
   }

   for (const auto& qual : type.second) { // This const comes from the function signature.
      if (qual == "const" || include_paramconst && qual == "paramconst") {
         return true;
      }
   }

   return false;
}

bool vfm::CppParser::hasCppFunctionSideeffects(const std::string& function_name) const
{
   auto function_code = function_definitions_.at(function_name);
   bool has_sideeffects = false;

   function_code->applyToMeAndMyChildrenIterative([&has_sideeffects, &function_name](const MathStructPtr m) {
      if (m->isTermVarOnLeftSideOfAssignment()) {
         std::string m_var_name = StaticHelper::cleanVarNameOfPossibleRefSymbol(m->toVariableIfApplicable()->getVariableName());
         std::string var_name_2 = "";

         if (m->getFather()->getTermsJumpIntoCompounds()[1]->isTermVar()) {
            var_name_2 = m->getFather()->getTermsJumpIntoCompounds()[1]->toVariableIfApplicable()->getVariableName();
         }

         if (!StaticHelper::stringStartsWith(m_var_name, function_name + ".") // Not a function-local variable.
            && !StaticHelper::stringStartsWith(m_var_name, TEMP_VAR_BASE_NAME)
            && m_var_name != var_name_2) {
            has_sideeffects = true;
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures, has_sideeffects);

   return has_sideeffects;
}

bool vfm::CppParser::functionIsIsolatedOnLine(const std::string& enclosing_function, const int begin_pos_of_internal_function) const
{
   // Assume enclosing_function = "*f*(...)" (for some *f*) at begin_pos_of_internal_function.
   int dummy_pos = begin_pos_of_internal_function;
 
   // Start at internal function f backwards to see if there's something between it and the next "=", ";" or "{", "}".
   auto tokens_before = StaticHelper::tokenize(enclosing_function, *parser_, dummy_pos, 3, true, DEFAULT_REGEX_FOR_TOKENIZER, DEFAULT_IGNORE_CLASS_FOR_TOKENIZER, true, false);

   assert(tokens_before && tokens_before->size() <= 3);

   if (tokens_before->size() >= 2 && tokens_before->back() != "=" && tokens_before->back() != ";" && tokens_before->back() != "{" && tokens_before->back() != "}"
      && tokens_before->at(1) != "=" && tokens_before->at(1) != ";" && tokens_before->at(1) != "{" && tokens_before->at(1) != "}") { // A TAL/AKA info could be dangling before actual ";"
      return false;
   }

   size_t target_pos_after;

   dummy_pos = begin_pos_of_internal_function; // Beginning of the function call in the string - becomes token number of closing bracket later!
   auto tokens_after = findTokensAfterFunctionCall(enclosing_function, dummy_pos);
   return dummy_pos >= tokens_after.size() - 2;
}

std::vector<std::string> vfm::CppParser::findTokensAfterFunctionCall(const std::string& enclosing_function, int& dummy_pos) const
{
   auto tokens_after = StaticHelper::tokenize( // Go in forward direction to check the same for what comes after f.
      enclosing_function, *parser_, dummy_pos, std::numeric_limits<int>::max(), false, DEFAULT_REGEX_FOR_TOKENIZER, DEFAULT_IGNORE_CLASS_FOR_TOKENIZER, true, false, AkaTalProcessing::none, {}, false, [](const std::vector<std::string> tokens_so_far) {
      return !tokens_so_far.empty() && (tokens_so_far.back() == ";" || tokens_so_far.back() == "}");
   });

   int count = -1;
   dummy_pos = -1;
   for (int i = 2; i < tokens_after->size(); i++) { // Assume first token after *f* (i = 1) is "(", so start at i = 2.
      const auto& token = tokens_after->at(i);

      if (token == OPENING_BRACKET_STR) {
         count--;
      }
      else if (token == CLOSING_BRACKET_STR) {
         count++;
      }

      if (count == 0) {
         dummy_pos = i;
         break;
      }
   }

   return *tokens_after;
}

std::string vfm::CppParser::findSurroundingNamespace(const std::string code, const int pos)
{
   for (int i = pos; i >= 0; i--) {
      std::string namespace_name;

      if (code[i] == '}') {
         i = StaticHelper::findMatchingBegTagLevelwise(code, "{", "}", i, { "\"" }, { "\"" });
         continue;
      }

      if (code[i] == '{') {
         int dummy = i;
         auto tokens = StaticHelper::tokenize(
            code,
            *SingletonFormulaParser::getLightInstance(),
            dummy,
            4,
            true,
            DEFAULT_REGEX_FOR_TOKENIZER,
            DEFAULT_IGNORE_CLASS_FOR_TOKENIZER,
            false);

         for (int i = 0; i < tokens->size(); i++) {
            if (tokens->at(i) == "namespace") {
               namespace_name = tokens->at(i - 1) + "::";
            }
         }
      }

      if (!namespace_name.empty()) {
         return findSurroundingNamespace(code, i - 1) + namespace_name;
      }
   }

   return "";
}

std::shared_ptr<vfm::mc::TypeAbstractionLayer> vfm::CppParser::prepareVariablesForPrematureTal() const
{
   std::shared_ptr<vfm::mc::TypeAbstractionLayer> tal{ type_abstraction_layer_->copy() };

   for (const auto& var_name : findAllRecursiveVariableNames(true)) {
      fillTypeIntoTAL(var_name, tal);
   }

   return type_abstraction_layer_;
}

std::pair<float, float> vfm::CppParser::getSingleRange(const MathStructPtr m_raw, const std::pair<float, float>& range1, const std::pair<float, float>& range2) const
{
   auto m = m_raw->copy();
   m = MathStruct::flattenFormula(m->toTermIfApplicable());

   float min = 1; // Invalid inital values that make the relational operators simpler.
   float max = 0;

   const float lbx = range1.first; // Using Christian's nomenclature to avoid (even more) confusion.
   const float ubx = range1.second;
   const float lby = range2.first;
   const float uby = range2.second;

   const bool zero_in_range1 = lbx <= 0 && ubx >= 0;
   const bool zero_in_range2 = lby <= 0 && uby >= 0;
   const bool non_zero_possible_in_range1 = lbx != 0 || ubx != 0;
   const bool non_zero_possible_in_range2 = lby != 0 || uby != 0;
   const bool only_zero_possible_in_range1 = !non_zero_possible_in_range1;
   const bool only_zero_possible_in_range2 = !non_zero_possible_in_range2;
   const bool ranges_intersect = ubx >= lby && uby >= lbx;
   const bool ranges_are_point = lbx == ubx && ubx == lby && lby == uby;

   auto minMaxForBool = [](const bool condition_for_only_1, const bool condition_for_only_0, float& min, float& max) {
      if (!condition_for_only_1) min = 0;
      if (!condition_for_only_0) max = 1;
      assert(min <= max);
   };

   auto checkOptor = [&m](const std::string& optor) { // A bit over-simplified, but captures std::max = max, vfc::equal = != etc.
      return m->getOptor() == optor || m->isTermCompound() && m->toTermCompoundIfApplicable()->getCompoundStructure()->getOptor() == optor;
   }; // TODO: Decide for EITHER flattening OR this method, currently this method has no effect, but flattening might be too expensive.

   if (checkOptor(SYMB_PLUS)) {
      min = lbx + lby;
      max = ubx + uby;
   }
   else if (checkOptor(SYMB_MINUS)) {
      min = lbx - uby;
      max = ubx - lby;
   }
   else if (checkOptor(SYMB_MULT)) {
      if (lbx >= 0) {
         if (ubx >= 0 && lby >= 0 && uby >= 0) {
            min = lbx * lby;
            max = ubx * uby;
         }
         else if (ubx >= 0 && lby < 0 && uby >= 0) {
            min = ubx * lby;
            max = ubx * uby;
         }
         else { // ubx >= 0 && lby < 0 && uby < 0
            min = ubx * lby;
            max = lbx * uby;
         }
      }
      else { // lbx < 0
         if (ubx >= 0 && lby >= 0 && uby >= 0) {
            min = lbx * uby;
            max = ubx * uby;
         }
         else if (ubx >= 0 && lby < 0 && uby >= 0) {
            min = std::min(lbx * uby, ubx * lby);
            max = ubx * uby;
         }
         else if (ubx >= 0 && lby < 0 && uby < 0) {
            min = ubx * lby;
            max = lbx * lby;
         }
         else if (ubx < 0 && lby >= 0 && uby >= 0) {
            min = lbx * uby;
            max = ubx * lby;
         }
         else if (ubx < 0 && lby < 0 && uby >= 0) {
            min = lbx * uby;
            max = lbx * lby;
         }
         else { // ubx < 0 && lby < 0 && uby < 0
            min = ubx * uby;
            max = lbx * lby;
         }
      }
   }
   else if (checkOptor(SYMB_DIV)) { // Note that floor and ceil are applied when returning the values. TODO @ Christian: Treatment of 0 in denominator not clear.
      float lby_safe = lby != 0 ? lby : 1;
      float uby_safe = uby != 0 ? uby : -1;

      if (lby_safe == 0) {
         addError("Range extension failed for operator '" + SYMB_DIV + "' due to division by value '" + std::to_string(lby_safe) + "'.");
      }

      if (lbx >= 0) {
         if (ubx >= 0 && lby >= 0 && uby >= 0) {
            min = lbx / uby_safe;
            max = ubx / lby_safe;
         }
         else if (ubx >= 0 && lby < 0 && uby >= 0) {
            min = ubx / -1;
            max = ubx / 1;
         }
         else { // ubx >= 0 && lby < 0 && uby < 0
            min = ubx / uby_safe;
            max = lbx / lby_safe;
         }
      }
      else { // lbx < 0
         if (ubx >= 0 && lby >= 0 && uby >= 0) {
            min = lbx / lby_safe;
            max = ubx / lby_safe;
         }
         else if (ubx >= 0 && lby < 0 && uby >= 0) {
            min = ubx / -1;
            max = ubx / +1;
         }
         else if (ubx >= 0 && lby < 0 && uby < 0) {
            min = ubx / uby_safe;
            max = lbx / uby_safe;
         }
         else if (ubx < 0 && lby >= 0 && uby >= 0) {
            min = lbx / lby_safe;
            max = ubx / lby_safe;
         }
         else if (ubx < 0 && lby < 0 && uby >= 0) {
            min = lbx / +1;
            max = lbx / -1;
         }
         else { // ubx < 0 && lby < 0 && uby < 0
            min = ubx / lby_safe;
            max = lbx / uby_safe;
         }
      }
   }
   else if (checkOptor(SYMB_ABS)) {
      if (lbx < 0 && ubx >= 0) {
         min = 0;
      }
      else {
         min = std::min(std::abs(lbx), std::abs(ubx));
      }

      max = std::max(std::abs(lbx), std::abs(ubx));
   }
   else if (checkOptor(SYMB_MIN)) {
      min = std::min(lbx, lby);
      max = std::min(ubx, uby);
   }
   else if (checkOptor(SYMB_MAX)) {
      min = std::max(lbx, lby);
      max = std::max(ubx, uby);
   }
   else if (checkOptor(SYMB_MOD)) {
      if (lbx < 0) {
         min = std::max(-1 * (std::max(std::abs(lby), std::abs(uby)) - 1), lbx);
      }
      else {
         min = 0;
      }

      if (ubx < 0) {
         max = 0;
      }
      else {
         max = std::min(std::max(std::abs(lby), std::abs(uby)) - 1, ubx);
      }
   }
   else if (checkOptor(SYMB_NEG)) { // TODO @ Christian: Please check, is that correct?
      min = -ubx;
      max = -lbx;
   }
   // All below can only be { 0, 1 }, but they can be even more limited in some cases.
   else if (checkOptor(SYMB_AND)) { // R (x && y) can be just 1 if no range includes 0, just 0 if any range is (0, 0).
      minMaxForBool(
         !zero_in_range1 && !zero_in_range2,                           // Only 1
         only_zero_possible_in_range1 || only_zero_possible_in_range2, // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_OR)) { // R (x || y) can be just 0 if ub(x) = lb(x) = ub(y) = lb(y) = 0, just 1 if any range excludes 0.
      minMaxForBool(
         !zero_in_range1 || !zero_in_range2, // Only 1
         ranges_are_point && lbx == 0,       // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_EQ)) { // R (x == y) can be limited to just 0 if the ranges don't intersect or just 1 if ub(x) = lb(x) = ub(y) = lb(y).
      minMaxForBool(
         ranges_are_point,  // Only 1
         !ranges_intersect, // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_GR)) { // R(x > y) must be 1 if lb(x) > ub(y), must be 0 if lb(y) >= ub(x)
      const bool x_is_gr_y = lbx > uby;
      const bool x_is_smeq_y = lby >= ubx;

      minMaxForBool(
         x_is_gr_y,   // Only 1
         x_is_smeq_y, // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_GREQ)) { // R(x >= y) must be 1 if lb(x) >= ub(y), must be 0 if lb(y) > ub(x)
      const bool x_is_greq_y = lbx >= uby;
      const bool x_is_sm_y = lby > ubx;

      minMaxForBool(
         x_is_greq_y, // Only 1
         x_is_sm_y,   // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_SM)) { // R(x < y) must be 1 if ub(x) < lb(y), must be 0 if ub(y) <= lb(x)
      const bool x_is_sm_y = ubx < lby;
      const bool x_is_greq_y = uby <= lbx;

      minMaxForBool(
         x_is_sm_y,   // Only 1
         x_is_greq_y, // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_SMEQ)) { // R(x <= y) must be 1 if ub(x) <= lb(y), must be 0 if ub(y) < lb(x)
      const bool x_is_smeq_y = ubx <= lby;
      const bool x_is_gr_y = uby < lbx;

      minMaxForBool(
         x_is_smeq_y, // Only 1
         x_is_gr_y,   // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_NEQ)) { // R(x != y) can be limited to just 1 if the ranges don't intersect or just 0 if ub(x) = lb(x) = ub(y) = lb(y).
      minMaxForBool(
         !ranges_intersect, // Only 1
         ranges_are_point,  // Only 0
         min, max);
   }
   else if (checkOptor(SYMB_NOT)) { // R(!(x)) can be limited to just 0 (0 not in range of x) or just 1 (lb(x) = ub(x) = 0).
      minMaxForBool(
         only_zero_possible_in_range1, // Only 1
         !zero_in_range1,              // Only 0
         min, max);
   }
   else {
      addError("Operator '" + m->getOptor() + "' not covered for range extraction.");
   }

   // TODO: Should we do floor/ceil or just leave the float ranges?
   //return { std::floor(min), std::ceil(max) }; // floor and ceil make a difference only for division.

   return { min, max };
}

std::pair<float, float> vfm::CppParser::deriveGlobalRangeFromLeafRanges(const MathStructPtr m) const
{
   std::map<MathStructPtr, std::pair<float, float>> ranges{};
   auto tal = prepareVariablesForPrematureTal()->copy();

   m->applyToMeAndMyChildrenIterative([this, &ranges, &tal](const MathStructPtr m) {
      if (m->isTermVal()) {
         ranges[m] = { m->constEval(), m->constEval() };
         addDebug("Range of constant value '" + m->serializeWithinSurroundingFormula(50, 50) + "' is (" + std::to_string(ranges[m].first) + ".." + std::to_string(ranges[m].second) + ").");
      }
      else if (m->isTermVar()) {
         auto m_var = m->toVariableIfApplicable();
         auto m_var_name = StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName());

         ranges[m] = type_abstraction_layer_->getRange(m_var_name);
         addDebug("Range of variable '" + m->serializeWithinSurroundingFormula(50, 50) + "' is (" + std::to_string(ranges[m].first) + ".." + std::to_string(ranges[m].second) + ").");
      }
      else if (m->getTermsJumpIntoCompounds().size() == 1) {
         ranges[m] = getSingleRange(m, ranges.at(m->getTermsJumpIntoCompounds()[0]), { 0, 0 });
         addDebug("Range of one-operand operator '" + m->serializeWithinSurroundingFormula(50, 50) + "' is (" + std::to_string(ranges[m].first) + ".." + std::to_string(ranges[m].second) + ").");
      }
      else if (m->getTermsJumpIntoCompounds().size() == 2) {
         ranges[m] = getSingleRange(m, ranges.at(m->getTermsJumpIntoCompounds()[0]), ranges.at(m->getTermsJumpIntoCompounds()[1]));
         addDebug("Range of two-operand operator '" + m->serializeWithinSurroundingFormula(50, 50) + "' is (" + std::to_string(ranges[m].first) + ".." + std::to_string(ranges[m].second) + ").");
      } else {
         addError("Operator '" + m->getOptor() + "' has " + std::to_string(m->getTermsJumpIntoCompounds().size()) + ">2 operands which is not covered for range extraction.");
      }

      if (ranges.count(m)) {
         addDebug("Inferred range (" + std::to_string(ranges[m].first) + ".." + std::to_string(ranges[m].second) + ") for '" + m->serializeWithinSurroundingFormula(50, 50) + "'.");
      }

   }, TraverseCompoundsType::avoid_compound_structures, FormulaTraversalType::PostOrder);

   return ranges.at(m);
}

bool vfm::CppParser::checkForVariablesWithoutType(const MathStructPtr formula) const
{
   bool error_free = true;

   formula->applyToMeAndMyChildrenIterative([this, &error_free](const MathStructPtr m) {
      auto m_var = m->toVariableIfApplicable();

      if (m_var) {
         auto m_var_name_plain = StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName());
         auto pairs = StaticHelper::deriveListOfPairsForAkaAnnotatedVarName(m_var_name_plain);
         auto m_var_name = pairs.empty() ? m_var_name_plain : pairs[0].first;

         if (!types_of_variables_.count(m_var_name)) {
            addError("No type found for variable '" + m_var_name + "' in checkForVariablesWithoutType.");
            error_free = false;
         }
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   return error_free;
}

std::map<std::string, std::string> vfm::CppParser::collectEnumsForKratos() const
{
   std::map<std::string, std::string> res;

   for (const auto& type : data_types_) {
      auto enum_type = type->toEnumIfApplicable();

      if (enum_type) {
         std::string values_str;

         for (const auto& value : enum_type->getPossibleValues()) {
            values_str += " |" + enum_type->getName() + "____" + value.second + "|";
         }

         for (const auto& value : enum_type->getPossibleValues()) {
            res.insert({ enum_type->getName() + "::" + value.second, values_str });
         }
      }
   }

   return res;
}

std::string vfm::CppParser::generateGraphvizWithTypes(const MathStructPtr m) const
{
   auto m_copy{ m->copy() };
   auto tal{ prepareVariablesForPrematureTal()->copy() };

   m_copy->applyToMeAndMyChildrenIterative([this, tal](const MathStructPtr m) {
      static const std::string NO_TYPE_DENOTER{ "<notype>" };

      auto m_var = m->toVariableIfApplicable();

      if (m_var) {
         auto m_var_name_plain = StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName());
         auto pairs = StaticHelper::deriveListOfPairsForAkaAnnotatedVarName(m_var_name_plain);
         auto m_var_name = pairs.empty() ? m_var_name_plain : pairs[0].first;
         auto cpp_type = types_of_variables_.count(m_var_name) ? types_of_variables_.at(m_var_name).first : nullptr;
         auto str_type = cpp_type ? cpp_type->getName() : NO_TYPE_DENOTER;

         if (str_type == NO_TYPE_DENOTER) {
            addError("No type found for variable '" + m_var_name + "' during graphviz-with-types generation.");
         }

         fillTypeIntoTAL(m_var_name, tal);

         if (tal->getVariablesWithTypes().count(m_var_name)) {
            auto values = mc::TypeAbstractionLayer::getMCValues(tal->getVariablesWithTypes().at(m_var_name).first);

            if (values.size() > 4) {
               values = { values[0], values[1], "...", values[values.size() - 2], values[values.size() - 1] };
            }

            str_type += "\\n(" + StaticHelper::tokensAsString(values, true, ", ") + ")";
         }

         m_var->setVariableName(m_var_name + " : " + str_type);
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   return m_copy->generateGraphviz(0, false);
}

std::string deriveEnvModelFileName(const std::string& base_name, const std::vector<std::string>& options, const DataPack& data)
{
   std::string generated_name{ base_name };

   static constexpr bool GENERATE_DETAILED_FILENAME{ false };

   if (GENERATE_DETAILED_FILENAME) {
      for (const auto& option : options) {
         auto varval = StaticHelper::split(StaticHelper::removeWhiteSpace(option), NATIVE_SMV_ENV_MODEL_ASSIGNMENT);

         if (varval.size() != 2) {
            continue;
         }

         auto var = varval.at(0);
         auto val = varval.at(1);

         if (val == "true") {
            generated_name += "_1" + StaticHelper::toUpperCase(var);
         }
         else if (val == "false") {
            generated_name += "_0" + StaticHelper::toLowerCase(var);
         }
         else if (!StaticHelper::stringContains(val, ".")) {
            generated_name += "_" + val + var;
         }
         else {
            generated_name += "_" + var + "=" + std::to_string(data.getSingleVal(var));
         }
      }
   }

   generated_name = generated_name + ".smv";

   return generated_name;
}

std::vector<std::string> vfm::CppParser::processTemplateOptions(const std::string& template_file_path)
{
   auto split = StaticHelper::split(template_file_path, NATIVE_SMV_ENV_MODEL_DENOTER_CLOSE);
   auto options_raw{ StaticHelper::removeWhiteSpace(
   StaticHelper::replaceAll(split.at(0), NATIVE_SMV_ENV_MODEL_DENOTER_OPEN, "")) };
   addNote("Processing template options '" + options_raw + "'.");

   auto options{ StaticHelper::split(
      options_raw,
      NATIVE_SMV_ENV_MODEL_SEPARATOR) };

   for (const auto& option : options) {
      if (option == NATIVE_SMV_ENV_MODEL_DENOTER_ALWAYS_REGENERATE) { // Only allowed option without "= value".
         //use_cached = false;
      }
      else {
         auto varval = StaticHelper::split(option, NATIVE_SMV_ENV_MODEL_ASSIGNMENT);
         if (varval.size() != 2) {
            addError("Malformed option for env model generation: '" + option + "'.");
         }

         auto var = varval.at(0);
         auto val = varval.at(1);

         if (data_->isDeclared(var)) {
            addError("Variable '" + var + "' in template option '" + option + "' already in use with value '" + std::to_string(data_->getSingleVal(var)) + "'.");
         }

         if (StaticHelper::isParsableAsFloat(val)) {
            data_->addOrSetSingleVal(var, std::stof(val));
         }
         else if (StaticHelper::stringStartsWith(val, STRING_PREFIX_ENVMODEL_GEN)) {
            std::string decrypted{ StaticHelper::fromSafeString(val.substr(STRING_PREFIX_ENVMODEL_GEN.size())) };

            // Add to constraints, any.
            bool invarspec{ StaticHelper::stringStartsWith(decrypted, "INVARSPEC") };
            bool ltlspec{ StaticHelper::stringStartsWith(decrypted, "LTLSPEC") };
            bool ctlspec{ StaticHelper::stringStartsWith(decrypted, "CTLSPEC") };

            std::string spec{ StaticHelper::replaceAll(StaticHelper::replaceAll(StaticHelper::replaceAll(decrypted, "LTLSPEC", ""), "CTLSPEC", ""), "INVARSPEC", "") };
            spec = StaticHelper::trimAndReturn(spec);

            if (invarspec) { // TODO!
               //addConstraint(spec, getInvariants());
            }
            else if (ltlspec) {
               is_ltl_mode_ = true;
               //addConstraint(spec, mc_specs_.first);
            }
            else if (ctlspec) {
               //addConstraint(spec, mc_specs_.second);
            }

            data_->addStringToDataPack(decrypted, var);
         }
         else {
            if (!data_->isDeclared(val)) {
               addError("Value '" + val + "' used as variable in template option '" + option + "' is undeclared.");
            }

            data_->addOrSetSingleVal(var, data_->getSingleVal(val));
         }

         addDebug("Template variable '" + var + "' has now value '" + std::to_string(data_->getSingleVal(var)) + "' in data pack.");
      }
   }

   return options;
}

std::string getFileNameWithPath(const std::string& template_file_path)
{
   auto split{ StaticHelper::split(template_file_path, NATIVE_SMV_ENV_MODEL_DENOTER_CLOSE) };

   if (split.size() != 2) {
      Failable::getSingleton()->addError("Malformed template file description for env model generation: '" + template_file_path + "'.");
   }

   return split.at(1);
}

std::string vfm::CppParser::getFullPathToStoreCachedVersionIn(
   std::string& generated_name,
   const std::string& template_file_path,
   const std::string& generated_filepath,
   const std::vector<std::string>& template_options
) const
{
   std::string env_model_generated_path = StaticHelper::removeLastFileExtension(generated_filepath, "/");
   std::string template_name{ StaticHelper::getFileNameFromPath(getFileNameWithPath(template_file_path)) };
   generated_name = deriveEnvModelFileName(StaticHelper::removeLastFileExtension(template_name), template_options, *data_);
   std::string full_path_to_store_cached_version_in = env_model_generated_path + "/" + generated_name;

   return full_path_to_store_cached_version_in;
}

std::string vfm::CppParser::generateScript(const std::string& script_content, const std::shared_ptr<DataPack> data, const std::shared_ptr<FormulaParser> parser)
{
   auto em_script = std::make_shared<vfm::mc::EnvModel>(data, parser);
   //addFailableChild(em_script); // TODO
   em_script->setTemplate(script_content);
   std::string script_processed{ em_script->generateEnvModel(em_script) };
   return script_processed;
}

std::string vfm::CppParser::generateEnvModel(
   const std::string& template_file_path, 
   const std::string& generated_filepath,
   const std::vector<std::string>& template_options)
{
   std::string env_model_generated_path{ StaticHelper::removeLastFileExtension(generated_filepath, "/") };

   std::string file_name_with_path{ getFileNameWithPath(template_file_path) };
   std::string pure_path{ StaticHelper::removeFileNameFromPath(file_name_with_path) };

   std::string templates_generated_path{ env_model_generated_path + "/templates_archive/"};
   addNote("Copying templates directory '" + pure_path + "' to generated location ('" + templates_generated_path + "').");
   std::filesystem::copy(pure_path, templates_generated_path, std::filesystem::copy_options::overwrite_existing);

   if (!std::filesystem::exists(file_name_with_path)) {
      addError("EnvModel template file '" + file_name_with_path + "' not found.");
   }

   std::string generated_name{};
   std::string full_path_to_store_cached_version_in{ getFullPathToStoreCachedVersionIn(generated_name, template_file_path, generated_filepath, template_options) };
   //auto options = processTemplateOptions(template_file_path); // This is done on the top level now.

   if (true /*!use_cached || !std::filesystem::exists(full_path_to_store_cached_version_in)*/) {
      addNote("Generating from template '" + file_name_with_path + "' in '" + full_path_to_store_cached_version_in + "'.");

      auto em = std::make_shared<vfm::mc::EnvModel>(data_, parser_);
      data_->addStringToDataPack(StaticHelper::removeLastFileExtension(file_name_with_path, "/"), macro::MY_PATH_VARNAME); // Set MY_PATH variable relative to which file operations are performed in the generator.
      addFailableChild(em);
      em->loadFromFile(file_name_with_path);
      std::string processed{ em->generateEnvModel(em) };
      addNote("Writing temp version on EnvModel into '" + full_path_to_store_cached_version_in + "'.");
      StaticHelper::writeTextToFile(processed, full_path_to_store_cached_version_in);
   }
   else {
      addNote("Using cached EnvModel from '" + full_path_to_store_cached_version_in + "'.");
   }
   
   writeMortyGUIProgressFile(15, "topology generator");
   dumpCurrentState(env_model_generated_path + "/dump1_after_envmodel_generation.log");

   std::string target_generated_envmodel_name{ StaticHelper::removeLastFileExtension(generated_filepath, "/") + "/" + generated_name};

   std::string script_filename{ "script.tpl" };
   std::string script_target_filename{ StaticHelper::removeLastFileExtension(script_filename) + ".cmd" };
   std::string source_script_name{ StaticHelper::removeLastFileExtension(file_name_with_path, "/") + "/" + script_filename };
   std::string target_generated_script_name{ StaticHelper::removeLastFileExtension(generated_filepath, "/") + "/" + script_target_filename };

   // TODO: This copy is currently not neccessary, however, it might make sense to store the cached version somewhere else than the actual used version.
   addNote("Copying EnvModel into '" + target_generated_envmodel_name + "'.");
   StaticHelper::writeTextToFile(StaticHelper::readFile(full_path_to_store_cached_version_in), target_generated_envmodel_name);

   addNote("Copying '" + source_script_name + "' into '" + target_generated_script_name + "'.");

   std::string script_content{ StaticHelper::readFile(source_script_name) };

   auto script_processed = generateScript(script_content, data_, parser_);

   StaticHelper::writeTextToFile(script_processed, target_generated_script_name);

   return full_path_to_store_cached_version_in;
}

bool vfm::CppParser::performFSMCodeGenerationWrapper(
   const char* path_to_file_list_file, 
   const char* target_path_for_generated_code, 
   const bool create_live_pdf,
   std::string& path_to_envmodel_file,
   const std::vector<std::string>& template_options,
   const bool env_model_info_available)
{
   addNote("Code generation started.");

   std::string path_to_file_list_file_string{ path_to_file_list_file };
   std::string generated_env_model_file{};
   use_or_generate_native_smv_env_model_ = use_or_generate_native_smv_env_model_ || StaticHelper::stringStartsWith(path_to_file_list_file_string, NATIVE_SMV_ENV_MODEL_DENOTER_OPEN);
   in_envmodel_mode_ = !env_model_info_available;
   reset(data_, env_model_info_available);
   applySMVOperatorsToParser(); // Regardless of using actually native env model.

   if (isCurrentlyDoingNativeEnvModelGeneration()) {
      addNote("Generation of native SMV environment model activated.");

      smv_module_ = std::make_shared<mc::smv::Module>();
      addFailableChild(smv_module_);

      generated_env_model_file = generateEnvModel(path_to_file_list_file_string, target_path_for_generated_code, template_options);
      path_to_envmodel_file = generated_env_model_file;
   }

   const std::string path_to_file_list_file_str = std::string(path_to_file_list_file);
   const std::string target_path_for_generated_code_str = std::string(target_path_for_generated_code);
   const auto vec{ isCurrentlyDoingNativeEnvModelGeneration() ? std::vector<std::string>{} : readFileListFromFile(path_to_file_list_file_str)};

   std::string main_file_name_str{};

   if (isCurrentlyDoingNativeEnvModelGeneration()) {
      addNote("Searching for main FSM file in files listed in '" + path_to_file_list_file_str + "'.");
   }

   for (const auto& el : vec) {
      addDebug("Looking in '" + StaticHelper::absPath(el) + "'.");
      std::ifstream input(el);

      if (input.good()) {
         std::stringstream sstr{};
         while (input >> sstr.rdbuf());

         if (StaticHelper::stringContains(sstr.str(), VFM_GENCODE_DENOTER_BEGIN) 
            && StaticHelper::stringContains(sstr.str(), VFM_GENCODE_DENOTER_END)) {

            if (main_file_name_str.empty()) {
               main_file_name_str = el;
            }
            else {
               addError("Found gencode tags in more than one file: '" + StaticHelper::absPath(main_file_name_str) + "' and '" + StaticHelper::absPath(el) + "'.");
            }
         }
      }
      else {
         addError("File '" + StaticHelper::absPath(el) + "' could not be read. The bits [good|eof|fail|bad] are [" 
            + std::to_string(input.good()) 
            + std::to_string(input.eof()) 
            + std::to_string(input.fail()) 
            + std::to_string(input.bad()) 
            + "].");
      }

      input.close();
   }

   std::string target_path_for_vfm_code = target_path_for_generated_code_str + ".vfm";
   std::string target_path_for_dot_code = target_path_for_generated_code_str;

   if (isCurrentlyDoingNativeEnvModelGeneration()) {
      parseProgramByLoadingFileListFromFile(generated_env_model_file);

      std::filesystem::path varpath{ target_path_for_generated_code_str };
      varpath = varpath.parent_path();
      varpath /= "envmodel-variables.txt";

      addNote("Storing all EnvModel variable names in file '" + StaticHelper::absPath(varpath.string()) + "'.");
      std::string allvars{};
      for (const auto& var : smv_module_->getAllVariablesAndDefinesForOutsideUsage()) {
         allvars += var + "\n";
      }
      StaticHelper::writeTextToFile(allvars, varpath.string());

      //auto fsm = fsm_;
      //addNote("Storing vfm FSM code in '" + StaticHelper::absPath(target_path_for_vfm_code) + "'.");
      //fsm->storeToFile(target_path_for_vfm_code);
      //createFSMOutput(*fsm, target_path_for_dot_code, { GraphvizOutputSelector::data_only, GraphvizOutputSelector::functions_only, GraphvizOutputSelector::graph_only }, { "pdf" });
   }
   else if (main_file_name_str.empty()) {
      addError("No consistent pair of '" + VFM_GENCODE_DENOTER_BEGIN + "' / '" + VFM_GENCODE_DENOTER_END + "' tags found in any of the parsed files. Aborting.");
   }
   else {
      addNote("Found gencode tags in '" + StaticHelper::absPath(main_file_name_str) + "'.");
      addNote("Generated file will be created as '" + target_path_for_generated_code_str + "'.");

      parseProgramByLoadingFileListFromFile(path_to_file_list_file);

      //auto fsm = fsm_;

      //if (env_model_info_available) {
      //   fsm = fsm_->copyToPtr();
      //   addFailableChild(fsm);
      //}

      //fsm->encapsulateLongConditionsIntoFunctions(150);
      //fsm->encapsulateLongCallbacksIntoFunctions(40);

      //replaceCodeWithGenCode(main_file_name_str, target_path_for_generated_code_str, target_path_for_dot_code, create_live_pdf);

      //if (!options_.isGatekeeper()) {
      //   addNote("Storing vfm FSM code in '" + StaticHelper::absPath(target_path_for_vfm_code) + "'.");
      //   fsm->storeToFile(target_path_for_vfm_code);

      //   // Create one-time pdf, not affected by live_pdf.      }
      //   createFSMOutput(*fsm, target_path_for_dot_code, { GraphvizOutputSelector::data_only, GraphvizOutputSelector::functions_only, GraphvizOutputSelector::graph_only }, { "pdf" });
      //}
      //else {
      //   addNote("Skipping creation of individual result files due to gatekeeper mode.");
      //}
   }

   if (hasErrorOccurred()) {
      addError("Code generation " + FAILED_COLOR + "FAILED" + RESET_COLOR + ".");
      return false;
   }
   else {
      addNote("Code generation " + OK_COLOR + "SUCCEEDED" + RESET_COLOR + ".");
      return true;
   }
}

void createTitleString(Failable* this_parser, const std::string& topic) {
   std::string note_string = "*** Creating FSM for '" + topic + "' ***";
   std::string lotsofstars;

   for (int i = 0; i < note_string.size(); i++) {
      lotsofstars += "*";
   }

   this_parser->addNotePlain(BOLD_COLOR + "\n" + lotsofstars);
   this_parser->addNotePlain(note_string);
   this_parser->addNotePlain(lotsofstars + RESET_COLOR);
};

void CppParser::addStateVariablesToTAL(fsm::FSMs& fsm)
{
   std::string current_state_var_name = StaticHelper::makeVarNameNuSMVReady(fsm.getCurrentStateVarName());
   auto state_names = std::make_shared<std::map<float, std::string>>();

   for (const auto id : fsm.getStatesPlainSet()) {
      state_names->insert({ id, fsm.getStateVarName(id, false) });
   }

   auto cpp_type = std::make_shared<CppTypeEnum>(NAME_OF_BASE_ENUM_FOR_STATES, state_names);
   processTypeForVariableName(current_state_var_name, cpp_type, {});
   addPlainEnumVariable(NAME_OF_BASE_ENUM_FOR_STATES, state_names);
   fillTypeIntoTAL(current_state_var_name, type_abstraction_layer_);

   addNote("Added state variable '" + current_state_var_name + "' with enum type '" + type_abstraction_layer_->get(current_state_var_name).first.cpp_type_->toString() + "' to TAL.");
}

VariablesWithKinds CppParser::kreateKratosFilesAndCheckFormula(const std::string& target_path_for_generated_code) const
{
   const std::string kratos_file{ target_path_for_generated_code };
   const std::string graphviz_with_types_file{ std::string(target_path_for_generated_code) + "_combined.graphviz_with_types.dot" };

   TermPtr full_formula{ function_definitions_.at(main_function_name_) };

   addNote("Making final formula left-associative.");
   full_formula = StaticHelper::makeAssociative(full_formula, ";", AssociativityTypeEnum::left);

   if (use_or_generate_native_smv_env_model_) {
      addNote("Flattening final formula.");
      full_formula = MathStruct::flattenFormula(full_formula);
   }

   if (options_.getCreateAdditionalDebugFiles().getEnumAsString() == VFM_OPTION_CREATE_ADDITIONAL_FILES_ALL) {
      addNote("Checking types in final formula and creating graphviz tree with types for debugging in '" + graphviz_with_types_file
         + "' (option '" + VFM_OPTION_CREATE_ADDITIONAL_FILES + "' = '" + options_.getCreateAdditionalDebugFiles().getEnumAsString() + "').");
      StaticHelper::createImageFromGraphvizDot(generateGraphvizWithTypes(full_formula), graphviz_with_types_file);
   }
   else {
      addNote("Checking types in final formula. Omitting tree with types creation (option '" + VFM_OPTION_CREATE_ADDITIONAL_FILES + "' = '" + options_.getCreateAdditionalDebugFiles().getEnumAsString() + "').");
      checkForVariablesWithoutType(full_formula);
   }

   addNote("Kreating Kratos code and vfm code.");
   VariablesWithKinds fsm_controlled_out{};
   std::string kratos_code{ serializeKratos(
      full_formula,
      main_function_name_,
      collectEnumsForKratos(),
      variables_ordering_,
      IGNORE_THESE,
      true, // Backwards compatibility towards 1st and 2nd workflow abandoned, therefore always assume no-C++ EM.
      getAllVariablesExceptImmutableEnumAndBoolTypes(),
      fsm_controlled_out) };

   addNote("Storing Kratos code in '" + kratos_file + "'.");
   std::ofstream outKratos{ kratos_file };
   outKratos << kratos_code;
   outKratos.close();

   std::string vfm_code = full_formula->serialize();

   std::string vfm_file{ StaticHelper::replaceAll(kratos_file, "k2", "vfm") };
   addNote("Storing vfm code in '" + vfm_file + "'.");
   std::ofstream outVfm{ vfm_file };
   outVfm << vfm_code;
   outVfm.close();

   std::filesystem::path varpath{ target_path_for_generated_code };
   varpath = varpath.parent_path();
   varpath /= "planner-variables.txt";

   addNote("Storing all Planner variable names in file '" + StaticHelper::absPath(varpath.string()) + "'.");
   std::set<std::string> allvars{};
   full_formula->applyToMeAndMyChildren([&allvars](const MathStructPtr m) {
      auto m_var = m->toVariableIfApplicable();

      if (m_var) {
         allvars.insert(StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName()));
      }
   });
   std::string allvars_str{};

   for (const auto& var : allvars) allvars_str += var + "\n";
   StaticHelper::writeTextToFile(allvars_str, varpath.string());

   const std::vector<std::pair<std::string, std::string>> replacements
   {
      { "\n", "\n\\l" },
      { " ", "\\ " },
      { "{", "\\{" },
      { "}", "\\}" },
      { ">", "\\>" },
      { "<", "\\<" },
      { "@", "" },
      { "|", "\\|" },
      { "&", "\\&" }
   };

   static const int MAX_LABEL_SIZE = 1000000;

   std::string kratos_code_file{ kratos_file + ".dot" };
   std::string vfm_code_file{ StaticHelper::replaceAll(kratos_code_file, ".k2", ".vfm") };

   addNote("Kreating Kratos PDF code in '" + kratos_code_file + "'.");
   StaticHelper::createImageFromGraphvizDot(
      std::string("digraph G {\n")
      + "r [shape=record label=\"" + StaticHelper::shortenToMaxSize(StaticHelper::replaceManyTimes(kratos_code, replacements), MAX_LABEL_SIZE) + "\\l\"];\n"
      + "}",
      kratos_code_file);

   addNote("Creating vfm PDF code in '" + vfm_code_file + "'.");
   StaticHelper::createImageFromGraphvizDot(
      std::string("digraph G {\n")
      + "s [shape=record label=\"" + StaticHelper::shortenToMaxSize(StaticHelper::replaceManyTimes(vfm_code, replacements), MAX_LABEL_SIZE) + "\\l\"];\n"
      + "}",
      vfm_code_file);

   addNote("Kreating Kratos tree PDF in '" + kratos_file + "_TREE.dot.pdf" + "'.");
   StaticHelper::createImageFromGraphvizDot(full_formula->generateGraphviz(0, false), kratos_file + "_TREE.dot");

   return fsm_controlled_out;
}

void CppParser::createResultFiles(
   const std::string& target_path_for_generated_code, 
   const MCSpecification& mc_specs, 
   const std::string& path_to_envmodel_template,
   const std::string& path_to_envmodel_file)
{
   checkConstraintsForConsistency(types_of_variables_);

   std::string kratos_filename{ target_path_for_generated_code + "_combined.k2" };
   auto fsm_controlled{ kreateKratosFilesAndCheckFormula(kratos_filename) };

   generateMainFileForNativeEnvModel(target_path_for_generated_code, kratos_filename, path_to_envmodel_template, fsm_controlled, path_to_envmodel_file);
}

bool setTypeConst(const vfm::CppType& type, const float const_value, const std::string& m_var_name, const Failable* log_to = nullptr)
{
   if (!type->isConst()) {
      if (type->getName() == IMMUTABLE_BOOL_CONST_TYPE_NAME || type->getName() == IMMUTABLE_ENUM_TYPE_NAME) {
         log_to->addDebug("Not touching variable '" + m_var_name + "' of immutable type.");
      } else {
         if (log_to) {
            log_to->addDebug("Found constant range '" + std::to_string(const_value) + ".." + std::to_string(const_value) + "' for non-const variable '" + m_var_name + "'. If it's fine by you, I'll make it constant.");
         }

         type->setConst(true);
         return true;
      }
   }

   return false;
}

void vfm::CppParser::setTypeOrSubTypeConstSafe(const std::string& m_var_name, const float const_value, const std::shared_ptr<vfm::TermVar>& m_var)
{
   if (types_of_variables_.count(m_var_name)) {
      auto type = types_of_variables_.at(m_var_name).first;
      setTypeConst(type, const_value, m_var_name, this);
      type->getName() != IMMUTABLE_BOOL_CONST_TYPE_NAME && type->getName() != IMMUTABLE_ENUM_TYPE_NAME;
   }
   else {
      const auto error_str = "Found constant range '" + std::to_string(const_value) + ".." + std::to_string(const_value) + "' for variable '" + m_var_name + "'. It's not in 'types_of_variables_', though, so I can't make it constant.";
      auto base_name = getTypeBaseName(m_var_name);

      if (types_of_variables_.count(base_name)) {
         auto base = types_of_variables_.at(base_name);
         auto type = base.first->deriveSubTypeFor(m_var_name, !isLocalVarName(m_var_name).empty(), false, ErrorLevelEnum::invalid).first;

         if (type) {
            setTypeConst(type, const_value, m_var_name, this);
            type->getName() != IMMUTABLE_BOOL_CONST_TYPE_NAME && type->getName() != IMMUTABLE_ENUM_TYPE_NAME;
         }
         else {
            addError(error_str);
         }
      }
      else {
         addError(error_str);
      }
   }

   m_var->getPtrToRoot()->applyToMeAndMyChildrenIterative([const_value, &m_var_name](const MathStructPtr m) { // Set all variables of that name const.
      const auto v = m->toVariableIfApplicable();

      if (v && StaticHelper::cleanVarNameOfPossibleRefSymbol(v->getVariableName()) == StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name)) {
         m->toVariableIfApplicable()->setConstVariable(const_value);
      }
   }, TraverseCompoundsType::avoid_compound_structures);

   data_->addConstVariable(m_var_name, const_value);
}

void vfm::CppParser::applyToAllMCItems(const std::function<void(std::shared_ptr<MathStruct>)>& f, const bool include_constraints, const bool include_all_functions)
{
   for (auto& fmla_raw : function_definitions_) {
      if (include_all_functions || fmla_raw.first == main_function_name_) {
         auto fmla{ _id(fmla_raw.second) };
         fmla->applyToMeAndMyChildren(f, TraverseCompoundsType::go_into_compound_structures);
         fmla_raw.second = fmla->getOperands()[0];
      }
   }

   if (include_all_functions) {
      for (auto& function_pairs : parser_->getDynamicTermMetas()) {
         for (auto& function_pair : function_pairs.second) {
            auto fmla = _id(function_pair.second);
            fmla->applyToMeAndMyChildren(f, TraverseCompoundsType::go_into_compound_structures);
            function_pair.second = fmla->getOperands()[0];
         }
      }
   }

   if (include_constraints) {
      for (auto& invariant : all_invariants_) {
         auto fmla = _id(invariant);
         fmla->applyToMeAndMyChildren(f, TraverseCompoundsType::go_into_compound_structures);
         invariant = fmla->getOperands()[0];
      }

      for (auto& initial_state_constraint : all_initial_state_constraints_) {
         auto fmla = _id(initial_state_constraint);
         fmla->applyToMeAndMyChildren(f, TraverseCompoundsType::go_into_compound_structures);
         initial_state_constraint = fmla->getOperands()[0];
      }

      for (const auto& el : type_abstraction_layer_->getVariablesWithTypes()) { // INIT-Formulas
         auto init_str = el.second.second;

         if (init_str != FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER) {
            auto formula = _id(MathStruct::parseMathStruct(init_str, parser_, data_)->toTermIfApplicable());
            formula->applyToMeAndMyChildren(f, TraverseCompoundsType::go_into_compound_structures);
            type_abstraction_layer_->setInitValueOf(el.first, formula->getOperands()[0]->serialize());
            addDebug("{{applyToAllMCItems}} Init value of variable '" + el.first + "' is '" + init_str + "'.");
         }
      }
   }
}

void vfm::CppParser::createConstantsFromPointRangeVariables()
{
   applyToAllMCItems([this](const MathStructPtr m) {
      if (m->isTermVar()) {
         auto m_var{ m->toVariableIfApplicable() };
         auto m_var_name{ StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName()) };

         if (!StaticHelper::isPrivateVar(m_var_name) && !IGNORE_THESE.count(m_var_name)) {
            auto range{ type_abstraction_layer_->getRange(m_var_name) };

            if (range.first == range.second) {
               setTypeOrSubTypeConstSafe(m_var_name, range.first, m_var);
            }
         }
      }
   }, true);
}

void vfm::CppParser::insertLiteralValuesForConstants()
{
   applyToAllMCItems([this](const MathStructPtr m) {
      if (m->isTermVarNotOnLeftSideOfAssignment()) {
         auto m_var{ m->toVariableIfApplicable() };
         auto m_var_name{ m_var->getVariableName() };

         if (types_of_variables_.count(m_var_name) && containsConstQualifier(types_of_variables_.at(m_var_name))) {
            if (!m_var->isConstVariable()) {
               addWarning("Variable '" + m_var_name + "' has const qualifier, but is not set const in formula.");
            }

            TermPtr replacement{ _val(m_var->constEval()) };

            if (types_of_variables_.at(m_var_name).first->toBoolIfApplicable()) {
               replacement = _var(m_var->constEval() ? "true" : "false");
            }
            else if (types_of_variables_.at(m_var_name).first->toEnumIfApplicable()) {
               addError("Constant enums not yet supported. You'll need to request this feature...");
            }

            addDebug("Found const variable '" + m_var_name + "' of type '" + types_of_variables_.at(m_var_name).first->getName() + "'. Replacing it with value '" + replacement->serialize() + "'.");
            m_var->replace(replacement);
         }
         else {
            auto base_name{ getTypeBaseName(m_var_name) };

            if (types_of_variables_.count(base_name)) {
               auto base{ types_of_variables_.at(base_name) };
               auto pair{ base.first->deriveSubTypeFor(m_var_name, !isLocalVarName(m_var_name).empty(), false, ErrorLevelEnum::invalid) };
               auto type{ pair.first };

               if (type && type->isConst()) {
                  addDebug("Found const variable '" + m_var_name + "'.");

                  auto val1{ m_var->constEval() };

                  if (pair.second.first) {
                     auto val2{ MathStruct::parseMathStruct(*pair.second.first, parser_, data_)->eval(data_, parser_) };
                     auto val{ val1 != 0 ? val1 : val2 };

                     if (val1 != val2) {
                        addWarning("Variable '" + m_var_name + "' is const, but the value in the formla tree (" + std::to_string(val1) + ") differs from the one retrieved as init value (" + std::to_string(val2) + "). I'll take " + std::to_string(val) + ".");
                     }
                     m_var->replace(_val(val));
                  }
                  else {
                     addWarning("Const variable '" + m_var_name + "' is const, but there has no init value been retrieved. I'll take the value from the formula tree: " + std::to_string(val1) + ".");
                     m_var->replace(_val(val1));
                  }
               }
            }
         }
      }
      else if (m->isTermVarOnLeftSideOfAssignment()) { // TODO: lots of double code to above.
         auto m_var{ m->toVariableIfApplicable() };
         auto m_var_name{ StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var->getVariableName()) };

         if (types_of_variables_.count(m_var_name) && containsConstQualifier(types_of_variables_.at(m_var_name))) {
            if (!m_var->isConstVariable()) {
               addWarning("Variable '" + m_var_name + "' has const qualifier, but is not set const in formula.");
            }
            addDebug("Found const set variable '" + m_var_name + "'. Deleting the line.");
            m_var->getFather()->removeLineFromSequence();
         }
         else {
            auto base_name{ getTypeBaseName(m_var_name) };

            if (types_of_variables_.count(base_name)) {
               auto base{ types_of_variables_.at(base_name) };
               auto pair{ base.first->deriveSubTypeFor(m_var_name, !isLocalVarName(m_var_name).empty(), false, ErrorLevelEnum::invalid) };
               auto type{ pair.first };

               if (type && type->isConst()) {
                  addDebug("Found const set variable '" + m_var_name + "'. Deleting the line.");
                  m_var->getFather()->removeLineFromSequence();
               }
            }
         }
      }
   }, true);
}

std::string vfm::CppParser::serializeKratos(
   const TermPtr full_formula,
   const std::string& entry_function_name,
   const std::map<std::string, std::string>& enum_values,
   const std::vector<std::string>& variables_ordered,
   const std::set<std::string> blacklist,
   const bool native_env_model_wf,
   const std::map<std::string, std::string>& all_variables_except_immutable_enum_and_bool_with_type,
   VariablesWithKinds& fsm_controlled) const
{
   std::string s{R"(;; ============================================================================================================
;; C O P Y R I G H T
;; ------------------------------------------------------------------------------------------------------------
;; copyright (C) 2022 Robert Bosch GmbH. All rights reserved.
;; ============================================================================================================
)"};
   std::string pars{};
   std::string pars_plain{};
   //std::string dummy_func_name = "call_" + entry_function_name;
   std::string declarations{};
   std::string initializations{};
   std::pair<std::map<std::string, std::string>, std::string> additional_functions{};

   fsm_controlled = full_formula->findSetVariables(data_);

   fsm_controlled.renameVariablesForKratos();

   if (!native_env_model_wf) { // Shift all variables into "first" to achieve behavior as used before the 3rd workflow.
      for (const auto& el : fsm_controlled.getOutputVariables()) {
         fsm_controlled.addInputVariable(el);
      }

      fsm_controlled.clearOutputVariables();
   }

   auto vars_inp{ fsm_controlled.getVariablesOfSpecifiedKindForMainSMV(VarClassification::input, all_variables_except_immutable_enum_and_bool_with_type) };

   auto helper = [this](const std::string& par) -> std::string {
      if (!types_of_variables_.count(par)) return "notype";
      return types_of_variables_.at(par).first->toStringNuXmv();
   };

   std::string testo{ "\nVAR\n-- Planner variables\n" };
   for (const auto& par : vars_inp) {
      pars += std::string("\n") + "(! (var |" + par + "| " + all_variables_except_immutable_enum_and_bool_with_type.at(par) + ") :input-var true)";
      testo += par + " : " + helper(par) + ";\n";
   }
   testo += "-- EO Planner variables\n\n";
   for (const auto& par : vars_inp) {
      std::string init_value{ type_abstraction_layer_->getInitValueFor(par) };
      std::string additional_info{};

      if (init_value == mc::NO_INIT_DENOTER) {
         if (helper(par) == "boolean") {
            init_value = "FALSE";
            additional_info = " -- Init value guessed.";
         }
         else if (helper(par) == "integer") {
            init_value = "0";
            additional_info = " -- Init value guessed.";
         }
      }

      testo += "INIT " + par + " = " + StaticHelper::replaceAll(init_value, "::", "____") + ";" + additional_info + "\n";
   }
   data_->addStringToDataPack(testo, "PLANNER_VARIABLES");

   std::string return_variables{};

   if (native_env_model_wf) {
      for (const auto& par : fsm_controlled.getOutputVariables()) {
         if (!fsm_controlled.getInputVariables().count(par) && type_abstraction_layer_->getVariablesWithTypes().count(par)) {
            auto type{ type_abstraction_layer_->getVariablesWithTypes().at(par).first };
            std::string type_str{ mc::TypeAbstractionLayer::getMcType(type).first };
            return_variables += "\n(var |" + par + "| " + type_str + ")";
         }
      }
   }
   else {
      return_variables = "(var |ret| int)";
   }

   for (const auto& ignore_item : blacklist) {
      fsm_controlled.eraseFromInputVariables(ignore_item);
      fsm_controlled.eraseFromInputVariables(SYMB_REF + ignore_item);
      fsm_controlled.eraseFromOutputVariables(ignore_item);
      fsm_controlled.eraseFromOutputVariables(SYMB_REF + ignore_item);
   }

   std::vector<std::string> variables_ordered_kratos_style{};
   for (const auto& var : variables_ordered) variables_ordered_kratos_style.push_back(StaticHelper::replaceAll(var, "::", "____"));

   for (const auto& ivar : variables_ordered_kratos_style) {
      if (fsm_controlled.getInputVariables().count(ivar) && fsm_controlled.getOutputVariables().count(ivar)) {
         auto declaration = getInitVarStringNuSMVOrKratos(ivar, additional_functions, false, false, true, enum_values);
         auto initialization = getInitVarStringNuSMVOrKratos(ivar, additional_functions, true, false, true, enum_values);

         if (!declaration.empty() && !initialization.empty()) {
            declarations += declaration;
            initializations += initialization;
            addDebug("Added variable '" + ivar + "' with declaration '" + StaticHelper::trimAndReturn(declaration) + "' and initialization '" + StaticHelper::trimAndReturn(initialization) + "' to kratos code.");
         }
         else {
            addDebug("Empty initialization received for variable '" + ivar + "'.");
         }
      }
      else {
         if (!fsm_controlled.getOutputVariables().count(ivar)) {
            addDebug("Variable '" + ivar + "' omitted since it is not FSM-controlled (i.e., not an output variable).");
         }
         else if (!fsm_controlled.getInputVariables().count(ivar)) {
            addDebug("Variable '" + ivar + "' omitted since it is not an input variable.");
         }
         else {
            addDebug("Variable '" + ivar + "' omitted since it is neither an input nor an output variable.");
         }
      }
   }

   for (const auto& ivar : fsm_controlled.getOutputVariables()) {
      if (std::find(variables_ordered_kratos_style.begin(), variables_ordered_kratos_style.end(), ivar) == variables_ordered_kratos_style.end()) {
         addWarning("FSM-controlled variable '" + ivar + "' omitted since it is not in the ordered variables list.");
      }
   }

   std::string main_part = full_formula->serializeK2(enum_values, additional_functions);

   for (const auto& kratos_assert : all_kratos_constraints_) {
      std::string kratos_assert_str = "(call assert " + kratos_assert->serializeK2(enum_values, additional_functions) + ")\n";
      main_part = StaticHelper::replaceAll(main_part, "\n(label while0)\n", "\n(label while0)\n" + kratos_assert_str); // TODO!
   }

   for (const auto& init_constraint : all_initial_state_constraints_) {
      std::string init_constraint_str = "(assume " + init_constraint->serializeK2(enum_values, additional_functions) + ")";
      main_part = StaticHelper::replaceAll(main_part, "\n(label while0)\n", "\n" + init_constraint_str + "\n(label while0)\n"); // TODO!
   }

   s += R"((function assert ((var cond bool)) (return)
(locals)
(seq
(condjump cond (label end))
(! (label error) :error assert-fail)
(label end)))
)";

   s += R"(
(function rndet ((var lo int) (var hi int)) (return (var ret int)) 
(locals) 
(seq (havoc ret) (assume (and (ge ret lo) (le ret hi)))))
)";

   static constexpr bool DEBUG_KRATOS{ true }; // Makes purely internal variables visible by declaring them return variables.

   if (DEBUG_KRATOS) {
      addNote("Debug mode Kratos active. I will add internal variables to return interface to make them visible in CEX.");
   }

   s += additional_functions.second;

   s += "\n" + StaticHelper::createKratosNdetFunction("ndet_int2", { "int" , "int" });
   s += "\n" + StaticHelper::createKratosNdetFunction("ndet_bool2", { "bool" , "bool" });

   s += std::string("\n(entry ") + /*dummy_func_name*/ entry_function_name + ")\n";
   s += "(globals" + std::string(native_env_model_wf ? " (! (var loc bool) :location-var true)" : "") + ")\n";
   s += std::string("(function " + entry_function_name + " (") + pars + "\n)\n\
(return " + return_variables + (DEBUG_KRATOS ? " ;; EO output vars. Due to debug mode, the internal vars are returned, as well.\n" + declarations : "") + "\n)\n";
   s += std::string("(locals\n") + (DEBUG_KRATOS ? "" : declarations) + ")\n";

   s += +"\n(seq\n" + initializations + "\n";

   s += main_part;
   s += ")\n)\n\n";
   //s += std::string("(function ") + dummy_func_name + " () (return) (locals " + pars + " (var global_return_value int)) (call " + entry_function_name + " " + pars_plain + " global_return_value))";
   s += "\n";

   addDebug("Kreated Kratos code:\n" + s);

   return s;
}

void vfm::CppParser::inferRangeForLocalVariables()
{
   float node_count{ 0 };

   applyToAllMCItems([&node_count](const MathStructPtr m) {
      node_count++;
   }, false);

   float current_count{ 0 };
   int old_percent{ 0 };
   std::vector<std::pair<std::string, std::shared_ptr<TermVar>>> touched_items{};

   applyToAllMCItems([this, &current_count, &old_percent, &node_count, &touched_items](const MathStructPtr m) {
      current_count++;
      int percent = (int) (100 * current_count / node_count);

      if (percent != old_percent) {
         std::cout << StaticHelper::printProgress("Range inferral <logging paused>", percent - 1, 100, 100);

         if (percent == 100) {
            std::cout << "\n";
         }
      }

      old_percent = percent;

      if (m->isTermVarOnLeftSideOfAssignment()) {
         auto m_var_name{ StaticHelper::cleanVarNameOfPossibleRefSymbol(m->toVariableIfApplicable()->getVariableName()) };

         if (StaticHelper::stringContains(m_var_name, TEMP_VAR_BASE_NAME) || !isLocalVarName(m_var_name).empty()) {
            auto old_range = type_abstraction_layer_->hasRange(m_var_name)
               ? type_abstraction_layer_->getRange(m_var_name)
               : std::pair<float, float>({ 1, 0 });
            
            addDebug("Extending range (" + std::to_string(old_range.first) + ".." + std::to_string(old_range.second) + ") for variable '" + m_var_name + "' in line '" + m->getFather()->serialize() + "'.");

            if (types_of_variables_.count(m_var_name)) {
               auto cpp_type = types_of_variables_.at(m_var_name).first;

               if (cpp_type->toBoolIfApplicable()) {
                  addDebug("Found boolean type, inferring range (0..1). TODO: Using our cool range inferral method, we might reduce this to a constant in some cases.");
                  type_abstraction_layer_->addBooleanVariable(m_var_name, false);
               }
               else if (cpp_type->toEnumIfApplicable()) {
                  addDebug("Found enum type, inferring full enum range. TODO: Using our cool range inferral method, we might reduce this to a subset/constant in some cases.");
                  type_abstraction_layer_->addVariableWithEnumType(m_var_name, cpp_type->toEnumIfApplicable());
               }
               else {
                  addDebug("Found number type, inferring range from atomic variables...");

                  auto pair = deriveGlobalRangeFromLeafRanges(m->getFather()->getTermsJumpIntoCompounds()[1]);

                  if (pair.first > pair.second) {
                     addError("Invalid range <" + std::to_string(pair.first) + ".." + std::to_string(pair.second) + "> received for '" + m_var_name + "'.");
                  }

                  type_abstraction_layer_->extendOrSetRangeOfIntVariable(m_var_name, pair.first, pair.second);

                  auto new_range = type_abstraction_layer_->getRange(m_var_name);

                  addDebug("New range is: (" + std::to_string(pair.first) + ".." + std::to_string(pair.second) + ").");
                  addDebug("Extended to : (" + std::to_string(new_range.first) + ".." + std::to_string(new_range.second) + ").");

                  touched_items.push_back({ m_var_name, m->toVariableIfApplicable() });

                  if (global_primitives_init_values_.count(m_var_name) && global_primitives_init_values_[m_var_name] == FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER) {
                     const auto& range = type_abstraction_layer_->getRange(m_var_name);
                     const int some_random_init_value = range.first;
                     const std::string some_random_init_value_str = _val(some_random_init_value)->serialize();

                     addDebug("{{inferRangeForLocalVariables}} Initial value of variable '" + m_var_name + "' is '" + some_random_init_value_str + "'.");

                     type_abstraction_layer_->setInitValueOf(m_var_name, some_random_init_value_str);
                     global_primitives_init_values_[m_var_name] = some_random_init_value;
                  }
               }
            }
            else {
               addError("Variable '" + m_var_name + "' not found in 'types_of_variables_'. Range inferral failed.");
            }
         }
      }
   }, false);

   resumeOutputOfMessages();

   for (const auto& item : touched_items) {
      const auto& range = type_abstraction_layer_->getRange(item.first);

      if (range.first == range.second) {
         addNote("Range of '" + item.first + "' decayed to constant value '" + std::to_string(range.first) + "'. I'll make it a constant.");
         setTypeOrSubTypeConstSafe(item.first, range.first, item.second);
      }
   }
}

std::string vfm::CppParser::toStringCppParser() const
{
   std::string s{ };

   s += "\n\n######\noptions_:\n" + options_.serialize();
   s += "\n\n######\ncommand_line_argument_:\n" + command_line_argument_;
   s += "\n\n######\nparser_:\n" + parser_->toStringCompoundFunctions();
   s += "\n\n######\ntype_abstraction_layer_:\n" + type_abstraction_layer_->serialize(true);
   s += "\n\n######\nfsm_->type_abstraction_layer_:\n" + type_abstraction_layer_->serialize(true);
   s += "\n\n######\nmain_function_name_:\n" + main_function_name_;
   s += "\n\n######\nmain_namespace_name_:\n" + main_namespace_name_;
   s += "\n\n######\nin_envmodel_mode_:\n" + in_envmodel_mode_;
   s += "\n\n######\nuse_or_generate_native_smv_env_model_:\n" + use_or_generate_native_smv_env_model_;
   s += "\n\n######\ntemp_variable_counter_:\n" + temp_variable_counter_;
   s += "\n\n######\nsmv_module_:\n" + (smv_module_ ? smv_module_->serialize() : "NULL");
   s += "\n\n######\ndata_types_:\n";

   for (const auto& el : data_types_) {
      s += el->toString() + "\n";
   }

   s += "\n\n######\nfunction_definitions_:\n";

   for (const auto& el : function_definitions_) {
      s += el.first + " = " + el.second->serialize() + "\n";
   }

   s += "\n\n######\ntypes_of_variables_:\n";

   for (const auto& el : types_of_variables_) {
      s += el.first + " = " + el.second.first->toString() + " [";

      for (const auto& qualifier : el.second.second) {
         s += qualifier + ",";
      }

      s += "]\n";
   }

   s += "\n\n######\nglobal_primitives_tal_range_descriptions_:\n";

   for (const auto& el : global_primitives_tal_range_descriptions_) {
      s += el.first + " = " + el.second + "\n";
   }

   s += "\n\n######\nglobal_primitives_aka_descriptions_:\n";

   for (const auto& el : global_primitives_aka_descriptions_) {
      s += el.first + " = " + el.second + "\n";
   }

   s += "\n\n######\nglobal_primitives_init_values_:\n";

   for (const auto& el : global_primitives_init_values_) {
      s += el.first + " = " + el.second + "\n";
   }

   s += "\n\n######\nfunction_aka_from_new_to_old_:\n";

   for (const auto& el : function_aka_from_new_to_old_) {
      s += el.first + " = " + el.second + "\n";
   }

   s += "\n\n######\nall_fsm_controlled_variables_:\n";

   for (const auto& el : all_fsm_controlled_variables_) {
      s += el + "\n";
   }

   s += "\n\n######\nall_external_variables_:\n";

   for (const auto& el : all_external_variables_) {
      s += el + "\n";
   }

   s += "\n\n######\nall_constants_to_model_checker_:\n";

   for (const auto& el : all_constants_to_model_checker_) {
      s += el + "\n";
   }

   s += "\n\n######\nvariables_ordering_:\n";

   for (const auto& el : variables_ordering_) {
      s += el + "\n";
   }

   s += "\n\n######\nfunction_signatures_:\n";

   for (const auto& el : function_signatures_) {
      s += el.first + " = " + toStringFunctionSignature(el.second) + "\n";
   }

   s += "\n\n######\nall_initial_state_constraints_:\n";

   for (const auto& el : all_initial_state_constraints_) {
      s += el->serialize() + "\n";
   }

   s += "\n\n######\nall_invariants_:\n";

   for (const auto& el : all_invariants_) {
      s += el->serialize() + "\n";
   }

   s += "\n\n######\nall_kratos_constraints_:\n";

   for (const auto& el : all_kratos_constraints_) {
      s += el->serialize() + "\n";
   }

   s += "\n\n######\nmain_function_name_:\n" + main_function_name_;

   s += "\n\n######\ndata_:\n" + data_->toStringHeap();

   return s;
}

void vfm::CppParser::applyPrecisionIncreaseTo(const TermPtr fmla) const
{
   mc::simplification::applyToFullFormula(
      fmla,
      { apply_rule_INCREASE_INT_PRECISION_BY_10_0, apply_rule_INCREASE_INT_PRECISION_BY_10_1, apply_rule_INCREASE_INT_PRECISION_BY_10_2, apply_rule_INCREASE_INT_PRECISION_BY_10_3 },
      parser_, true);
}

void vfm::CppParser::postprocessFinalModel()
{
   addNote("Creating constants for point-range variables.");
   createConstantsFromPointRangeVariables();

   addNote("Inserting literal values for constants 1.");
   insertLiteralValuesForConstants();

   addNote("Inferring ranges for '" + TEMP_VAR_BASE_NAME + "' and other local variables.");
   if (true) inferRangeForLocalVariables();

   addNote("Inserting literal values for constants 2.");
   insertLiteralValuesForConstants();

   for (auto& el : global_primitives_init_values_) {
      if (el.second == FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER) {
         addDebug("Variable '" + el.first + "' still has init value '" + FIGURE_OUT_RANDOM_VALUE_FROM_RANGE_LATER + "'. You'll get an error if the variable is used, otherwise it's fine.");
      }
   }

   if (options_.getOptimizationMode() == OptimizationModeEnum::all) {
      addNote("Simplifying final FSM (optimization mode '" + options_.getOptimizationMode().getEnumAsString() + "').");
      function_definitions_.at(main_function_name_) = mc::simplification::simplifyFast(function_definitions_.at(main_function_name_));
      StaticHelper::checkForOutdatedSimplification(parser_);
   } else if (options_.getOptimizationMode() == OptimizationModeEnum::inner_only) {
      addNote("Optimizing code parts marked with '" + INNER_SIMPLIFY_KEYWORD + "(...)' keyword (optimization mode '" + options_.getOptimizationMode().getEnumAsString() + "').");

      auto formula{ _id(function_definitions_.at(main_function_name_)) };

      bool changed{ true };

      while (changed) {
         changed = false;

         formula->applyToMeAndMyChildrenIterative([this, &changed](const MathStructPtr m)
         {
            if (m->getOptorOnCompoundLevel() == INNER_SIMPLIFY_KEYWORD) {
               auto formula_before{ m->child0JumpIntoCompounds() };
               std::string before{ formula_before->serializeWithinSurroundingFormula(50, 50) };
               auto formula_after{ mc::simplification::simplifyFast(formula_before) };
               StaticHelper::checkForOutdatedSimplification(parser_);
               std::string after{ formula_after->serializeWithinSurroundingFormula(50, 50) };
               m->replaceJumpOverCompounds(formula_after);
               changed = true;
               addNote("Simplified subformula '" + before + "' to '" + after + "'.");
            }
         }, TraverseCompoundsType::avoid_compound_structures, changed);

         formula->setChildrensFathers(vfm::MathStruct::FatherSetterStyle::avoid_compound_structures);
         StaticHelper::makeAssociative(formula, ";", AssociativityTypeEnum::left);
      }

      function_definitions_.at(main_function_name_) = formula->child0();
   }
   else {
      addWarning("Fully omitting simplification of final FSM due to optimization mode set to '" + options_.getOptimizationMode().getEnumAsString() + "' (this is recommended only for debugging).");
   }

   addNote("Increasing precision of remaining 'rational' int variables by factor 10 in multiplications and divisions.");
   auto fmla{ _id(function_definitions_.at(main_function_name_)) };

   applyPrecisionIncreaseTo(fmla);

   StaticHelper::checkForOutdatedSimplification(parser_);
   function_definitions_.at(main_function_name_) = fmla->getOperands()[0];
}

void vfm::CppParser::handleGlobalAKAs(const MathStructPtr formula)
{
   for (const auto& aka_mapping : global_primitives_aka_descriptions_) {
      std::string original_name{ aka_mapping.first };
      std::string aka_var_name{ StaticHelper::fromSafeString(aka_mapping.second.substr(3)) };

      aka_var_name = getAKAFromHeap(MathStruct::parseMathStruct(aka_var_name, parser_, data_));

      type_abstraction_layer_->addAkaMapping(original_name, aka_var_name);

      addNote("Converting variable names to their AKAs.");
      formula->applyToMeAndMyChildren([&original_name, &aka_var_name](const MathStructPtr m) {
         auto m_var{ m->toVariableIfApplicable() };

         if (m_var) {
            std::string m_var_name{ m_var->getVariableName() };

            if (StaticHelper::cleanVarNameOfPossibleRefSymbol(m_var_name) == original_name) {
               std::string possible_ref_symbol{ StaticHelper::stringStartsWith(m_var_name, SYMB_REF) ? SYMB_REF : "" };
               std::string new_name{ possible_ref_symbol + aka_var_name };
               m_var->setVariableName(new_name);
            }
         }
      });
   }
}

std::map<std::string, std::string> vfm::CppParser::getAllVariablesExceptImmutableEnumAndBoolTypes() const
{
   std::map<std::string, std::string> all_variables_except_immutable_enum_and_bool{};

   for (const auto& var : types_of_variables_) {
      CppType type = var.second.first;

      if (type->getName() != IMMUTABLE_BOOL_CONST_TYPE_NAME && type->getName() != IMMUTABLE_ENUM_TYPE_NAME) {
         if (type_abstraction_layer_->getVariablesWithTypes().count(var.first)) {
            all_variables_except_immutable_enum_and_bool.insert({ var.first, type_abstraction_layer_->getVariablesWithTypes().at(var.first).first.mc_type_name_ });
         }
         else {
            if (type->toAtomicIfApplicable() && type->toAtomicIfApplicable()->getBaseType() == DataPack::AssociationType::Float) {
               addWarning("Variable '" + var.first + "' not found in TAL, meaning it has no proper range attached. I'll ignore this for now and take the type indicated by 'types_of_variables_', which is '" + var.second.first->toString() + "'.");
               all_variables_except_immutable_enum_and_bool.insert({ var.first, "int" });
            }
            else if (type->toAtomicIfApplicable() && type->toAtomicIfApplicable()->getBaseType() == DataPack::AssociationType::Bool) {
               addWarning("Variable '" + var.first + "' not found in TAL, meaning it has no proper range attached. I'll ignore this for now and take the type indicated by 'types_of_variables_', which is '" + var.second.first->toString() + "'.");
               all_variables_except_immutable_enum_and_bool.insert({ var.first, "bool" });
            }
            else {
               addDebug("Variable '" + var.first + "' not found in TAL. Assigning 'dummy_type'.");
               all_variables_except_immutable_enum_and_bool.insert({ var.first, "dummy_type" });
            }
         }
      }
   }

   return all_variables_except_immutable_enum_and_bool;
}

void vfm::CppParser::generateMainFileForNativeEnvModel(
   const std::string& generated_folder, 
   const std::string& planner_filename, 
   const std::string& env_model_template_filename,
   const VariablesWithKinds& fsm_controlled,
   const std::string& path_to_envmodel_file) const
{
   if (true /*has_envmodel_ && use_or_generate_native_smv_env_model_*/) { // Old workflow not supported anymore.
      addNote("Generating main SMV file.");
      auto pair{ StaticHelper::split(env_model_template_filename, NATIVE_SMV_ENV_MODEL_DENOTER_CLOSE) };
      std::string env_model_pattern{ StaticHelper::replaceAll(pair[0], NATIVE_SMV_ENV_MODEL_DENOTER_OPEN, "") };
      std::string envmodel_base_name{ StaticHelper::removeLastFileExtension(StaticHelper::getFileNameFromPath(pair[1])) };
      std::string main_file_tpl{ StaticHelper::removeLastFileExtension(pair[1], "/") + "/main.tpl" };
      std::string template_str{ StaticHelper::readFile(main_file_tpl) };

      std::string envmodel_name{ deriveEnvModelFileName(
         envmodel_base_name, 
         StaticHelper::split(env_model_pattern,NATIVE_SMV_ENV_MODEL_SEPARATOR), 
         *data_) };

      std::string planner_smv_name{ StaticHelper::getFileNameFromPath(planner_filename) + ".smv" };

      const auto aka{ [this](const std::string& var) -> std::string {
         return type_abstraction_layer_->getPlannerToEnvModelVarnameMapping().count(var)
            ? type_abstraction_layer_->getPlannerToEnvModelVarnameMapping().at(var)
            : var;
      } };

      const auto func{ [&aka, this](const std::string& var) -> std::string {
         std::string possible_aka{aka(var)};

         return possible_aka == var ? "" : " (AKA '" + possible_aka + "')";
      } };

      std::string k2_parameters{};
      std::string k2_output{};

      // Assuming that the ordering does not change in the fsm_controlled sets (cf. https://stackoverflow.com/questions/8833938).
      auto scaling_description{ ScaleDescription(StaticHelper::readFile(path_to_envmodel_file)) };
      float time_scaling_factor{ scaling_description.getTimeScalingFactor() };
      float distance_scaling_factor{ scaling_description.getDistanceScalingFactor() };

      std::vector<VariableScaleDescription> timescaled_variables{ scaling_description.getVariables() };

      for (const auto& in_var : fsm_controlled.getVariablesOfSpecifiedKindForMainSMV(VarClassification::input, getAllVariablesExceptImmutableEnumAndBoolTypes())) {
         addDebug("Processing input variable '" + in_var + "'" + func(in_var) + " for main.smv.");
       
         std::string timescaling_addition{};

         /*
            Eingabe fr unsere Skalierung ist t_hut und x_hut, was die Skalierungsfaktoren fr die Zeit und den Raum sind.
            Fr die Umrechnung reale Welt => EnvModel gilt:
               Raum-Variablen werden mit x_hut multipliziert
               Zeit-Variablen werden mit t_hut multipliziert
               Geschw-Variablen werden mit x_hut/t_hut multipliziert
               Beschl.-Variablen werden mit x_hut/t_hut^2 multipliziert
            EnvModel => reale Welt entsprechend umgekehrt:
               Raum-Variablen werden durch x_hut dividiert
               Zeit-Variablen werden durch t_hut dividiert
               Geschw-Variablen werden mit t_hut/x_hut multipliziert
               Beschl.-Variablen werden mit t_hut^2/x_hut multipliziert
            D.h. fr die Umrechnung in beide Richtungen reicht es, wenn wir...
               t_hut und x_hut kennen und
               fr jede Variable wissen, ob sie 1, 2, 3 oder 4 ist.
         */

         for (const auto& tsvar : timescaled_variables) {
            if (tsvar.variable_name_ == in_var) {
               if (tsvar.type_ == ScaleTypeEnum::time) {
                  timescaling_addition = " / " + std::to_string(time_scaling_factor);
               }
               else if (tsvar.type_ == ScaleTypeEnum::distance) {
                  timescaling_addition = " / " + std::to_string(distance_scaling_factor);
               }
               else if (tsvar.type_ == ScaleTypeEnum::velocity) {
                  timescaling_addition = " * " + std::to_string(time_scaling_factor) + " / " + std::to_string(distance_scaling_factor);
               }
               else if (tsvar.type_ == ScaleTypeEnum::acceleration) {
                  timescaling_addition = " * " + std::to_string(time_scaling_factor) + " * " + std::to_string(time_scaling_factor) + " / " + std::to_string(distance_scaling_factor);
               }
               else if (tsvar.type_ == ScaleTypeEnum::none) {
                  // Do nothing.
               }
               else {
                  addError("TimescaleType '" + tsvar.type_.getEnumAsString() + "' not supported.");
               }
            }
         }

         auto par_formula{ _id(MathStruct::parseMathStruct("env." + aka(in_var) + timescaling_addition, parser_, data_)->toTermIfApplicable()) };
         applyPrecisionIncreaseTo(par_formula);

         k2_parameters += ",\n   " + par_formula->child0()->serialize();
      }

      for (const auto& out_var : fsm_controlled.getVariablesOfSpecifiedKindForMainSMV(VarClassification::output, getAllVariablesExceptImmutableEnumAndBoolTypes())) {
         // TRANS env.ego.a = planner."agent.a";
         addDebug("Processing output variable '" + out_var + "'" + func(out_var) + " for main.smv.");

         k2_output += "-- TRANS env." + aka(out_var) + " = planner.\"" + out_var + "\";\n";
      }

      for (const auto& int_var : fsm_controlled.getVariablesOfSpecifiedKindForMainSMV(VarClassification::state, getAllVariablesExceptImmutableEnumAndBoolTypes())) {
         addDebug("(Ignoring internal variable '" + int_var + "'" + func(int_var) + " for main.smv.)");
      }

      auto em = std::make_shared<vfm::mc::EnvModel>(data_, parser_);
      addFailableChild(em);
      em->setTemplate(template_str);
      
      data_->addStringToDataPack(planner_smv_name, "FILENAME_PLANNER");
      data_->addStringToDataPack(envmodel_name, "FILENAME_ENVMODEL");
      data_->addStringToDataPack(k2_parameters, "PLANNER_PARAMETERS");
      data_->addStringToDataPack(k2_output, "TRANSITIONS_PLANNER_TO_ENVMODEL");
      data_->addStringToDataPack(main_function_name_, "PLANNER_ENTRY_FILENAME");

      std::string processed{ em->generateEnvModel(em) };

      StaticHelper::writeTextToFile(processed, StaticHelper::removeLastFileExtension(generated_folder, "/") + "/main.smv");
   }
}

std::string vfm::CppParser::getInitVarStringNuSMVOrKratos(
   const std::string& evar_raw,
   std::pair<std::map<std::string, std::string>, std::string>& additional_functions,
   const bool init,
   const bool next,
   const bool kratos,
   const std::map<std::string, std::string>& enum_values) const
{
   if (data_->isConst(StaticHelper::cleanVarNameOfPossibleRefSymbol(evar_raw)) || data_->isHidden(StaticHelper::cleanVarNameOfPossibleRefSymbol(evar_raw))) {
      return "";
   }

   std::string evar{ StaticHelper::makeVarNameNuSMVReady(evar_raw) };
   //std::string current_state_var_name{ StaticHelper::makeVarNameNuSMVReady(getCurrentStateVarName()) }; // Only for old-style nuxmv translation modes.

   if (evar[0] == '_') {
      return "";
   }

   if (all_constants_to_model_checker_.count(evar)) { // Currently empty.
      return "   DEFINE " + evar + " := " + std::to_string((int)MathStruct::parseMathStruct(evar, true, false, parser_)->toTermIfApplicable()->eval(data_, parser_)) + ";\n";
   }

   //if (next && evar == current_state_var_name) { // Only for old-style nuxmv translation modes.
   //   return "";
   //}

   std::string evar_doublecolon_reverted{ StaticHelper::replaceAll(evar, "____", "::") };


   if (!type_abstraction_layer_->getVariablesWithTypes().count(evar_doublecolon_reverted)) {
      // SPECIAL CASE FOR ACA4
      const std::string SPECIAL_CASE{ "GpFunktionsstatusGetriggerterFswBilden____calculate.isMinOrMaxDurationInCurrentStateElapsed" };
      const std::string SPECIAL_CASE_REVERTED{ "GpFunktionsstatusGetriggerterFswBilden::calculate.isMinOrMaxDurationInCurrentStateElapsed" };

      if (evar == SPECIAL_CASE) {
         addNote("Adding type bool for special case '" + SPECIAL_CASE + "' in ACA4 parsing.");
         const_cast<CppParser*>(this)->types_of_variables_[SPECIAL_CASE] = { std::make_shared<CppTypeAtomic>("bool", DataPack::AssociationType::Bool), {} };
         const_cast<CppParser*>(this)->types_of_variables_[SPECIAL_CASE_REVERTED] = { std::make_shared<CppTypeAtomic>("bool", DataPack::AssociationType::Bool), {} };
         type_abstraction_layer_->addBooleanVariable(SPECIAL_CASE, false);
         type_abstraction_layer_->addBooleanVariable(SPECIAL_CASE_REVERTED, false);
      }
      else {
         // EO SPECIAL CASE FOR ACA4
         if (types_of_variables_.count(evar_doublecolon_reverted)
            && types_of_variables_.at(evar_doublecolon_reverted).first->toAtomicIfApplicable()
            && types_of_variables_.at(evar_doublecolon_reverted).first->toAtomicIfApplicable()->getBaseType() == DataPack::AssociationType::Float) {
            addWarning("Variable '" + evar_doublecolon_reverted + "' not found in type abstraction layer (TAL). Using the one from 'types_of_variables_', which is Float ==> int.");
            type_abstraction_layer_->addIntegerVariable(evar_doublecolon_reverted, 0, 1);
         }
         else if (types_of_variables_.count(evar_doublecolon_reverted)
            && types_of_variables_.at(evar_doublecolon_reverted).first->toAtomicIfApplicable()
            && types_of_variables_.at(evar_doublecolon_reverted).first->toAtomicIfApplicable()->getBaseType() == DataPack::AssociationType::Bool) {
            addWarning("Variable '" + evar_doublecolon_reverted + "' not found in type abstraction layer (TAL). Using the one from 'types_of_variables_', which is Bool ==> bool.");
            type_abstraction_layer_->addBooleanVariable(evar_doublecolon_reverted, false);
         }
         else {
            addError("Variable '" + evar_doublecolon_reverted + "' not found in type abstraction layer (TAL).");
            type_abstraction_layer_->addDummyTypeVariable(evar_doublecolon_reverted, "dummy");
         }
         // SPECIAL CASE FOR ACA4
      }
      // EO SPECIAL CASE FOR ACA4
   }

   mc::MCType type = mc::TypeAbstractionLayer::getMcType(type_abstraction_layer_->getVariablesWithTypes().at(evar_doublecolon_reverted).first);
   std::string mc_type_name = type.first;
   std::string s = "   ";

   if (init) {
      auto val_fmla = MathStruct::parseMathStruct(type_abstraction_layer_->getInitValueFor(evar_doublecolon_reverted), parser_, data_)->toTermIfApplicable();

      if (kratos) {
         //if (data_->isVarDeclared(evar_raw)) {
         //   val_fmla = _val(data_->getSingleVal(evar_raw));
         //}

         val_fmla = _set_alt(_var(evar), val_fmla);
      }

      std::string val{ kratos ? val_fmla->serializeK2(enum_values, additional_functions) : val_fmla->serializeNuSMV(data_, parser_) };

      //if (!kratos && evar == current_state_var_name) { // Only for old-style nuxmv translation modes.
      //   val = getStateVarName(INVALID_STATE_NUM, false);
      //}

      if (kratos) {
         s += val;
      }
      else {
         s += "init(" + evar + ") := " + val;
      }
   }
   else if (next) {
      s += "next(" + evar + ") := " + evar;
   }
   else {
      if (kratos) {
         s += "(var " + _var(evar)->serializeK2(enum_values, additional_functions) + " " + mc_type_name + ")";
      }
      else {
         s += evar + " : " + mc_type_name;
      }

      if (mc_type_name == mc::DUMMY_TYPE_NAME) {
         addError("Dummy type found for variable '" + evar + "'. You'll need to resolve the type manually.");
      }
   }

   if (!kratos) {
      s += ";";
   }

   s += "\n";

   return s;
}

std::string vfm::CppParser::getCommandLineArgument() const
{
   return command_line_argument_;
}

void vfm::CppParser::addConstraint(const std::string& constraint_raw, std::vector<TermPtr>& constraint_list, const std::shared_ptr<FormulaParser> parser_raw) {
   auto constraint = constraint_raw;
   auto parser = parser_raw ? parser_raw : parser_;

   StaticHelper::preprocessCppConvertArraysToCStyle(constraint);
   StaticHelper::preprocessCppConvertCStyleArraysToVars(constraint);

   auto fmla = MathStruct::parseMathStruct(constraint, parser, data_)->toTermIfApplicable();
   constraint_list.push_back(fmla);
   list_of_nusmv_constraints_.push_back(fmla); // Store all constraints in FSM for later reference.
   addNote("Parsed and stored nuSMV constraint: '" + fmla->serializeNuSMV(data_, parser_) + "'.");
}

bool vfm::CppParser::checkConstraintsForConsistency(const std::map<std::string, CppTypeWithQualifiers>& types_of_variables) const
{
   addNote("Checking all nusmv constraints (INIT, INVAR, LTL, CTL, Kratos SPEC) for consistency.");

   bool all_ok{ true };

   for (const auto& constraint : list_of_nusmv_constraints_) {
      bool fine = true;

      constraint->applyToMeAndMyChildren([&types_of_variables, &constraint, this, &fine](const MathStructPtr m) {
         if (m->toVariableIfApplicable()) {
            auto m_var_name = m->toVariableIfApplicable()->getVariableName();

            if (!types_of_variables.count(m_var_name)) {
               std::vector<std::string> known_vars_temp; // TODO: Very inefficient, but who cares, since the OP made an error.

               for (const auto& pair : types_of_variables) {
                  known_vars_temp.push_back(pair.first);
               }

               auto match = std::get<0>(StaticHelper::findClosest(known_vars_temp, m_var_name));
               std::string suggestion = match >= 0 && match < known_vars_temp.size() ? " Did you mean '" + known_vars_temp.at(match) + "'?" : "";
               addError("Variable '" + m_var_name + "' in nusmv constraint '" + m->serializeWithinSurroundingFormula(100, 100) + "' is unknown." + suggestion);
               fine = false;
            }
         }
         });

      addError("Constraint '" + constraint->serializeNuSMV(data_, parser_) + "' is " + (fine ? OK_COLOR + "FINE" : FAILED_COLOR + "MALFORMED") + RESET_COLOR + ".", (fine ? ErrorLevelEnum::note : ErrorLevelEnum::error), "\n");
      all_ok = all_ok && fine;
   }

   return all_ok;
}

void vfm::CppParser::dumpCurrentState(const std::string& path) 
{
   addNote("Dumping current state of CppParser in '" + path + "'.");
   StaticHelper::writeTextToFile(toStringCppParser(), path);
}

bool vfm::CppParser::performCodeGenerationAndMCCodeCreation(
   const char* path_to_file_list_file_code, 
   const char* path_to_file_list_file_env_model, 
   const char* target_path_for_generated_code, 
   const bool create_live_pdf)
{
   std::string target_path_for_env_model(target_path_for_generated_code);
   target_path_for_env_model += "_envmodel.cpp";

   const auto DO_ENVMODEL = [this, &target_path_for_generated_code, &path_to_file_list_file_env_model, &create_live_pdf, &target_path_for_env_model](
      bool& success_env_model, std::string& path_to_envmodel_file, const std::vector<std::string>& template_options) {
      createTitleString(this, "environment model");
      success_env_model = performFSMCodeGenerationWrapper(path_to_file_list_file_env_model, target_path_for_env_model.c_str(), create_live_pdf, path_to_envmodel_file, template_options, false);
      dumpCurrentState(StaticHelper::removeLastFileExtension(std::string(target_path_for_generated_code), "/") + "/dump2_after_envmodel_parsing.log");
   };

   writeMortyGUIProgressFile(2, "topology generator");

   const std::string path_to_file_list_file_env_model_string = path_to_file_list_file_env_model;
   has_envmodel_ = !path_to_file_list_file_env_model_string.empty();
   bool success_code = true, success_env_model = true;

   addDebug("Clearing list of former '" + GLOBAL_FAILABLE_NAME + "' errors, warnings etc.");
   auto template_options = processTemplateOptions(std::string(path_to_file_list_file_env_model));
   Failable::getSingleton(GLOBAL_FAILABLE_NAME)->resetAllErrors();
   std::string generated_name{};
   std::string path_to_envmodel_file{ getFullPathToStoreCachedVersionIn(generated_name, path_to_file_list_file_env_model, target_path_for_env_model, template_options) };       // The env model file is needed for main.smv generation to retrieve the timescaling data.
   std::string path_to_envmodel_file_dummy{}; // Used for second run where no env model is generated.


   if (has_envmodel_ && !data_->getSingleVal("EM_LESS")) {
      DO_ENVMODEL(success_env_model, path_to_envmodel_file, template_options);
   }
   else {
      addNote("No environment model given. Skipping creation of combined FSM.");
   }

   writeMortyGUIProgressFile(35, "planner parsing");

   createTitleString(this, "tactical planner");
   success_code = performFSMCodeGenerationWrapper(path_to_file_list_file_code, target_path_for_generated_code, create_live_pdf, path_to_envmodel_file_dummy, template_options, has_envmodel_);
   dumpCurrentState(StaticHelper::removeLastFileExtension(std::string(target_path_for_generated_code), "/") + "/dump3_after_planner_parsing.log");

   writeMortyGUIProgressFile(55, "combined model");

   if (has_envmodel_) {
      createTitleString(this, "combined model");
      postprocessFinalModel();
   }
   else { // TODO: How long do we even want to support the EM-less mode?
      createTitleString(this, "EM-less final model");

      for (const auto& el : global_primitives_aka_descriptions_) {
         addWarning("No environment model given, but AKA notation '" + el.first + "' => '" + StaticHelper::fromSafeString(StaticHelper::replaceAll(el.second, ".", "")) + "' found in the (planner) code.");
      }

      postprocessFinalModel();
   }

   writeMortyGUIProgressFile(87, "collecting results");

   if (!options_.isGatekeeper()) {
      addNote("Creating result files.");
      createResultFiles(target_path_for_generated_code, mc_specs_, path_to_file_list_file_env_model, path_to_envmodel_file);
   }

   if (has_envmodel_ && data_->getSingleVal("EM_LESS")) {
      writeMortyGUIProgressFile(93, "em-less generation");
      addNotePlain("*** EM-less EnvModel Generation ***");
      generateEnvModel(path_to_file_list_file_env_model, target_path_for_env_model, template_options);
   }

   writeMortyGUIProgressFile(100, "finalizing");

   dumpCurrentState(StaticHelper::removeLastFileExtension(std::string(target_path_for_generated_code), "/") + "/dump4_after_full_run.log");

   deleteMortyGUIProgressFile();

   return success_code && success_env_model && !hasErrorOccurred();
}

std::ofstream logfile;

void printVfmIntro(const vfm::CppParser& cppp, const std::string& target_path_for_generated_code)
{
   logfile.open(target_path_for_generated_code + ".log");
   cppp.addOrChangeErrorOrOutputStream(logfile, true);
   cppp.addOrChangeErrorOrOutputStream(logfile, false);

   // http://patorjk.com/software/taag/#p=display&h=1&c=echo&f=Cricket&t=vfm
   cppp.addNotePlain("          ___              __      __   ");
   cppp.addNotePlain(" .--.--..'  _|.--------. _|  |_  _|  |_ ");
   cppp.addNotePlain(" |  |  ||   _||        ||_    _||_    _|");
   cppp.addNotePlain("  \\___/ |__|  |__|__|__|  |__|    |__|  ");
   cppp.addNotePlain("    very fast math       CodeGeneration \n\n");

   if (cppp.getCommandLineArgument().empty()) {
      cppp.addNote("No additional command line input given.");
   }
   else {
      cppp.addNote("Appending this command line input to the program to parse:");
      cppp.addNotePlain("----------------------------------------------------------");
      cppp.addNotePlain(cppp.getCommandLineArgument());
      cppp.addNotePlain("----------------------------------------------------------\n");
   }
}

void printVfmOutro(const bool result, const vfm::CppParser& cppp, const std::chrono::nanoseconds& parsing_time)
{
   std::string succeeded_str = (result ? OK_COLOR + "SUCCESS" : FAILED_COLOR + "FAILED") + RESET_COLOR;

   cppp.addNotePlain("\n  ______  ______  ______  ______  ______  ______ ");
   cppp.addNotePlain(" |______||______||______||______||______||______|");
   cppp.addNotePlain("   EO very fast math   CodeGeneration <" + succeeded_str + ">\n\n");

   cppp.addNotePlain("Elapsed time: " + OK_COLOR + StaticHelper::printTimeFormatted(parsing_time) + RESET_COLOR + ".\n");

   if (!result) {
      cppp.addNotePlain(BOLD_COLOR + "Summary of errors:" + RESET_COLOR);
      cppp.printAndThrowErrorsIfAny(true, false);
   }

   int num_warning = cppp.hasErrorOccurred(ErrorLevelEnum::warning);
   if (num_warning) {
      cppp.addNotePlain("\nThere have been " + std::to_string(num_warning) + " warnings.");

      cppp.addNotePlain(BOLD_COLOR + "Summary:" + RESET_COLOR);
      cppp.printAndThrowErrorsIfAny(true, false, ErrorLevelEnum::warning);
   }

   cppp.addNotePlain("\n\nFor more information please contact: "
      + SPECIAL_COLOR + AUTHOR_NAME + " (" + AUTHOR_SHORT + "; " + AUTHOR_EMAIL + ")." + RESET_COLOR);

   logfile.close();
}

extern "C"
bool performFSMCodeGeneration(
   const char* path_to_file_list_file_code, 
   const char* path_to_file_list_file_env_model, 
   const char* target_path_for_generated_code,
   const char* command_line_argument)
{
   std::string cmd_line_arg{ command_line_argument };
   CppParser cppp{ "\n" + VFM_BEGIN + "\n" + std::string(command_line_argument) + "\n" + VFM_END + "\n" };
   printVfmIntro(cppp, std::string(target_path_for_generated_code));

   std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
   bool result = cppp.performCodeGenerationAndMCCodeCreation(path_to_file_list_file_code, path_to_file_list_file_env_model, target_path_for_generated_code, CREATE_LIVE_PDF);
   std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
   
   printVfmOutro(result, cppp, end - begin);
   return result;
}
